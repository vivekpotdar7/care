<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
  <Workflow created="1603302492655" id="0a111e58754c15ea81754c4689ef016a" libraries="Identity" name="Do Provisioning Forms" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="project" output="true" required="true">
      <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will 
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
    </Variable>
    <Variable input="true" name="formTemplate" required="true">
      <Description>
      The name of the Form object that will be the template for
      generated forms.
    </Description>
    </Variable>
    <Variable input="true" name="preferredOwner">
      <Description>
      Optional argument to buildProvisioningForm to pass in the name of
      an identity we should try to process first when feeding
      forms back to the workflow.  If there are no questions for that
      identity and there are questions for other identities, a form for
      one of the other identities is generated at random.  When set the
      value is usually the same as "sessionOwner" a built-in system variable
      containing the name of the user currently interacting with a 
      workflow session.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority of any generated workitems.
    </Description>
    </Variable>
    <Variable input="true" name="requiredOwner">
      <Description>
      Optional argument to buildProvisioningForm to pass in the name of
      an identity we should try to process first when feeding
      forms back to the workflow.  If there are no questions for that
      identity and there are questions for other identities, no form is 
      returned and the workflow may terminate without answering all of the
      questions in the project.

      This variable should only be on if you want to generate provisioning
      forms for the requester before approval. When called after approval (from Identity Request Provision),
      we don't pass in this attribute and all the rest of the provisioning forms can be generated.
    </Description>
    </Variable>
    <Variable input="true" name="fallbackOwner">
      <Description>
      Optional argument to specify a fallback identity to own Forms when nothing else is specified.
    </Description>
    </Variable>
    <Variable input="true" name="accountSelectionOwner">
      <Description>
      Optional argument to buildAccountSelectionForm to specify identity that owns the Form.
    </Description>
    </Variable>
    <Variable input="true" name="disableManualAccountSelection">
      <Description>
      When set to 'true' the system will not send out Account Selection Notification emails 
      for users with more than one account on any one application and the system 
      can't determine the provisioning account.
      This is only passed in from Identity Refresh workflow.
    </Description>
    </Variable>
    <Variable name="workItemForm">
      <Description>
      Holds the assembled provisioning form for this user. This is generated
      dynamically and passed into a work item for presentation.  
      During rendering the new field values are saved in the form fields.  
      When the work item is assimilated, we copy the form from the work
      item back to this variable for further processing.
      
      Note that this must be named workItemForm if you want to use it
      in the "send" list of an Approval.  This is the name recognized
      by WorkItemFormBean.  If you need to use a different name, or
      have multiple forms then you will need to use an Arg in the Approval
      to do the name translation.
    </Description>
    </Variable>
    <Variable name="formOwnerError">
      <Description>
      Set to true if we ever have difficulty determining a form owner.
      Used to break out of the provisioning loop.  This really shouldn't
      be necessary but be safe.
    </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
     Global comments list which should be appended to the comments list ofr
     each approval.
    </Description>
    </Variable>
    <Variable name="accountSelectionForm">
      <Description>
      Dynamic account selection form generated when target account is ambiguous.
    </Description>
    </Variable>
    <Variable name="calculatedAccountSelectionOwner">
      <Description>
      Calculated owner value for account selection form.
    </Description>
    </Variable>
    <Step icon="Start" name="start" posX="33" posY="16">
      <Transition to="Get Account Selection Owner"/>
    </Step>
    <Step action="call:getAccountSelectionOwner" condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; (project.hasUnansweredProvisioningTargets() || project.hasUnansweredAccountSelections())" name="Get Account Selection Owner" posX="372" posY="12" resultVariable="calculatedAccountSelectionOwner">
      <Arg name="accountSelectionOwner" value="ref:accountSelectionOwner"/>
      <Arg name="owner" value="ref:requiredOwner"/>
      <Arg name="preferredOwner" value="ref:preferredOwner"/>
      <Arg name="fallbackOwner" value="ref:fallbackOwner"/>
      <Transition to="Build Account Selection Form"/>
    </Step>
    <Step action="call:buildAccountSelectionForm" condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; project.hasUnansweredProvisioningTargets()" name="Build Account Selection Form" posX="561" posY="12" resultVariable="accountSelectionForm">
      <Arg name="project" value="ref:project"/>
      <Arg name="owner" value="ref:calculatedAccountSelectionOwner"/>
      <Description>
      Call the standard handler method to build the account selection form.
    </Description>
      <Transition to="Present Account Selection Form"/>
    </Step>
    <Step condition="script:!isNull(accountSelectionForm)" name="Present Account Selection Form" posX="561" posY="12">
      <Approval owner="script:accountSelectionForm.getTargetUser()" send="identityName,identityDisplayName,launcher">
        <AfterScript>
          <Source>
          import sailpoint.object.Form;
          import sailpoint.object.ProvisioningTarget;
          import sailpoint.object.AccountSelection;
          import sailpoint.object.Field;

          Form accountSelectionForm = item.getForm();
          
          Iterator fieldIterator = accountSelectionForm.iterateFields();

          List targets = project.getProvisioningTargets();
          
          //apply selected value to matching AccountSelection
          //if accountSelectionId, then apply to the first unanswered AccountSelection
          while (fieldIterator.hasNext()) {
              Field fld = (Field)fieldIterator.next();
              if (fld == null) 
                continue;

              Integer targetIndex = (Integer)fld.getAttribute("targetIndex");
              Integer selectionIndex = (Integer)fld.getAttribute("selectionIndex");
              
              if (targetIndex == null || selectionIndex == null) continue;
                            
              ProvisioningTarget target = (ProvisioningTarget) targets.get(targetIndex.intValue());
              
              List selections = target.getAccountSelections();
              AccountSelection selection = (AccountSelection) selections.get(selectionIndex.intValue()); 
                 
              if (selection.isAnswered()) continue;
              
              if (fld.getValue().equals("doCreateOpt")) {
                selection.setDoCreate(true);
              }
              else {
                selection.setSelection(fld.getValue());
              }
          }
          
        </Source>
        </AfterScript>
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="Role Account Selection for $(identityDisplayName)"/>
        <Arg name="workItemForm" value="ref:accountSelectionForm"/>
        <Arg name="workItemDisableNotification">
          <Script>
            <Source>
           
            // If this is interactive then don't bother sending email notifications.
            return (null != sessionOwner) &amp;&amp; !sessionOwner.equals("System") &amp;&amp; !sessionOwner.equals("Scheduler");
            
          </Source>
          </Script>
        </Arg>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c4688c1015d" name="Account Selection Notification"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Description>
      Present the account selection form and check to make sure all account selections were made.
    </Description>
      <Transition to="Handle Old Account Selections"/>
    </Step>
    <Step condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; project.hasUnansweredAccountSelections()" name="Handle Old Account Selections" posX="561" posY="12">
      <Approval owner="ref:calculatedAccountSelectionOwner" renderer="accountSelectionRenderer.xhtml">
        <AfterScript>
          <Source>
          import sailpoint.object.Attributes;
          import sailpoint.api.Provisioner;

          // Set the account selections back on the project.  Later these will
          // be consulted when the native identities are resolved.
          List accountSelections = approval.get("accountSelectionsFromWorkItem");
          project.setAccountSelections(accountSelections);

          // Recompile project so that selected native identities get put into
          // provisioning plans.
          Provisioner p = new Provisioner(wfcontext.getSailPointContext());
          Attributes args = wfcontext.getStepArguments();
          p.recompile(project, args);
        </Source>
        </AfterScript>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Account Selection for User: $(identityDisplayName)"/>
        <Arg name="workItemDisableNotification">
          <Script>
            <Source>
           
            // If this is interactive then don't bother sending email notifications.
            return (null != sessionOwner) &amp;&amp; !sessionOwner.equals("System") &amp;&amp; !sessionOwner.equals("Scheduler");
            
          </Source>
          </Script>
        </Arg>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="accounts" value="script:project.getAccountSelections()"/>
        <Arg name="expansionItems" value="script:project.getExpansionItems()"/>
        <Arg name="identityDisplayName" value="$(identityDisplayName)"/>
        <Arg name="identityName" value="$(identityName)"/>
        <Return local="true" name="accounts" to="accountSelectionsFromWorkItem"/>
        <ValidationScript>
          <Source>
          import sailpoint.object.AccountSelection;
          import sailpoint.tools.Util;

          // The return has not yet been processed since we're in the validator
          // script.  Grab the account selections from the work item.
          List accountSelections = item.getAttribute("accounts");

          // Make sure that all account selections have decisions.
          for (AccountSelection sel : accountSelections) {
              if (Util.isEmpty(sel.getSelectedNativeIdentities())) {
                  return "Please make a selection for each application.";
              }
          }
          return null;
        </Source>
        </ValidationScript>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c4688c1015d" name="Account Selection Notification"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Description>
      There are two ways to model account selections.  Pre 6.3 workflows use a 
      top-level List of AccountSelection objects on the project.  6.3 added a List
      of ProvisioningTarget objects.  We need to handle both, but there will never
      be a combination of them in the same workflow case.  This step handles
      the old model.
    </Description>
      <Transition to="Recompile Provisioning Project"/>
    </Step>
    <Step action="call:recompileProject" name="Recompile Provisioning Project" posX="99" posY="112" resultVariable="project">
      <Arg name="project" value="ref:project"/>
      <Description>
      Recompile the project.
    </Description>
      <Transition to="Build Provisioning Form"/>
    </Step>
    <Step action="call:buildProvisioningForm" name="Build Provisioning Form" posX="99" posY="112" resultVariable="workItemForm">
      <Arg name="project" value="ref:project"/>
      <Arg name="template" value="ref:formTemplate"/>
      <Arg name="owner" value="ref:requiredOwner"/>
      <Arg name="preferredOwner" value="ref:preferredOwner"/>
      <Arg name="fallbackOwner" value="ref:fallbackOwner"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Description>
      Call the standard handler method to build the provisioning form
      from the specified template and question list.
    </Description>
      <Transition to="Present Provisioning Form"/>
    </Step>
    <Step condition="script:!isNull(workItemForm)" name="Present Provisioning Form" posX="99" posY="252">
      <Approval owner="script:workItemForm.getTargetUser()" return="workItemForm" send="identityName,identityDisplayName,workItemForm,launcher">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="Complete provisioning form for $(identityDisplayName)"/>
        <Arg name="workItemDisableNotification">
          <Script>
            <Source>
            
            // 
            // If this is interactive then don't bother sending email
            // notifications.
            // 
            // There is some subtle logic here. Basically requiredOwner
            // is null most of the time except in the case of pre-approval
            // forms. In that case we want to return the forms for the
            // required owner so they can fill it in during the request
            // process instead of waiting on a workitem.  
            //
            boolean disableEmail = false;
            String owner = ( requiredOwner != null ) ? requiredOwner : sessionOwner;
            if ( Util.nullSafeEq(owner, workItemForm.getTargetUser()) ) { 
                disableEmail = true;
            }
            return disableEmail;
            
          </Source>
          </Script>
        </Arg>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c4688be015c" name="Provisioning Form Notification"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Description>
      Present the form we calculated in the previous step.
      TODO: Need something more formal to determine who the owner
      of this should be.
    </Description>
      <Transition to="Assimilate Provisioning Form"/>
    </Step>
    <Step action="call:assimilateProvisioningForm" condition="script:!isNull(workItemForm)" name="Assimilate Provisioning Form" posX="314" posY="252" resultVariable="project">
      <Arg name="project" value="ref:project"/>
      <Arg name="form" value="ref:workItemForm"/>
      <Description>
      Assimilate the results of the provisioning form back into the workflow.
      This may result in the generation of another set of questions for
      a different user.  Assimilation can also theoretically generate new
      questions for the same user if some of the template fields had
      conditional rendering.

      You can pass things into the Template and Field scripts by
      defining Args in this step.  You cannot change plan copmiler
      options, those were specified in the call to compileProvisioningProject
      and stored in the project for recompilation and execution.

      A new project is returned, but actually it will always be the
      same as the project passed in.
    </Description>
      <Transition to="Build Provisioning Form" when="(project != null &amp;&amp; project.hasQuestions()) &amp;&amp; !isNull(workItemForm)"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="853" posY="12"/>
  </Workflow>
  <Workflow created="1603302492692" id="0a111e58754c15ea81754c468a14016c" libraries="Identity" name="Do Manual Actions" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="project" output="true" required="true">
      <Description>
      A ProvisioningProject object describing the modifications to the identity.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority any generated workitems.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable input="true" name="doAudit">
      <Description>
      When true we will audit the completion of manual action work items.
    </Description>
    </Variable>
    <Description>
     Preset the unmanaged portion of a provisioning project as work items
     to be processed manually.  This is used by the Identity Update and
     Identity Refresh workflows.  LCM has a similar step but it audits
     differently. Need to reconsider this and see if we can share the
     same subprocess.
   </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
    </RuleLibraries>
    <Step icon="Approval" name="Manual Actions">
      <Approval mode="parallelPoll" owner="rule:Build Manual Action Approvals" renderer="lcmManualActionsRenderer.xhtml" send="identityDisplayName,identityName">
        <AfterScript>
          <Source>
          // Mark all items finished, LCM workflows do this for the dashboard
          // widget that tracks provisioning completion (the closed loop).
          // I'm not sure if we need that here, depends on which TaskResults
          // the scanner looks at, but be consistent.

          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;

          // must be a leaf approval
          if (item != null) {
            ApprovalSet set = (ApprovalSet)item.get("approvalSet");
            if ( set != null ) {
                List approvalItems = set.getItems();
                for ( ApprovalItem approvalItem : approvalItems ) {
                    approvalItem.setState(WorkItem.State.Finished);
                }
            }

            // Audit the manual change
            // this is in LCM Workflow Library, if we think we need the
            // same level of auditing this will have to be brought over
            // to IdentityLibrary
            // if (doAudit)
            //   auditManualAction(item);
          }
        </Source>
        </AfterScript>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Manual Changes requested for User: $(identityDisplayName)"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemType" value="ManualAction"/>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c468a0d016b" name="Pending Manual Changes"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Description>
      Build an Approval structure for the unmanaged plan in the provisioning project.
      The construtor is in the rule "Build Manual Action Approvals" that expects
      to be passed launcher, project, identityName, and fallbackApprover.
    </Description>
    </Step>
  </Workflow>
  <Workflow created="1603302492710" id="0a111e58754c15ea81754c468a26016d" libraries="Identity,IdentityRequest" name="Provision with retries" type="Subprocess">
    <Variable input="true" name="project" output="true" required="true">
      <Description>
      Project that will be provisioned.
    </Description>
    </Variable>
    <Variable initializer="script:new Integer(60);" input="true" name="provisioningRetryThreshold" type="integer">
      <Description>
      The interval in minutes to wait to retry the request defaults to 
      60 minutes.  The retryInterval will be read from the underlying
      applications involved in the retry provisioning activity and
      the max interval defined across all applications will be used .
      If an interval is not specified on any of the Applications 
      we'll fall back to the setting in this variable which defaultws
      to an hour.
    </Description>
    </Variable>
    <Variable editable="true" initializer="script:new Integer(-1);" input="true" name="provisioningMaxRetries" type="integer">
      <Description>
       The maximum number of retries that will be attempted before failure 
       of the provisioning activities.  A value of -1 will execute
       retries indefinetly.
 
       Like provisioningRetry the value will be read from the
       application, if not defined on the application 
       we'll fall back to this setting which will default to -1.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the retries loop and let the 
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" input="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the resutls of the request.
    </Description>
    </Variable>
    <Variable editable="true" input="true" name="recompileBeforeProvisioning">
      <Description>
      True to recompile the project prior to calling the Provisioner. This is useful when background
      provisioning is enabled, to pick up any changes that might have happened between the time the
      workflow was backgrounded, and the time in which it is resumed.
    </Description>
    </Variable>
    <Variable input="true" name="disableIdentityRequests">
      <Description>
      May be passed by the calling workflow to disable processing of
      IdentityRequest objects after provisioning.  This option should
      be passed by any workflow that is not used by LCM and does not
      maintain the IdentityRequest model.  This avoids logging a warning
      when the IdentityRequest is not found.
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
      The ID of the IdentityRequest for this request.
    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="retries" output="true" type="integer">
      <Description>
       The number of retries performed during the execution
       of the provisioning activities.
    </Description>
    </Variable>
    <Variable name="retryProject">
      <Description>
      Project that is assembled for retry purposes, the parts of
      original plan are broken into a separate plan that includes
      only the account requests that need to be retried.

      After each visit to retr this project will be rebuilt after
      the previous execution results are assimimlated back onto
      the "main" project.
    </Description>
    </Variable>
    <Variable input="true" name="splitProvisioning">
      <Description>
            True to denote this is a partial of the full ProvisioningPlan. This should be true in the case of LCM Provisioning
            splits.
        </Description>
    </Variable>
    <Step icon="Start" name="Start" posX="17" posY="104">
      <Transition to="Initialize Retries"/>
    </Step>
    <Step icon="Task" name="Initialize Retries" posX="101" posY="104">
      <Description>
      When visiting for the first time initalize the 
      retry variable and avoid the sleep that we'll 
      want when looping for retries.
    </Description>
      <Script>
        <Source>
        if ( retries == null ) { 
            retries = new Integer(0); 
        } else {
            retries++;
        }
        wfcontext.getWorkflowCase().put("retries", retries);
      </Source>
      </Script>
      <Transition to="Wait for next retry" when="script:(retries > 0)"/>
      <Transition to="Provision"/>
    </Step>
    <Step name="Wait for next retry" posX="159" posY="17" wait="ref:retryInterval">
      <Description>
      This is a sleep step and just waits to execute the next step.
      Typically only called when we are retrying to give us some delay
      between calls down to the PE. Skipped during the first loop.
    </Description>
      <Transition to="Provision Retry"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision" posX="258" posY="100">
      <Arg name="project" value="ref:project"/>
      <Arg name="background" value="!ref:foregroundProvisioning"/>
      <Description> 
       Call the typical provisionProject method during our first time
       through the workflow.  If there are retries this step
       will be skipped and should fall into the "Retry Provision"
       step.

       The only thing special here is the flag we specify to
       the PlanEvaluator to prevent the Request object from
       from being created if there are retries in the project.
       Then we can handle them directly in the workflow looping 
       until we are complete.
    </Description>
      <Transition to="Refresh Identity Request"/>
    </Step>
    <Step action="call:refreshIdentityRequestAfterProvisioning" name="Refresh Identity Request" posX="365" posY="100">
      <Arg name="project" value="ref:project"/>
      <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
      <Description> 
       Refresh the identity request to include provisioning results and
       any other provisioning side effects in the project.
       
       Note that the disableIdentityRequests input variable is passed
       to skip request processing if we're being called from a non-LCM workflow.
       It is easier to pass this option than to transition around this step.
    </Description>
      <Transition to="Check for retry" when="!ref:enableRetryRequest"/>
      <Transition to="End" when="ref:enableRetryRequest"/>
    </Step>
    <Step action="call:retryProvisionProject" icon="Provision" name="Provision Retry" posX="421" posY="17" resultVariable="retryProject">
      <Arg name="project" value="ref:retryProject"/>
      <Arg name="disableRetryRequest" value="true"/>
      <Description> 
       Call retryProvisionProject method that will retry the plans
       in the project. Notice we pass in the retryProject which 
       contains only the parts of the main project that need
       to be retried.
    </Description>
      <Transition to="Merge Retry Project Results"/>
    </Step>
    <Step action="call:mergeRetryProjectResults" name="Merge Retry Project Results" posX="603" posY="17" resultVariable="project">
      <Arg name="project" value="ref:project"/>
      <Arg name="retryProject" value="ref:retryProject"/>
      <Description>
       Merge the results from the retry project back into the project.
       This step will take and items that are no longer marked rety
       over to the orginal project.
    </Description>
      <Transition to="Check for retry"/>
    </Step>
    <Step action="call:assembleRetryProject" icon="Task" name="Check for retry" posX="603" posY="98" resultVariable="retryProject">
      <Arg name="project" value="ref:project"/>
      <Description> 
       Dig into the project and look for things marked retryable.
       Build an new plan that contains only the retryable parts.
    </Description>
      <Transition to="Update Identity Request"/>
    </Step>
    <Step action="call:refreshIdentityRequestAfterRetry" condition="script:(retryProject != null)" name="Update Identity Request" posX="49" posY="262">
      <Arg name="project" value="ref:retryProject"/>
      <Description> 
       Update the Identity Request object with the retry details.
    </Description>
      <Transition to="Calculate Max Retry"/>
    </Step>
    <Step action="call:getProvisioningMaxRetries" name="Calculate Max Retry" posX="178" posY="262" resultVariable="provisioningMaxRetries">
      <Arg name="project" value="ref:retryProject"/>
      <Description> 
       Calculate the provisioningMaxRetries variable by digging into the
       retry project in an attempt to resolve the provisioningMaxRetries
       from the applications that are involved falling back
       to a system config.

       Use the provisioningMaxRetries to drive if we continue to loop or end.
    </Description>
      <Transition to="Calculate Retry Threshold"/>
    </Step>
    <Step action="call:getProvisioningRetryThreshold" name="Calculate Retry Threshold" posX="309" posY="262" resultVariable="retryInterval">
      <Arg name="project" value="ref:retryProject"/>
      <Description> 
       Calculate the retryInterval variable by digging into the
       retry project in an attempt to resolve the provisioningMaxRetries
       from the applications that are involved falling back
       to the workflow setting.
    </Description>
      <Transition to="Start" when="script:( ( retryProject != null ) &amp;&amp; ( provisioningMaxRetries == -1 || retries &lt; provisioningMaxRetries ) )"/>
      <Transition to="Timeout" when="script:( ( retryProject != null ) &amp;&amp;( retries >= provisioningMaxRetries ) )"/>
      <Transition to="Check for more provisioning"/>
    </Step>
    <Step name="Check for more provisioning" posX="472" posY="259" resultVariable="project">
      <Description>
      There may be cases when dependencies that were waiting on a dependency will still have to be fulfulled,
      for those cases loop back to provisioning.
    </Description>
      <Script>
        <Source>
        if ( project.hasUnfinishedIntegrationPlans() ) {
            project.put("disableProjectReset", true);
        }
        return project;
      </Source>
      </Script>
      <Transition to="Provision" when="script: ( ( project != null ) &amp;&amp; (project.hasUnfinishedIntegrationPlans()) ) ;"/>
      <Transition to="End"/>
    </Step>
    <Step action="call:forceRetryTimeoutFailure" name="Timeout" posX="374" posY="413" resultVariable="project">
      <Arg name="message" value="Retry timeout occured."/>
      <Arg name="project" value="ref:project"/>
      <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
      <Arg name="retryProject" value="ref:retryProject"/>
      <Description> 
       Go back through the project and mark everything that was being
       retried to failure.
    </Description>
      <Transition to="Update Identity Request with timeouts failures"/>
    </Step>
    <Step action="call:refreshIdentityRequestAfterProvisioning" name="Update Identity Request with timeouts failures" posX="539" posY="413">
      <Arg name="project" value="ref:project"/>
      <Description> 
       Update the Identity Request object with the failures that were added to
       the project due to retry timeout.
    </Description>
      <Transition to="End"/>
    </Step>
    <Step icon="Stop" name="End" posX="695" posY="413"/>
  </Workflow>
  <Workflow created="1603302492720" id="0a111e58754c15ea81754c468a2e016e" libraries="Identity,IdentityRequest" modified="1615816285817" name="Check Status of queued items" type="Subprocess">
    <Variable input="true" name="project" output="true" required="true">
      <Description>
      Project that has account requests in the QUEUED state.
    </Description>
    </Variable>
    <Variable initializer="script:new Integer(5);" input="true" name="provisioningStatusCheckInterval" type="integer">
      <Description>
      The interval in minutes to retry the check status call,
      defaults to 1 hour.
    </Description>
    </Variable>
    <Variable initializer="script:new Integer(-1);" name="provisioningMaxStatusChecks" type="integer">
      <Description>
       The maximum number of status checks that will be tried before failure 
       of the provisioning activities.  A value of -1 will execute
       indefinetly, which is the default.
    </Description>
    </Variable>
    <Variable input="true" name="disableIdentityRequests">
      <Description>
      May be passed by the calling workflow to disable processing of
      IdentityRequest objects after provisioning.  This option should
      be passed by any workflow that is not used by LCM and does not
      maintain the IdentityRequest model.  This avoids logging a warning
      when the IdentityRequest is not found.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="splitProvisioning">
      <Description>
      True to denote this is a partial of the full ProvisioningPlan. This should be true in the case of LCM Provisioning
      splits.
    </Description>
    </Variable>
    <Variable name="statusChecks" output="true" type="integer">
      <Description>
       The number of status checks performed during the execution
       of the provisioning activities.
    </Description>
    </Variable>
    <Step icon="Start" name="Start" posX="25" posY="233">
      <Transition to="Requires Check"/>
    </Step>
    <Step action="call:requiresStatusCheck" icon="Task" name="Requires Check" posX="134" posY="233" resultVariable="requiresStatusCheck">
      <Arg name="project" value="ref:project"/>
      <Description>
       Up front check to compute if the status check is necessary.

       Dig into the plan and check to see if any of the plan results have 
       queued items with requestIds??

       If both are not true, bail out -- otherwise enter a loop 
       that will checking for status.       
    </Description>
      <Transition to="Initialize Status Checks" when="script:(requiresStatusCheck)"/>
      <Transition to="Apply Committed Results"/>
    </Step>
    <Step icon="Task" name="Initialize Status Checks" posX="192" posY="119">
      <Description>
      When visiting for the first time initalize the 
      statusChecks counter variable and avoid the sleep that we'll 
      want when looping while checking status.
    </Description>
      <Script>
        <Source>
        if ( statusChecks == null ) { 
            statusChecks = new Integer(0); 
        } else {
            statusChecks++;
        }
        wfcontext.getWorkflowCase().put("statusChecks", statusChecks);
      </Source>
      </Script>
      <Transition to="Calculate Max Checks"/>
    </Step>
    <Step action="call:getProvisioningMaxStatusChecks" name="Calculate Max Checks" posX="344" posY="119" resultVariable="provisioningMaxStatusChecks">
      <Description> 
       Calculate the maxRetries variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to a system config.
    </Description>
      <Transition to="Calculate StatusCheck Threshold"/>
    </Step>
    <Step action="call:getProvisioningStatusCheckInterval" name="Calculate StatusCheck Threshold" posX="526" posY="119" resultVariable="provisioningCheckStatusInterval">
      <Arg name="project" value="ref:project"/>
      <Description> 
       Calculate the provisioningStatusCheckInterval variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to the workflow setting.
    </Description>
      <Transition to="CheckStatus" when="script:(statusChecks == 0)"/>
      <Transition to="Wait for next check"/>
    </Step>
    <Step name="Wait for next check" posX="584" posY="16" wait="ref:provisioningCheckStatusInterval">
      <Description>
       Pause and waiting for things to happen on the PE side.  
       Use the configurable interval to determine how long
       we wait in between checks.
    </Description>
      <Transition to="CheckStatus"/>
    </Step>
    <Step action="call:checkProvisioningStatus" name="CheckStatus" posX="730" posY="16" resultVariable="project">
      <Arg name="project" value="ref:project"/>
      <Description> 
       Call the connector's checkStatus method for each queued item found in a project.
       This method will also update the status on the plan as items complete.
    </Description>
    </Step>
    <Step action="call:refreshIdentityRequestAfterProvisioning" name="Refresh Identity Request" posX="730" posY="121">
      <Arg name="project" value="ref:project"/>
      <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
      <Description> 
       Refresh the identity request to include provisioning results returned
       from the connector's checkStatus any other provisioning side effects updated in the project.
       
       This method gives us the update of each access request item so it can
       be displayed in the UI as they complete instead of waiting for
       the entire process to complete.
       
       Note that the disableIdentityRequests input variable is passed
       to skip request processing if we're being called from a non-LCM workflow.
       It is easier to pass this option than to transition around this step.
    </Description>
      <Transition to="Requires Check" when="script:( provisioningMaxStatusChecks == -1 || statusChecks &lt; provisioningMaxStatusChecks)"/>
      <Transition to="Timeout" when="script:( statusChecks >= provisioningMaxStatusChecks )"/>
      <Transition to="Apply Committed Results"/>
    </Step>
    <Step action="call:addMessage" name="Timeout" posX="916" posY="118">
      <Arg name="message" value="Max number of status checks occurred."/>
      <Description> 
    </Description>
      <Transition to="Apply Committed Results"/>
    </Step>
    <Step action="call:applyCommittedResults" condition="script: return (statusChecks != null );" icon="Task" name="Apply Committed Results" posX="916" posY="229">
      <Arg name="project" value="ref:project"/>
      <Description>
      Apply any of the commited plans, account requests or attribute requests 
      that result from our checking the request status.
    </Description>
      <Transition to="End"/>
    </Step>
    <Step icon="Stop" name="End" posX="1116" posY="229"/>
  </Workflow>
  <Workflow created="1603302492733" id="0a111e58754c15ea81754c468a3d016f" libraries="Identity,IdentityRequest,Group" name="Manage Ticket" type="Subprocess">
    <Variable input="true" name="project" required="true">
      <Description>
      Project that is being provisioninged.
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId" output="true" required="true">
      <Description>
      The ID of the IdentityRequest object which can can be used to read/update 
      the external ticket id. 
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication" required="true">
      <Description>
      Ticketing application that supports creating/updating objects of type ticket.
    </Description>
    </Variable>
    <Variable input="true" name="ticketDataGenerationRule">
      <Description>
      A rule that builds up the ticketing provisioning plan based on the workflow
      context.  This rule gets all of the arguments to this subprocess 
      plus the curreent workflow context.  The rule can return either a 
      ProvisioningPlan or a Map of name value pairs. 
      
      The rule name can be specified here on the subprocess or on the 
      ticketManagementApplication config under the same name as this 
      variable.
    </Description>
    </Variable>
    <Variable input="true" name="action" required="true">
      <Description>
      This is a breadcrumb given to the rule to help it generate the proper
      provisioning plan for the current injection point.  There will be several
      default injection points that will map to an action.
     
      OOTB There are four points which all workflow are injected and will map to the
      "actions" passed into this subprocess.
     
      open
      postApproval
      postProvisioning
      close
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="ticketPlan">
      <Description>
      Plan that is generated during the processing of the ticektDataGenerationRule
      execution.  This will eventually be turned in to the ticketProject which can 
      be provisioned.
    </Description>
    </Variable>
    <Variable name="ticketProject">
      <Description>
      Variable that will hold our compiled project, that eventually will be 
      provisioned to the backend ticketing system.
    </Description>
    </Variable>
    <Variable input="true" name="ticketId" output="true">
      <Description>
      Variable that will hold the ticketId, it may be passed in for update
      and will be returned on create.  If this value is null AND the
      its not a create action, the ticket id will be read from 
      the identityRequest.externalTicketId field.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority of any workitems.
    </Description>
    </Variable>
    <Description>
   A workflow subprocss designed to allow service/help desk tickets opened
   or updated during the lifecycle of a workflow.
  </Description>
    <Step icon="Start" name="Start" posX="27" posY="12"/>
    <Step action="call:generateTicketPlan" name="Generate Ticket Plan" posX="132" posY="12" resultVariable="ticketPlan">
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="identityRequest" value="ref:identityRequest"/>
      <Arg name="action" value="ref:action"/>
      <Arg name="application" value="ref:ticketManagementApplication"/>
      <Arg name="rule" value="ref:ticketDataGenerationRule"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Description>
      A workflow service that will call to the generation rule to help
      generate an 'ObjectRequest' based provisioning plan that will be used to 
      create/update the ticket.  If the rule returns a plan that plan will be 
      returned directly by the buildTicketPlan call.  the rule returns a Map it will 
      be converted into a provisioning plan.
    </Description>
    </Step>
    <Step action="call:compileGroupProject" name="Compile Ticket" posX="251" posY="12" resultVariable="ticketProject">
      <Arg name="plan" value="ref:ticketPlan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="disableRetryRequest" value="true"/>
      <Arg name="optimisticProvisioning" value="false"/>
      <Description>
      Compile the generated plan in a project so it can be provisioned.
      These will normally compile down to a single targeted connector plan.      
    </Description>
    </Step>
    <Step icon="Task" name="Provision Ticket" posX="379" posY="12">
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:ticketProject"/>
      <Arg name="foregroundProvisioning" value="true"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
      project and checking policy violations.
    </Description>
      <Return name="retries" to="retries"/>
      <Return name="project" to="ticketProject"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a26016d" name="Provision with retries"/>
      </WorkflowRef>
      <Transition to="Update IdentityRequest External ID"/>
    </Step>
    <Step action="call:updateExternalTicketId" condition="script:( action.startsWith(&quot;open&quot;) );" name="Update IdentityRequest External ID" posX="551" posY="12" resultVariable="ticketId">
      <Arg name="project" value="ref:ticketProject"/>
      <Arg name="application" value="ref:ticketManagementApplication"/>
      <Description>
      Typically only called once, after the create of the ticket. This call will update
      the IdentityRequest.externalTicketId with the returned ticketId (String).
    </Description>
    </Step>
    <Step icon="Stop" name="End" posX="722" posY="12"/>
  </Workflow>
  <Workflow created="1603302492758" id="0a111e58754c15ea81754c468a560171" libraries="Role" name="Role Modeler - Impact Analysis" type="RoleModeler" workItemRenderer="workflow.xhtml">
    <Variable editable="true" name="doArchive" type="boolean">
      <Description>Set to true to enable archiving role versions.</Description>
      <Prompt>Enable Role Versioning</Prompt>
    </Variable>
    <Variable editable="true" initializer="true" name="doOverlapAnalysis" type="boolean">
      <Description>Set to true to enable role overlap analysis.</Description>
      <Prompt>Enable Overlap Enalysis</Prompt>
    </Variable>
    <Variable editable="true" name="doRoleAssignment" type="boolean">
      <Description>Set to true to enable role assignment analysis.</Description>
      <Prompt>Enable Role Assignment analysis</Prompt>
    </Variable>
    <Variable editable="true" initializer="100" name="maxGainLoss" type="int">
      <Description>Maximum number of Identities contained in the gains/loss list</Description>
      <Prompt>Gain/Loss Limit</Prompt>
    </Variable>
    <Variable editable="true" initializer="1" name="overlapThreshold" type="int">
      <Description>Minimum overlap percentage in any facet a role must have to be included in the result.</Description>
      <Prompt>Minimum Overlap Percentage</Prompt>
    </Variable>
    <Variable input="true" name="approvalObject">
      <Description>New version of role to approve</Description>
    </Variable>
    <Variable name="approvalType">
      <Description>Set to "delete" when deleting roles. Set to "rollback" when restoring a role archive.  Otherwise null.</Description>
    </Variable>
    <Variable input="true" name="approvalSource">
      <Description>
       Where in the UI we are requesting the approval.
       Values: modeler, directed, undirected, certification.
     </Description>
    </Variable>
    <Variable input="true" name="impactAnalysisOwner">
      <Description>Name of user to receive impact analysis result</Description>
    </Variable>
    <Variable initializer="call:getDisplayableRoleName" name="roleName">
      <Description>Role name referenced by the email templates</Description>
    </Variable>
    <Variable editable="true" initializer="false" name="noRolePropagation" type="boolean">
      <Description>Set to true to disable role change propagation.</Description>
    </Variable>
    <Step icon="Start" name="start">
      <Transition to="Impact Analysis"/>
    </Step>
    <Step action="launchImpactAnalysis" condition="script:!(impactAnalysisOwner == unbound || impactAnalysisOwner == null)" icon="Analysis" name="Impact Analysis" posX="141" posY="17">
      <Arg name="doOverlapAnalysis" value="ref:doOverlapAnalysis"/>
      <Arg name="overlapThreshold" value="ref:overlapThreshold"/>
      <Arg name="noApplicationTemplates" value="true"/>
      <Arg name="doRoleAssignment" value="ref:doRoleAssignment"/>
      <Arg name="maxGainLoss" value="ref:maxGainLoss"/>
      <Transition to="Review Analysis"/>
    </Step>
    <Step condition="script:!(impactAnalysisOwner == unbound || impactAnalysisOwner == null)" icon="Email" name="Review Analysis" posX="258" posY="17">
      <Approval owner="ref:impactAnalysisOwner">
        <Arg name="workItemDescription" value="Review impact analysis of $(call:getObjectClass): $(call:getDisplayableRoleName)"/>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c468a530170" name="Role Modeler - Impact Analysis Review"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Transition to="Commit"/>
    </Step>
    <Step action="commit" condition="script:(impactAnalysisOwner == unbound || impactAnalysisOwner == null) || approved" name="Commit" posX="375" posY="17">
      <Arg name="archive" value="ref:doArchive"/>
      <Transition to="stop"/>
    </Step>
    <Step icon="Stop" name="stop" posX="541" posY="17"/>
  </Workflow>
  <Workflow created="1603302492779" id="0a111e58754c15ea81754c468a6b0173" libraries="Role" name="Role Modeler - Owner Approval" type="RoleModeler" workItemRenderer="workflow.xhtml">
    <Variable editable="true" name="doArchive" type="boolean">
      <Description>Set to true to enable archiving role versions.</Description>
      <Prompt>Enable Role Versioning</Prompt>
    </Variable>
    <Variable editable="true" initializer="true" name="doOverlapAnalysis" type="boolean">
      <Description>Set to true to enable role overlap analysis.</Description>
      <Prompt>Enable Overlap Enalysis</Prompt>
    </Variable>
    <Variable editable="true" initializer="1" name="overlapThreshold" type="int">
      <Description>Minimum overlap percentage in any facet a role must have to be included in the result.</Description>
      <Prompt>Minimum Overlap Percentage</Prompt>
    </Variable>
    <Variable input="true" name="approvalObject">
      <Description>New version of role to approve</Description>
    </Variable>
    <Variable name="approvalType">
      <Description>Set to "delete" when deleting roles. Set to "rollback" when restoring an archive.  Otherwise null.</Description>
    </Variable>
    <Variable input="true" name="approvalSource">
      <Description>
       Where in the UI we are requesting the approval.
       Values: modeler, directed, undirected, certification.
     </Description>
    </Variable>
    <Variable input="true" name="impactAnalysisOwner">
      <Description>Name of user to receive impact analysis result</Description>
    </Variable>
    <Variable name="roleName">
      <Description>Role name referenced by the email templates</Description>
    </Variable>
    <Variable editable="true" initializer="false" name="noRolePropagation" type="boolean">
      <Description>Set to true to disable role change propagation.</Description>
    </Variable>
    <Step action="getDisplayableRoleName" icon="Start" name="start" resultVariable="roleName">
      <Description>
      Copy the role name to a variable for easier reference in the
      email template.  Skip to approvals if there is no impact
      analysis owner.
    </Description>
      <Transition to="Check Approvals" when="impactAnalysisOwner == unbound || impactAnalysisOwner == null"/>
      <Transition to="Impact Analysis"/>
    </Step>
    <Step action="launchImpactAnalysis" icon="Analysis" name="Impact Analysis" posX="167" posY="16">
      <Arg name="doOverlapAnalysis" value="ref:doOverlapAnalysis"/>
      <Arg name="overlapThreshold" value="ref:overlapThreshold"/>
      <Arg name="noApplicationTemplates" value="true"/>
      <Description>
      Call a handler method to launch the impact analysis task.
    </Description>
      <Transition to="Review Analysis"/>
    </Step>
    <Step icon="Email" name="Review Analysis" posX="276" posY="16">
      <Approval owner="ref:impactAnalysisOwner">
        <Arg name="workItemDescription" value="Review impact analysis of $(call:getObjectClass): $(call:getDisplayableRoleName)"/>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c468a530170" name="Role Modeler - Impact Analysis Review"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Description>
      Wait for review of the impact analyis report.
    </Description>
      <Transition to="stop" when="!approved"/>
      <Transition to="Check Approvals"/>
    </Step>
    <Step name="Check Approvals" posX="85" posY="125">
      <Description>
      Skip approvals if the launcher is also the (previous) role owner.
    </Description>
      <Transition to="Audit Success" when="call:isSelfApproval"/>
      <Transition to="Approve"/>
    </Step>
    <Step icon="Approval" name="Approve" posX="276" posY="222">
      <Approval owner="call:buildOwnerApproval">
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c468a680172" name="Role Modeler - Approval"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Description>
      Single stage approval by the role owner.
      The handler method will build a suitable Approval object.
    </Description>
      <Transition to="Audit Success" when="approved"/>
      <Transition to="Audit Failure" when="!approved"/>
    </Step>
    <Step action="audit" icon="Audit" name="Audit Failure" posX="423" posY="218">
      <Arg name="source" value="ref:launcher"/>
      <Arg name="action" value="call:getApprovalAuditAction"/>
      <Arg name="target" value="Role: $(roleName)"/>
      <Arg name="string1" value="failure"/>
      <Transition to="stop"/>
    </Step>
    <Step action="audit" icon="Audit" name="Audit Success" posX="334" posY="120">
      <Arg name="source" value="ref:launcher"/>
      <Arg name="action" value="call:getApprovalAuditAction"/>
      <Arg name="target" value="Role: $(roleName)"/>
      <Arg name="string1" value="success"/>
      <Transition to="Commit"/>
    </Step>
    <Step action="commit" name="Commit" posX="423" posY="120">
      <Arg name="archive" value="ref:doArchive"/>
      <Transition to="stop"/>
    </Step>
    <Step icon="Stop" name="stop" posX="423" posY="12"/>
  </Workflow>
  <Workflow created="1603302492802" id="0a111e58754c15ea81754c468a810174" libraries="Identity" name="Identity Refresh" resultExpiration="-1" type="IdentityRefresh">
    <Variable input="true" name="identitizer" transient="true" type="object">
      <Description>
      Instance of sailpoint.object.Identitizer that launched this workflow.
      This is a transient object that will only be used if the
      workflow executes synchronously to completion when launched.
      It saves having finishRefresh allocate and initialize a new Identitizer.
    </Description>
    </Variable>
    <Variable input="true" name="identity" transient="true" type="object">
      <Description>
      Identity object we're refreshing.  This is a transient object
      that will only be used by finishRefresh if the workflow runs to 
      completion without suspending.
    </Description>
    </Variable>
    <Variable input="true" name="refreshOptions" type="object">
      <Description>
      Map of options to configure Identitizer when we're ready to 
      complete the refresh.  These were culled from the original set of
      options given to the Identitizer that launched this workflow.
    </Description>
    </Variable>
    <Variable input="true" name="identityName" type="string">
      <Description>
      The name of the identity object being refreshed.  The first half
      of the refresh will have been committed, this includes link refresh,
      attribute promotion, and role detction.
    </Description>
    </Variable>
    <Variable input="true" name="project">
      <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will 
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
    </Variable>
    <Variable input="true" name="changeEvents">
      <Description>
      A list of IdentityChangeEvent objects generated by pre-provisioning
      triggers.
    </Description>
    </Variable>
    <Variable input="true" name="detectionDifference">
      <Description>
      A sailpoint.object.Difference object with changes made to the
      detected role list during the first half of the refresh.  These
      will already have been committed to the database.  In theory this
      could be used to trigger approvals or notifications though we 
      don't really support the notion of "rejecting" a detection.
    </Description>
    </Variable>
    <Variable input="true" name="previousVersion" type="object">
      <Description>
      A copy of the Identity object made before the refresh.
      This is needed in the second phase of refresh for trigger processing.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" input="true" name="doManualActions">
      <Description>
      When set to 'true' the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can't be done automatically.
      This may be passed in from the refresh task arguments.
    </Description>
    </Variable>
    <Variable input="true" name="enableManualAccountSelection">
      <Description>
      When set to 'true' the system will send out Account Selection Notification emails 
      for users with more than one account on any one application and the system 
      can't determine the provisioning account.
      This may be passed in from the refresh task arguments.
    </Description>
    </Variable>
    <Step icon="Start" name="start" posX="28" posY="10">
      <Transition to="Evaluate Change Events"/>
    </Step>
    <Step condition="changeEvents != null" name="Evaluate Change Events" posX="161" posY="10">
      <Transition to="Do Provisioning Forms"/>
    </Step>
    <Step condition="project != null &amp;&amp; (project.hasQuestions() || (isTrue(enableManualAccountSelection) &amp;&amp; (project.hasUnansweredAccountSelections() ||  project.hasUnansweredProvisioningTargets())))" name="Do Provisioning Forms" posX="346" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="fallbackOwner" value="spadmin"/>
      <Arg name="accountSelectionOwner" value="applicationOwner"/>
      <Arg name="formTemplate" value="Identity Refresh"/>
      <Arg name="disableManualAccountSelection" value="script:!isTrue(enableManualAccountSelection)"/>
      <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c4689ef016a" name="Do Provisioning Forms"/>
      </WorkflowRef>
      <Transition to="Finish Refresh"/>
    </Step>
    <Step action="finishRefresh" name="Finish Refresh" posX="515" posY="10">
      <Arg name="identitizer" value="ref:identitizer"/>
      <Arg name="identity" value="ref:identity"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="refreshOptions" value="ref:refreshOptions"/>
      <Arg name="previousVersion" value="ref:previousVersion"/>
      <Arg name="project" value="ref:project"/>
      <Description>
      Provision what is left in the project then finish the refresh
      by running policy checks, recalculating scores, and other things.
    </Description>
      <Transition to="Save Identity"/>
    </Step>
    <Step condition="isTrue(doManualActions) &amp;&amp; project.getUnmanagedPlan() != null" name="Manual Actions" posX="696" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a14016c" name="Do Manual Actions"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="script: if (identity != null ) { context.saveObject(identity); context.commitTransaction(); }" condition="isTrue(doManualActions) &amp;&amp; project.getUnmanagedPlan() != null" name="Save Identity" posX="587" posY="150">
      <Arg name="identity" value="ref:identity"/>
      <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
      <Transition to="Manual Actions"/>
    </Step>
    <Step name="end" posX="859" posY="10"/>
  </Workflow>
  <Workflow configForm="Identity Update Config Form" created="1603302492821" id="0a111e58754c15ea81754c468a950175" libraries="Identity" name="Identity Update" type="IdentityUpdate">
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable editable="true" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "backgroud"
      option to force the workfow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintanance task to 
      see the resutls of the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="doManualActions">
      <Description>
      When set to 'true' the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can't be done automatically.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="doRefresh">
      <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="requireCreateTemplates">
      <Description>
      When set to 'true' any requests for an account that does not exist
      will be forced into the unmanaged plan unless the target application
      specifies an account creation template.  This may be combined with
      doManualActions to have work items sent out to handle account creation.
    </Description>
    </Variable>
    <Variable editable="true" name="approver">
      <Description>
      Name of Identity to approve role assignments.
      This is not set when launched from the UI, but you may want
      to hard code an initializer for testing.
    </Description>
    </Variable>
    <Variable editable="true" initializer="spadmin" name="fallbackApprover">
      <Description>
      The name of an Identity that will be assigned ownership of any
      manual action work items if the application owner is not set.
    </Description>
    </Variable>
    <Variable input="true" name="identityName" required="true">
      <Description>
      Name of Identity that is being updated.
    </Description>
    </Variable>
    <Variable input="true" name="plan" required="true">
      <Description>
      Master provisioning plan containing the changes to process.
    </Description>
    </Variable>
    <Variable name="sessionOwner">
      <Description>
      This is a system variable that we do not need to declare, but it's 
      good for documentation.  This will be set when the workflow is launched
      to the name of the Identity that is considered to be the owner
      of the interactive UI session.  This is passed to call:buildProvisioningForm
      so that we present forms to the active user first before suspending and
      opening work items for other users.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      Provisioning project containing assigned roles and side effects,
      compiled from the input plan.
    </Description>
    </Variable>
    <Variable name="newRoles"/>
    <Variable name="oldRoles"/>
    <Variable name="linksToAdd"/>
    <Variable name="linksToMove"/>
    <Variable name="linksToRemove"/>
    <Variable name="approvalSet"/>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Step icon="Start" name="start" posX="19" posY="17">
      <Transition to="Inspect Plan"/>
    </Step>
    <Step action="calculateIdentityDifference" name="Inspect Plan" posX="106" posY="17">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="oldRoles" value="oldRoles"/>
      <Arg name="newRoles" value="newRoles"/>
      <Arg name="linksToAdd" value="linksToAdd"/>
      <Arg name="linksToMove" value="linksToMove"/>
      <Arg name="linksToRemove" value="linksToRemove"/>
      <Arg name="approvalSet" value="approvalSet"/>
      <Description>
      Dig some things out of the plan into variables.
      We're setting newRoles and oldRoles temporarily so we can use
      the old approval pages.  Sould be calculating other differences!
    </Description>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" name="Compile Project" posX="204" posY="17" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="UI"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="requireCreateTemplates" value="ref:requireCreateTemplates"/>
      <Description>
      Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.
    </Description>
      <Transition to="Start Approval Process" when="ref:approver"/>
      <Transition to="Start Provisioning Form Process"/>
    </Step>
    <Step action="setLaunchMessage" icon="Message" name="Start Approval Process" posX="358" posY="13">
      <Arg name="message" value="workflow_identity_approval"/>
      <Arg name="arg1" value="ref:identityDisplayName"/>
      <Arg name="arg2" value="ref:approver"/>
      <Description> 
      Add a message to the worflow launch result indicating that an approval is in progress.
      This also serves an example of building localized messages from the 
      catalog.
    </Description>
      <Transition to="Approval"/>
    </Step>
    <Step icon="Approval" name="Approval" posX="462" posY="13">
      <Approval description="Approve modification to $(identityDisplayName)" owner="ref:approver" renderer="identityUpdate.xhtml" send="identityName,identityDisplayName,newRoles,oldRoles,linksToAdd,linksToMove,linksToRemove,approvalSet">
        <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
      </Approval>
      <Transition to="end" when="!ref:approved"/>
      <Transition to="Start Provisioning Form Process"/>
    </Step>
    <Step action="setLaunchMessage" icon="Message" name="Start Provisioning Form Process" posX="270" posY="124">
      <Arg name="message" value="workflow_identity_forms"/>
      <Arg name="arg1" value="ref:identityDisplayName"/>
      <Transition to="Do Provisioning Forms"/>
    </Step>
    <Step name="Do Provisioning Forms" posX="270" posY="219">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="preferredOwner" value="ref:sessionOwner"/>
      <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c4689ef016a" name="Do Provisioning Forms"/>
      </WorkflowRef>
      <Transition to="Start Provisioning Process"/>
    </Step>
    <Step action="setLaunchMessage" icon="Message" name="Start Provisioning Process" posX="270" posY="315">
      <Arg name="message">
        <Script>
          <Source>
          // pick a message with more detail if we're provisioning
          import sailpoint.object.ProvisioningPlan;
          String msg = "workflow_identity_saved";
          boolean otherPlans = false;
          List plans = project.getPlans();
          if (plans != null) {
              for (int i = 0 ; i &lt; plans.size() ; i++) {
                  ProvisioningPlan plan = (ProvisioningPlan)plans.get(i);
                  if (!ProvisioningPlan.APP_IIQ.equals(plan.getTargetIntegration())) {
                     otherPlans = true;
                     break;
                  }
              }
          }

          if (project.getUnmanagedPlan() != null &amp;&amp; isTrue(doManualActions)) {
              if (otherPlans)
                  msg = "workflow_identity_provisioning_manual";
              else
                  msg = "workflow_identity_manual";
          }
          else if (otherPlans) {
              msg = "workflow_identity_provisioning";
          }

          return msg;
        </Source>
        </Script>
      </Arg>
      <Arg name="arg1" value="ref:identityDisplayName"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision" posX="394" posY="315">
      <Arg name="background" value="!ref:foregroundProvisioning"/>
      <Arg name="project" value="ref:project"/>
      <Description>
      Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions, but if we have them
      the provisioner will just skip creating those accounts and do what it can.
    </Description>
      <Transition to="Manual Actions"/>
    </Step>
    <Step condition="isTrue(doManualActions) &amp;&amp; project.getUnmanagedPlan() != null" name="Manual Actions" posX="490" posY="315">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a14016c" name="Do Manual Actions"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="599" posY="315">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Arg name="provision" value="true"/>
      <Arg name="synchronizeAttributes" value="true"/>
      <Arg name="doManualActions" value="ref:doManualActions"/>
      <Description>
      Add arguments as necessary to enable refresh features.  Typically you only want this
      to correlate roles and possibly provision if we notice new assigned roles.
      Note that provisioning will be done in the Identity Refresh workflow so if there
      are any provisioning forms to display we won't feed them directly to the 
      current user, they'll have to return to the inbox.
    </Description>
      <Transition to="end"/>
    </Step>
    <Step name="Form Owner Error" posX="701" posY="9">
      <Script>
        <Source>
        //println("Unable to determine owner for provisioning form, terminating process");
        //println(wfcontext.getWorkflowCase().toXml());
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="599" posY="9"/>
  </Workflow>
  <Workflow created="1603302492849" id="0a111e58754c15ea81754c468ab10176" libraries="Identity" name="Scheduled Assignment" resultExpiration="-1" type="ScheduledAssignment">
    <Variable input="true" name="identity">
      <Description>The database id of the target identity</Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the target identity</Description>
    </Variable>
    <Variable input="true" name="assigner">
      <Description>The name of the identity considered to be the source of the assignment.
This is used for the audit event.  It is not necessary to make the assignment
becuase the original assigner will also be stored in RoleAssignment metadata
in the cube.</Description>
    </Variable>
    <Variable editable="true" initializer="script:System.getProperty(&quot;iiq.forceRefreshAfterScheduledRoleChange&quot;)" name="doRefresh">
      <Description>Set to true to cause a cube refresh after the assignment</Description>
    </Variable>
    <Variable input="true" name="eventType">
      <Description>The type of assignment.  This will be one of the constants defined in RoleEventGenerator.</Description>
    </Variable>
    <Variable input="true" name="role">
      <Description>The database id of the role to assign, if this is a role event</Description>
    </Variable>
    <Variable input="true" name="roleName">
      <Description>The name of the role to assign, if this is a role event</Description>
    </Variable>
    <Variable input="true" name="assignmentId">
      <Description>The unique id of the RoleAssignment, if this is a role event</Description>
    </Variable>
    <Variable input="true" name="application">
      <Description>The database id of an application, if this is an entitlement event</Description>
    </Variable>
    <Variable input="true" name="applicationName">
      <Description>The name of an application, if this is an entitlement event</Description>
    </Variable>
    <Variable input="true" name="instance">
      <Description>The name of an application instance, if this is an entitlement event</Description>
    </Variable>
    <Variable input="true" name="nativeIdentity">
      <Description>The specific id of the target account in the application, if this is an entitlement event</Description>
    </Variable>
    <Variable input="true" name="name">
      <Description>The name of an attribute in the account schema, if this is an entitlement event</Description>
    </Variable>
    <Variable input="true" name="value">
      <Description>The value of the account attribute, if this is an entitlement event</Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="enableManualAccountSelection">
      <Description>When set to &amp;#39;true&amp;#39; the system will send out Account Selection Notification emails 
    for users with more than one account on any one application and the system 
    can&amp;#39;t determine the provisioning account.
    This may be passed in from the refresh task arguments.</Description>
    </Variable>
    <Variable name="project">
      <Description>ProvisioningProject compiled from the Request</Description>
    </Variable>
    <Variable editable="true" initializer="false" input="true" name="doManualActions">
      <Description>When set to &amp;#39;true&amp;#39; the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can&amp;#39;t be done automatically.
      This may be passed in from the refresh task arguments.</Description>
    </Variable>
    <Variable initializer="false" name="identityHasOutstandingForms"/>
    <Description>
Workflow called to handle a scheduled assignment and deassignments,
commonly known as "sunrise" and "sunset".  These are intended to
be used only from Request objects that are scheduled by the provisioning
plan evaluator.
  </Description>
    <Step icon="Start" name="start" posX="28" posY="10">
      <Transition to="Compile Assignment Project"/>
    </Step>
    <Step action="call:compileScheduledAssignmentProject" icon="Task" name="Compile Assignment Project" posX="161" posY="10" resultVariable="project">
      <Arg name="identity" value="ref:identity"/>
      <Arg name="application" value="ref:application"/>
      <Arg name="nativeIdentity" value="ref:nativeIdentity"/>
      <Arg name="name" value="ref:name"/>
      <Arg name="value" value="ref:value"/>
      <Arg name="role" value="ref:role"/>
      <Arg name="assigner" value="ref:assigner"/>
      <Arg name="eventType" value="ref:eventType"/>
      <Arg name="instance" value="ref:instance"/>
      <Arg name="assignmentId" value="ref:assignmentId"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
      <Arg name="enableManualAccountSelection" value="ref:enableManualAccountSelection"/>
      <Transition to="Inspect Project"/>
    </Step>
    <Step name="Inspect Project" posX="336" posY="10">
      <Script>
        <Source>
        // hooks for project customization before execution
      </Source>
      </Script>
      <Transition to="Check For Outstanding Forms" when="!ref:identityHasOutstandingForms"/>
      <Transition to="Do Provisioning Forms"/>
    </Step>
    <Step action="call:outstandingProvisioningFormsForIdentity" name="Check For Outstanding Forms" resultVariable="identityHasOutstandingForms">
      <Arg name="identity" value="ref:identity"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Recompile" when="ref:identityHasOutstandingForms"/>
      <Transition to="Do Provisioning Forms"/>
    </Step>
    <Step action="call:compileScheduledAssignmentProject" icon="Task" name="Recompile" resultVariable="project" wait="script:new Integer(5);">
      <Arg name="identity" value="ref:identity"/>
      <Arg name="application" value="ref:application"/>
      <Arg name="nativeIdentity" value="ref:nativeIdentity"/>
      <Arg name="name" value="ref:name"/>
      <Arg name="value" value="ref:value"/>
      <Arg name="role" value="ref:role"/>
      <Arg name="assigner" value="ref:assigner"/>
      <Arg name="eventType" value="ref:eventType"/>
      <Arg name="instance" value="ref:instance"/>
      <Arg name="assignmentId" value="ref:assignmentId"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
      <Arg name="enableManualAccountSelection" value="ref:enableManualAccountSelection"/>
      <ConditionScript>
        <Source>identityHasOutstandingForms</Source>
      </ConditionScript>
      <Transition to="Inspect Project"/>
    </Step>
    <Step name="Do Provisioning Forms" posX="486" posY="10">
      <Arg name="preferredOwner"/>
      <Arg name="workItemComments"/>
      <Arg name="requiredOwner"/>
      <Arg name="fallbackOwner" value="spadmin"/>
      <Arg name="accountSelectionOwner" value="applicationOwner"/>
      <Arg name="formOwnerError"/>
      <Arg name="identityDisplayName"/>
      <Arg name="formTemplate" value="Identity Refresh"/>
      <Arg name="disableManualAccountSelection" value="script:!isTrue(enableManualAccountSelection)"/>
      <Arg name="calculatedAccountSelectionOwner"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemForm"/>
      <Arg name="workItemPriority"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="accountSelectionForm"/>
      <ConditionScript>
        <Source>project != null &amp;&amp; (project.hasQuestions() || (isTrue(enableManualAccountSelection) &amp;&amp; (project.hasUnansweredAccountSelections() ||  project.hasUnansweredProvisioningTargets())))</Source>
      </ConditionScript>
      <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms.
    </Description>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c4689ef016a" name="Do Provisioning Forms"/>
      </WorkflowRef>
      <Transition to="Process Project Pre-Actions"/>
    </Step>
    <Step action="call:processProject" name="Process Project Pre-Actions">
      <Arg name="identity" value="ref:identity"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Task" name="Provision" posX="633" posY="9">
      <Arg name="disableIdentityRequests" value="true"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="maxRetries"/>
      <Arg name="provisioningRetryThreshold"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityRequestId"/>
      <Arg name="retryProject"/>
      <Arg name="retries"/>
      <Arg name="enableRetryRequest"/>
      <Arg name="foregroundProvisioning" value="true"/>
      <Description>
      Execute the scheduled assignment project.
      We call the standard subprocess that handles retries.
      Note that the disableIdentityRequests option is passed
      to prevent logging a warning since this workflow does
      not maintain IdentityRequest objects.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a26016d" name="Provision with retries"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="script:isTrue(doRefresh)" icon="Task" name="Refresh Identity" posX="786" posY="10">
      <Arg name="identity" value="ref:identity"/>
      <Arg name="doManualActions" value="false"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Arg name="provision" value="true"/>
      <Description>
Add arguments as necessary to enable refresh features.  Provisioning is usually done
with an option to the Activate Assignment step.  Here you might want to check
policies or refresh the scorecard.  Correlating entitlements might pick up new
detected roles if the provisioning was done synchronously.
    </Description>
      <Transition to="Manual Actions"/>
    </Step>
    <Step condition="script:project.getUnmanagedPlan() != null" name="Manual Actions" posX="944" posY="10">
      <Arg name="project" value="ref:project"/>
      <Arg name="doAudit"/>
      <Arg name="workItemPriority"/>
      <Arg name="identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="fallbackApprover"/>
      <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a14016c" name="Do Manual Actions"/>
      </WorkflowRef>
      <Transition to="audit"/>
    </Step>
    <Step action="call:auditScheduledProject" icon="audit" name="audit" posX="1000" posY="10">
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="1086" posY="10"/>
  </Workflow>
  <Workflow created="1603302492862" id="0a111e58754c15ea81754c468abe0177" libraries="Role,Identity" name="Scheduled Role Activation" resultExpiration="1" type="ScheduledRoleActivation">
    <Variable input="true" name="eventType">
      <Description>The type of the role activation event.  This will be one of the constants defined in RoleEventGenerator: roleActivation or roleDeactivation</Description>
    </Variable>
    <Variable input="true" name="role">
      <Description>The database id of the role we're changing.</Description>
    </Variable>
    <Variable input="true" name="roleName">
      <Description>The name of the role we're changing.</Description>
    </Variable>
    <Variable editable="true" initializer="script:System.getProperty(&quot;iiq.forceRefreshAfterScheduledRoleChange&quot;)" name="doRefresh">
      <Description>Set to true to cause a full identity refresh after activation.</Description>
    </Variable>
    <Variable name="activate">
      <Script>
        <Source>
        // we sholld only be here for activation or deactivation events, 
        // but err on the side of activation in case the type is wrong
        import sailpoint.api.RoleEventGenerator;
        return !RoleEventGenerator.EVENT_TYPE_ROLE_DEACTIVATION.equals(eventType);
      </Source>
      </Script>
    </Variable>
    <Variable editable="true" initializer="false" name="noRolePropagation" type="boolean">
      <Description>Set to true to disable role change propagation.</Description>
    </Variable>
    <Description>
Workflow called when a role is ready to be enabled or disabled.
  </Description>
    <Step icon="Start" name="start" posX="30" posY="10">
      <Transition to="Activate Role"/>
    </Step>
    <Step action="call:enableRole" condition="ref:activate" icon="Task" name="Activate Role" posX="140" posY="10">
      <Arg name="role" value="ref:role"/>
      <Transition to="Deactivate Role"/>
    </Step>
    <Step action="call:disableRole" condition="!ref:activate" icon="Task" name="Deactivate Role" posX="260" posY="10">
      <Arg name="role" value="ref:role"/>
      <Transition to="Audit Success"/>
    </Step>
    <Step action="audit" icon="Audit" name="Audit Success" posX="390" posY="10">
      <Arg name="source" value="ref:launcher"/>
      <Arg name="action" value="script:(activate) ? &quot;activate&quot; : &quot;deactivate&quot;"/>
      <Arg name="target" value="ref:roleName"/>
      <Arg name="string1" value="script:((activate) ? &quot;Activated &quot; : &quot;Deactivated &quot;) + roleName"/>
      <Arg name="string2" value="Success"/>
      <Transition to="Refresh Identities"/>
    </Step>
    <Step action="call:refreshIdentities" condition="ref:doRefresh" icon="Task" name="Refresh Identities" posX="525" posY="10">
      <Arg name="identitiesWithRoles">
        <Script>
          <Source>
          // if we're deactivating, only refresh roles that have us
          import sailpoint.api.RoleEventGenerator;
          Object retval = null;
          if (RoleEventGenerator.EVENT_TYPE_ROLE_DEACTIVATION.equals(eventType)) 
             retval = role;
          return retval;
      </Source>
        </Script>
      </Arg>
      <Arg name="correlateEntitlements" value="true"/>
      <Arg name="provision" value="true"/>
      <Arg name="doManualActions" value="false"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="650" posY="10"/>
  </Workflow>
  <Workflow created="1603302492868" id="0a111e58754c15ea81754c468ac40178" libraries="Group" name="Entitlement Update" type="ManagedAttribute">
    <Variable editable="true" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "backgroud"
      option to force the workfow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintanance task to 
      see the resutls of the request.  For group requests this is much less
      of a problem than it is for account provisioning.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="doManualActions">
      <Description>
      When set to 'true' the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can't be done automatically.
    </Description>
    </Variable>
    <Variable editable="true" initializer="spadmin" name="fallbackApprover">
      <Description>
      The name of an Identity that will be assigned ownership of any
      manual action work items if the application owner is not set.
    </Description>
    </Variable>
    <Variable input="true" name="plan" required="true">
      <Description>
      Master provisioning plan containing the changes to process.
    </Description>
    </Variable>
    <Variable initializer="script:System.getProperty(&quot;iiq.forceApprover&quot;)" input="true" name="approver">
      <Description>
      Name of Identity to approve entitlement changes.
      This is not set when launched from the UI, but you may want
      to hard code an initializer for testing.
    </Description>
    </Variable>
    <Variable name="sessionOwner">
      <Description>
      This is a system variable that we do not need to declare, but it's 
      good for documentation.  This will be set when the workflow is launched
      to the name of the Identity that is considered to be the owner
      of the interactive UI session.  This is passed to call:buildProvisioningForm
      so that we present forms to the active user first before suspending and
      opening work items for other users.
    </Description>
    </Variable>
    <Variable name="summaryName">
      <Description>
      Single string representation of ManagedAttribute identity.
      This must be at least a combination of the application name
      and the managed attribute value (group name).
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      Provisioning project containing assigned roles and side effects,
      compiled from the input plan.
    </Description>
    </Variable>
    <Variable name="changes">
      <Description>
      A ChangeSummary object containing a JSF friendly summary of the
      changes being made.  
    </Description>
    </Variable>
    <Step icon="Start" name="start" posX="17" posY="19">
      <Transition to="Examine Plan"/>
    </Step>
    <Step action="getSummaryName" name="Examine Plan" posX="112" posY="19" resultVariable="summaryName">
      <Description>
      Derive a single string we can use as the name of the entitlement
      in approvals and logging.
    </Description>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileGroupProject" name="Compile Project" posX="219" posY="19" resultVariable="project">
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="GroupManagement"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Description>
      Compile the provisioning plan into a provisioning project.
      Unlike the project compilation step for identities, we do not
      expect to be dealing with provisioning policies and forms.
    </Description>
      <Transition to="Start Approval Process" when="ref:approver"/>
      <Transition to="Start Provisioning Process"/>
    </Step>
    <Step action="setLaunchMessage" icon="Message" name="Start Approval Process" posX="285" posY="112">
      <Arg name="message" value="workflow_identity_approval"/>
      <Arg name="arg1" value="ref:summaryName"/>
      <Arg name="arg2" value="ref:approver"/>
      <Description> 
      Add a message to the worflow launch result indicating that an approval is in progress.
      This also serves an example of building localized messages from the catalog.
    </Description>
      <Transition to="Build Approval Summary"/>
    </Step>
    <Step action="buildGroupChangeSummary" name="Build Approval Summary" posX="432" posY="112" resultVariable="changes">
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Approval"/>
    </Step>
    <Step icon="Approval" name="Approval" posX="554" posY="112">
      <Approval owner="ref:approver" renderer="entitlement.xhtml" send="summaryName,changes">
        <Arg name="workItemDescription">
          <Script>
            <Source>
            String action = "modification";
            if (changes.delete)
                action = "deletion";
            else if (changes.create)
                action = "creation";
            return "Approve " + action + " of entitlement " + summaryName;
          </Source>
          </Script>
        </Arg>
      </Approval>
      <Transition to="end" when="!ref:approved"/>
      <Transition to="Start Provisioning Process"/>
    </Step>
    <Step action="setLaunchMessage" icon="Message" name="Start Provisioning Process" posX="612" posY="15">
      <Arg name="message">
        <Script>
          <Source>
          // pick a message with more detail if we're provisioning
          import sailpoint.object.ProvisioningPlan;
          String msg = "workflow_identity_saved";
          boolean otherPlans = false;
          List plans = project.getPlans();
          if (plans != null) {
              for (int i = 0 ; i &lt; plans.size() ; i++) {
                  ProvisioningPlan plan = (ProvisioningPlan)plans.get(i);
                  if (!ProvisioningPlan.APP_IIQ.equals(plan.getTargetIntegration())) {
                     otherPlans = true;
                     break;
                  }
              }
          }

          if (project.getUnmanagedPlan() != null &amp;&amp; isTrue(doManualActions)) {
              if (otherPlans)
                  msg = "workflow_identity_provisioning_manual";
              else
                  msg = "workflow_identity_manual";
          }
          else if (otherPlans) {
              // jsl - if there are errors it looks odd to show
              // a "succesfully requesting provisioning" message
              // followed by the error message, just leave this out,
              // we can say something about manual provisioning but if
              // simply committed the change we dont' need anything more
              // msg = "workflow_identity_provisioning";
          }
          return msg;
        </Source>
        </Script>
      </Arg>
      <Arg name="arg1" value="ref:summaryName"/>
      <Description>
      Leave a launch message that can be displayed in the browser before
      we start provisioning which may be asynchronous.  Note that this
      uses the same message catalog keys as the identity update workflows
      which is okay because they don't mention the type of object being
      processed.  If that changes we'll need our own set of keys.
    </Description>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionGroupProject" icon="Provision" name="Provision" posX="732" posY="15">
      <Arg name="background" value="!ref:foregroundProvisioning"/>
      <Arg name="project" value="ref:project"/>
      <Description>
      Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions.
    </Description>
      <Transition to="Check Provisioning Errors"/>
    </Step>
    <Step name="Check Provisioning Errors" posX="851" posY="15">
      <Description>
      Placeholder for custom logging or other actions.  
      If there were group provisioning errors, provisionGroupProject
      will have left them in the WorkflowCase.messages list.
    </Description>
      <Script>
        <Source>
        import sailpoint.tools.Message;
        //System.out.println("Checking provisioning errors...");
        List errors = wfcontext.getWorkflowCase().getErrors();
        if (errors != null) {
            for (Message error : errors) {
                //System.out.println("*** " + error.toString());
            }
        }
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="977" posY="14"/>
  </Workflow>
  <Workflow created="1603302492884" explicitTransitions="true" id="0a111e58754c15ea81754c468ad40179" libraries="Identity" modified="1615449405705" name="Password Intercept" type="PasswordIntercept">
    <Variable editable="true" initializer="false" name="syncAll">
      <Description>
      Set to true to enable full synchronization over all
      accounts.
    </Description>
    </Variable>
    <Variable editable="true" name="targetApplications">
      <Description>
      Set to a csv or List(String) of Application names that will be synchronized.
    </Description>
    </Variable>
    <Variable input="true" name="identityName" required="true">
      <Description>
      Name of the Identity whose password has changed.
    </Description>
    </Variable>
    <Variable input="true" name="applicationName" required="true">
      <Description>
      Name of the Application where the password change was detected.
    </Description>
    </Variable>
    <Variable input="true" name="nativeIdentity" required="true">
      <Description>
      Name of the account on the Application where the password change was detected.
    </Description>
    </Variable>
    <Variable input="true" name="password" required="true">
      <Description>
      The new password, encrypted.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      A ProvisionignProject compiled from the target list.
    </Description>
    </Variable>
    <Step icon="Start" name="start" posX="28" posY="15">
      <Transition to="Select Targets"/>
    </Step>
    <Step name="Select Targets" posX="127" posY="15">
      <Script>
        <Source>
        // Placeholder for custom application selection.
        // The result must be left on the targetApplications list
        // as either a csv or List(String) of Application names.


        import sailpoint.object.*;
        import java.util.*;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.pwdInterceptLogger");
        log.info("Setting target applications for password intercept");

        System.out.println("Setting target applications for password intercept");


        Custom targetApplicationsCustom = context.getObjectByName(Custom.class,"CF-PWDInterceptor-TargetApps-Custom");
        //getting target applications from custom object
        targetApplications = targetApplicationsCustom.getList("targetApplications");
        System.out.println("targetApplications: "+targetApplications.toString());

        log.info("Source application : " + applicationName);
        log.info("Target applications : " + targetApplications);

        //removing source application from target applications list		
        if (applicationName !=null) {
        if (targetApplications.contains(applicationName)) {        
        targetApplications.remove(applicationName);
        log.info("source application : " + applicationName + " has been removed from targetApplications list" );
        System.out.println("source application : " + applicationName + " has been removed from targetApplications list");
        }
        }

        //Added the below single line of code to remove PeopleSoft which was getting picked up unnecessarily during password intercept and causing it to error out
        //targetApplications.remove("PeopleSoft");

        log.info("target Applications for password intercept: " + targetApplications.toString());
        System.out.println("target Applications for password intercept: " + targetApplications.toString());
        workflow.put("targetApplications",targetApplications);
      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="call:compilePasswordInterceptProject" name="Compile Project" posX="239" posY="15" resultVariable="project">
      <Arg name="password" value="ref:password"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="syncAll" value="ref:syncAll"/>
      <Arg name="sourceApplication" value="ref:applicationName"/>
      <Arg name="targetApplications" value="ref:targetApplications"/>
      <Description>
      Perform the default password synchronization using the
      supplied application list. 
    </Description>
      <Transition to="Empty Project" when="project == null"/>
      <Transition to="Examine Project"/>
    </Step>
    <Step name="Examine Project" posX="305" posY="150">
      <Description>
      This is a placeholder for custom code that may want to alter
      the project before execution.
    </Description>
      <Script>
        <Source>
        //System.out.println("Password intercept project:");
        //System.out.println(project.toXml());
      </Source>
      </Script>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Task" name="Provision" posX="418" posY="150">
      <Arg name="foregroundProvisioning" value="true"/>
      <Arg name="retries"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="enableRetryRequest"/>
      <Arg name="recompileBeforeProvisioning"/>
      <Arg name="disableIdentityRequests" value="true"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="provisioningMaxRetries"/>
      <Arg name="identityRequestId"/>
      <Arg name="retryProject"/>
      <Arg name="splitProvisioning"/>
      <Arg name="provisioningRetryThreshold"/>
      <Description>
      Execute the password synchronization project.
      We call the standard subprocess that handles retries.
      Note that the disableIdentityRequests option is passed
      to prevent logging a warning since this workflow does
      not maintain IdentityRequest objects.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a26016d" name="Provision with retries"/>
      </WorkflowRef>
      <Transition to="Audit"/>
    </Step>
    <Step name="Audit" posX="535" posY="150">
      <Description>
      Placeholder, what kind of auditing should we do?
      We've got low level ProvisioningResults in the project.
    </Description>
      <Transition to="end"/>
    </Step>
    <Step name="Empty Project" posX="418" posY="11">
      <Description>
      Here if there wasn't enough to build a project.  If there
      were missing inputs there should be errors in the log.  We could
      just be here because there were no sync targets.
    </Description>
      <Script>
        <Source>
        //System.out.println("Empty synchronization project");
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="535" posY="11"/>
  </Workflow>
  <Workflow created="1603302492892" explicitTransitions="true" id="0a111e58754c15ea81754c468adb017a" name="Alert - Disable Account" type="Alert">
    <Variable input="true" name="alertDefinition" required="true">
      <Description>The alertDefinition object that matched the alert.</Description>
    </Variable>
    <Variable input="true" name="alertId" required="true">
      <Description>The id of the Alert that triggered the workflow.</Description>
    </Variable>
    <Variable name="plan" output="true">
      <Description>ProvisioningPlan generated for the Alert.</Description>
    </Variable>
    <Variable name="project" output="true">
      <Description>The compiled project from the plan</Description>
    </Variable>
    <Variable initializer="Disable" name="op">
      <Description>Operation to take.</Description>
    </Variable>
    <Description>Disable accounts when alert is triggered.

    If the alert's targetType is Identity, this will set the Identity inactive.

    If the alert's targetType is Link, this will disable the account associated to the link.</Description>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Build Provisioning Plan"/>
    </Step>
    <Step action="buildAlertPlan" icon="Task" name="Build Provisioning Plan" posX="98" posY="10" resultVariable="plan">
      <Arg name="op" value="ref:op"/>
      <Arg name="alertId" value="ref:alertId"/>
      <Description>Build the Provisioning plan to disable the correct account</Description>
      <Transition to="Compile Plan"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Task" name="Compile Plan" posX="312" posY="10" resultVariable="project">
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="provisionProject" icon="Provision" name="Provision" posX="438" posY="10">
      <Arg name="project" value="ref:project"/>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="540" posY="10"/>
  </Workflow>
  <Workflow created="1603302493039" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e58754c15ea81754c468b6f017d" name="Identity Correlation" type="IdentityCorrelation">
    <Variable input="true" name="identityName">
      <Description>The name of the identity we're supposed to update.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these two values:

      IdentityCreateRequest
      IdentityEditRequest
    </Description>
    </Variable>
    <Variable editable="true" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "backgroud"
      option to force the workfow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintanance task to 
      see the resutls of the request.
    </Description>
    </Variable>
    <Variable initializer="user,requester" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options. 

     none or null
       disable notifications

     user 
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
     A string that specifies how we should handle the approvals.  

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.
 
     parallelPoll 
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to 
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="manager, newManager" input="true" name="approvalScheme">
      <Description>
      A String that specifies how approvals should be generated for 
      this workflow there are five built-in modes

      none - disabled approvals

      manager - The user's current manager will get approvals

      newManager - The newly assigned manager will get approvals when 
                   manager transfers occur. Otherwise the user's manager 
                   current manager will be the approver.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      fail -  fail and exit the workflow if any policy violations are found

      continue -  continue if policy violations are found
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description> 
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see 
       pending violations.
    </Description>
    </Variable>
    <Variable name="approvalForm">
      <Description>
       The form that is generated based on the changes that were made.  This
       form will be sent into the workitem and allow editing of the 
       requested values during the approval process. This is generated
       in "Build Approval Form" based on the passed-in plan.
    </Description>
    </Variable>
    <Variable initializer="IdentityCorrelation" name="interface">
      <Description>
      This variable shows up in Audit logs.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="start" posX="2" posY="19">
      <Transition to="Build Approval Set"/>
    </Step>
    <Step action="call:buildApprovalSet" icon="Task" name="Build Approval Set" posX="60" posY="92" resultVariable="approvalSet">
      <Description>
       The rule will go through the plan and build an approvalItem for each AccountRequest, 
       typically there is just one for the IIQ application requests.

       The rule will also annotate the plan with the previousValues so that they 
       can be assimilated onto the Form that is build, which is used during the approval 
       process for edits.
    </Description>
      <Transition to="Audit Start"/>
    </Step>
    <Step action="auditLCMStart" icon="Audit" name="Audit Start" posX="60" posY="185">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Transition to="Build Approval Form"/>
    </Step>
    <Step action="call:buildPlanApprovalForm" icon="Task" name="Build Approval Form" posX="60" posY="287" resultVariable="approvalForm">
      <Arg name="plan" value="ref:plan"/>
      <Arg name="template" value="LCM Identity Approval"/>
      <Transition to="Customize Approval Form"/>
    </Step>
    <Step name="Customize Approval Form" posX="60" posY="381" resultVariable="approvalForm">
      <Description>
       using the form that was generaed, mMrk the password field read only so approvers 
       can't change it.  Also associate a Rule with the name so name changes during 
       approvals can be validate.
    </Description>
      <Script>
        <Source>
        import sailpoint.object.Field;
        import sailpoint.object.Form;
        import sailpoint.object.Rule;

        if ( approvalForm != null ) {
            Field passwordField = approvalForm.getField("IIQ:password");
            if ( passwordField != null ) {
                passwordField.setReadOnly(true);
            }
            Field userId = approvalForm.getField("IIQ:name");
            if ( userId != null ) {
                String ruleName = "LCM Validate Identity Name";
                Rule rule = wfcontext.getSailPointContext().getObject(Rule.class, ruleName);
                if ( rule != null ) {
                    userId.setValidationRule(rule);
                }
            }
            Field manager = approvalForm.getField("IIQ:manager");
            if ( manager != null ) {
                // tell the FormBean to output the value as a name
                // instead of ID which is the default
                manager.addAttribute(Field.ATTR_VALUE_PROPERTY, "name");
            }
        }
        return approvalForm;
      </Source>
      </Script>
      <Transition to="Check Policies"/>
    </Step>
    <Step action="checkPolicyViolations" condition="script: !policyScheme.equals(&quot;none&quot;)" icon="Task" name="Check Policies" posX="180" posY="381" resultVariable="policyViolations">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policies" value="ref:policiesToCheck"/>
      <Transition to="Exit On Policy Violation" when="script:((Util.size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))"/>
      <Transition to="Approval"/>
    </Step>
    <Step condition="script:!approvalScheme.equals(&quot;none&quot;)" icon="Approval" name="Approval" posX="238" posY="288">
      <Approval mode="ref:approvalMode" owner="rule:LCM Build Identity Approvers" renderer="lcmEditableWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations,approvalSet">
        <AfterScript>
          <Source>
          import sailpoint.object.ApprovalSet;
          import sailpoint.object.WorkItem;
          import sailpoint.object.Workflow.WorkflowCase;
          import sailpoint.object.WorkflowCase;
          import sailpoint.object.Form;
          import sailpoint.util.GeneralException;

          if (item == null) {
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          // 
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              Identity id = item.getOwner();
              String ownerName = null;
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in afterscript.");
          }
 
          // djs: this is kind of a hack, do I have alternatives?
          // come back to this
          Form form = (Form)item.get("workItemForm");
          if ( form != null ) {
              WorkflowCase c = wfcontext.getWorkflowCase();
              if ( c != null ) {
                  c.put("approvalForm", form);
              }
          }

          //
          // If they are all rejected mark the Approval Rejected.
          // This allows the Transition to execute once we
          // get a rejection.
          //
          if ( approvalSet.isAllRejected() ) {
              approval.setState(WorkItem.State.Rejected);          
          }

          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
        </Source>
        </AfterScript>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Account Changes for User: $(identityDisplayName)"/>
        <Arg name="workItemForm" value="ref:approvalForm"/>
        <WorkItemConfig escalationStyle="none">
          <NotificationEmailTemplateRef>
            <Reference class="sailpoint.object.EmailTemplate" id="0a111e58754c15ea81754c468b49017c" name="LCM Identity Update Approval"/>
          </NotificationEmailTemplateRef>
        </WorkItemConfig>
      </Approval>
      <Transition to="Start Provisioning Process"/>
    </Step>
    <Step action="call:addMessage" condition="script:!approvalSet.isAllRejected()" icon="Message" name="Start Provisioning Process" posX="238" posY="191">
      <Arg name="message" value="Modifications to $(identityDisplayName) are being provisioned."/>
      <Transition to="Assimilate Form Changes"/>
    </Step>
    <Step action="assimilatePlanApprovalForm" icon="Task" name="Assimilate Form Changes" posX="238" posY="107" resultVariable="plan">
      <Arg name="form" value="ref:approvalForm"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="plan" value="ref:plan"/>
      <Description>
      This step takes the form from the workitem and applys any edits that were
      made back into the plan.
    </Description>
      <Transition to="Process Approval Decisions"/>
    </Step>
    <Step action="call:processPlanApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="238" posY="14" resultVariable="plan">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="plan" value="ref:plan"/>
      <Description>
    </Description>
      <Transition to="Notify" when="script:approvalSet.isAllRejected()"/>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Task" name="Compile Project" posX="391" posY="11" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="LCM"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Description>
      Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.
    </Description>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision" posX="502" posY="11">
      <Arg name="project" value="ref:project"/>
      <Arg name="background" value="!ref:foregroundProvisioning"/>
      <Description>Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions, but if we have them
      the provisioner will just skip creating those accounts and do what it can.</Description>
      <Transition to="Post Provision"/>
    </Step>
    <Step action="script:approvalSet.setAllProvisioned();" icon="Task" name="Post Provision" posX="605" posY="11">
      <Description>
      Mark all of the items in the approvalset provisioned since these
      are all synchronous activities.
    </Description>
      <Transition to="Audit Completion"/>
    </Step>
    <Step action="call:auditLCMCompletion" icon="Audit" name="Audit Completion" posX="715" posY="11">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Email" name="Notify" posX="362" posY="163">
      <Transition to="Notify User"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;user&quot;)" icon="Email" name="Notify User" posX="576" posY="163">
      <Arg name="template" value="LCM User Notification"/>
      <Arg name="to" value="script:getEmail(identityName)"/>
      <Transition to="Notify Requester"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;requester&quot;)" icon="Email" name="Notify Requester" posX="691" posY="163">
      <Arg name="template" value="LCM Requester Notification"/>
      <Arg name="to" value="script:getEmail(launcher)"/>
      <Transition to="Notify Manager"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;manager&quot;)" icon="Email" name="Notify Manager" posX="812" posY="163">
      <Arg name="template" value="LCM Manager Notification"/>
      <Arg name="to" value="script:getManagersEmail(identityName)"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Policy Violation" posX="919" posY="378">
      <Arg name="message" value="Failed due to policy violation(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Catches" name="Check Plan and Update Cart" posX="919" posY="17" resultVariable="plan">
      <Description>
      This step takes looks for name changes during creates and updates
      the stub identity on the plan accordingly.
    </Description>
      <Script>
        <Source>
        import sailpoint.object.ApprovalSet;
        import sailpoint.object.ApprovalItem;
        import sailpoint.object.Identity;
        import sailpoint.object.ProvisioningPlan;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;

        AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);
        if ( iiq != null ) {
            // Look for the name attribute
            boolean nameChanged = false;
            String idName = identityName;
            AttributeRequest name = iiq.getAttributeRequest("name");
            if ( name != null ) {
                String nameStr = Util.otoa(name.getValue());
                if ( nameStr != null ) {
                    // If they don't match this indicates a form
                    // update changes the accountId
                    if ( identityName.compareTo(nameStr) != 0 ) {
                        idName = nameStr; 
                        nameChanged = true;
                    }
                }
            }
            Identity planIdentity = plan.getIdentity();
            if ( ( planIdentity == null ) || ( nameChanged ) ) {
                SailPointContext ctx = wfcontext.getSailPointContext();
                Identity stub = ctx.getObject(Identity.class, idName);
                if ( stub == null ) {
                    stub = new Identity();
                    stub.setName(idName);
                }
                plan.setIdentity(stub);
            }

            //
            // Update the approval item with any changes that 
            // were made during the approval process
            // 
            if ( approvalSet != null ) {
                List approvalItems =  approvalSet.getItems();
                // in the default case there is always just one item for all the changes
                if ( Util.size(approvalItems) == 1 ) { 
                    // Re-flatten the attribute values so they are accurate when auditing changes
                    // and notifying. The values may have been updated in the approvalForm.
                    ApprovalItem item = approvalItems.get(0);
                    List attrRequestFlat = flattenAttributeRequests(iiq.getAttributeRequests());
                    if ( attrRequestFlat != null ) {
                        item.setValue(attrRequestFlat);
                    }
                    if ( nameChanged ) {
                        item.setNativeIdentity(idName);
                    }
                }
            }
        }
        return plan;
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="919" posY="163"/>
  </Workflow>
  <Workflow created="1603302495033" id="0a111e58754c15ea81754c4693390197" name="Generic Step Library" template="true" type="StepLibrary">
    <Step icon="Default" name="Generic Step"/>
    <Step icon="Start" name="Start"/>
    <Step icon="Stop" name="Stop"/>
  </Workflow>
  <Workflow created="1603302495071" explicitTransitions="true" id="0a111e58754c15ea81754c46935f0198" libraries="Identity" modified="1603889312346" name="Provisioning Approval Subprocess" type="Subprocess">
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
        A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.  In effect we are "taking a poll" of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approval items should be generated 
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below 
      in any order, separated by commas. The order in which they are 
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item. 
        For Role approvals this is the Role object owner. 
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.

    </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
       List of identities and/or workgroups names/ids that should be involved in the approval 
       process.    
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.      
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
       The ID of the IdentityRequest for this request.
    </Description>
    </Variable>
    <Variable input="true" name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="managerEmailTemplate">
      <Description>
       Name of the email template to use when manager of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
       Name of the email template to use when notifying the owner of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="securityOfficerEmailTemplate">
      <Description>
       Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="identityEmailTemplate">
      <Description>
       Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="workItemDescription">
      <Description>String "template" that will be used as the workitem description.</Description>
    </Variable>
    <Variable input="true" name="workItemEscalationTemplate">
      <Description>The email template that should be used when sending out reminders.</Description>
    </Variable>
    <Variable input="true" name="workItemHoursBetweenReminders">
      <Description>The number of hours to wait between sending reminders to approvers.</Description>
    </Variable>
    <Variable input="true" name="workItemHoursTillEscalation">
      <Description>The number of hourse to wait until an approval should be escalated.</Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable input="true" name="workItemReminderTemplate">
      <Description>The email template that should be used when sending out reminders.</Description>
    </Variable>
    <Variable input="true" name="workItemEscalationRule">
      <Description>The rule used to assign a new ownder during escalation.</Description>
    </Variable>
    <Variable input="true" name="workItemMaxReminders">
      <Description>The maximum number of reminder emails that will be sent before we begin the escalation process.</Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="clearApprovalDecisions">
      <Description>True to clear all decisions when generating approvals</Description>
    </Variable>
    <Variable initializer="true" input="true" name="dontUpdatePlan">
      <Description>True to skip updating the ProvisioningProject masterPlan when processing approval decisions.</Description>
    </Variable>
    <Variable input="true" name="approvalSet" output="true">
      <Description>
      ApprovalSet representing the things that were requested and come from
      the master provisioning plan. 
    </Description>
    </Variable>
    <Variable input="true" name="project" output="true">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan, the 
      master plan will be adjusted when approval decisions are applied and a new 
      revised provisiobion project will be returned.
    </Description>
    </Variable>
    <Variable input="true" name="plan" output="true">
      <Description>The provisioning plan.</Description>
    </Variable>
    <Description>
    Simple approval subrocess introduced into release 6.2 to make
    adding custom approvals easier.  This approval subprocess
    has a configuration form to make it easier to configure
    from the Business Process Editor.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="20" posY="22">
      <Transition to="Approval"/>
    </Step>
    <Step icon="Approval" name="Approval" posX="158" posY="22">
      <Approval mode="ref:approvalMode" owner="call:buildCommonApprovals" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId">
        <AfterScript>
          <Source>
          import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
        </Source>
        </AfterScript>
        <Arg name="launcher" value="ref:launcher"/>
        <Arg name="workItemDescription" value="ref:workItemDescription"/>
        <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
        <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
        <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
        <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
        <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
        <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="approvalMode" value="ref:approvalMode"/>
        <Arg name="approvalScheme" value="ref:approvalScheme"/>
        <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
        <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
        <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <InterceptorScript>
          <Source>
            
            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
        </Source>
        </InterceptorScript>
      </Approval>
      <Transition to="Process Approval Decisions" when="script:(step.getApproval() != null &amp;&amp; step.getApproval().containsApprovalItems())"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:processApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="420" resultVariable="project">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="disableAudit" value="true"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="recompilePlan" value="true"/>
      <Arg name="dontUpdatePlan" value="ref:dontUpdatePlan"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="420" posY="225"/>
  </Workflow>
  <Workflow created="1603302495101" id="0a111e58754c15ea81754c46937d0199" name="IdentityProvisioningStepLibrary" template="true" type="StepLibrary">
    <Step configForm="Provisioning Approval Step Form" icon="Task" name="Account Approval">
      <Arg name="approvalMode"/>
      <Arg name="approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature"/>
      <Arg name="identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate"/>
      <Arg name="managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate"/>
      <Arg name="ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemComments"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Description>
        Step library that can be used for provisioning request approvals.
        The process assumes many of the Provisioning Workflow structures exist
        and has things like provisioning plans and approvalSets are required.           
      </Description>
      <Return name="project"/>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c46935f0198" name="Provisioning Approval Subprocess"/>
      </WorkflowRef>
    </Step>
    <Step action="call:sendMultipleNotifications" configForm="Provisioning Notification Step Form" icon="Email" name="Notify">
      <Arg name="notificationScheme"/>
      <Arg name="userEmail" value="script:getUserEmail(identityName, plan)"/>
      <Arg name="userEmailTemplate"/>
      <Arg name="requesterEmail" value="script:getEmail(launcher)"/>
      <Arg name="requesterEmailTemplate"/>
      <Arg name="managerEmail" value="script:getManagersEmail(identityName, plan)"/>
      <Arg name="managerEmailTemplate"/>
      <Arg name="securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate"/>
      <Arg name="otherUsersToNotify"/>
      <Arg name="otherUsersToNotifyEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="source" value="ref:source"/>
      <Description>
      	  Notify the various actors specified on notification scheme.
        </Description>
    </Step>
  </Workflow>
  <Workflow created="1606498552406" explicitTransitions="true" id="0a111e5875e014d081760ac68a56276e" libraries="Identity" name="SP_SPNT_SNOW_INT_AutoApproveServiceNowRequest">
    <Variable input="true" name="snApprover"/>
    <Variable input="true" name="snApprovalStartDate"/>
    <Variable input="true" name="snApprovalEndDate"/>
    <Variable input="true" name="snApprovalComments"/>
    <Variable input="true" name="identityRequestId"/>
    <Variable input="true" name="plan"/>
    <Variable input="true" name="caseName"/>
    <Variable input="true" name="reqId"/>
    <Variable name="workItemName"/>
    <Variable name="workItemOwner"/>
    <Variable name="approvalSet"/>
    <Variable name="identityName"/>
    <Variable name="identityDisplayName"/>
    <Variable name="snApprovalStartDt"/>
    <Variable name="snApprovalEndDt"/>
    <Description>SP Auto Approve ServiceNow Access Request.</Description>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Default" name="Initialize" posX="98" posY="10" resultVariable="approvalSet">
      <Description>Set WorkItem name and Owner</Description>
      <Script>
        <Source>
		import sailpoint.object.Identity;
        import sailpoint.object.ApprovalItem;
		import sailpoint.object.ApprovalSet;
        import sailpoint.object.ProvisioningPlan;
		import sailpoint.object.ProvisioningPlan.AbstractRequest;
		import sailpoint.object.ProvisioningPlan.AccountRequest;
		import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
		import sailpoint.object.ProvisioningPlan.AttributeRequest;
        
        import java.text.SimpleDateFormat;
        import java.util.TimeZone;
        
        import sailpoint.workflow.IdentityLibrary;
        
        Identity identity = plan.getIdentity();
                
        ApprovalSet globalSet = new ApprovalSet();
        
        if (plan != null)
        {
        	List requests = plan.getAccountRequests();
        	if (Util.size(requests) > 0) {
        		for (ProvisioningPlan.AccountRequest request : requests) {
        			if (request != null) {
        				IdentityLibrary.addApprovalItems(identity, request, globalSet, wfcontext.getSailPointContext());
        			}
        		}
        	}
        }
        
        Date snApprovalStartDt = null;
        Date snApprovalEndDt = null;
        
       	SimpleDateFormat sf  = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				sf.setTimeZone(TimeZone.getTimeZone("UTC"));
        
        if(null != snApprovalStartDate) {        
        	try {
        		snApprovalStartDt = sf.parse(snApprovalStartDate);
        	} catch(java.text.ParseException e) {
        		//do nothing
        	}
        }
        
        if(null != snApprovalEndDate) {        
        	try {
        		snApprovalEndDt = sf.parse(snApprovalEndDate);
        	} catch(java.text.ParseException e) {
        		//do nothing
        	}
        }        
        
        wfcontext.setVariable("identityName", identity.getName());
        wfcontext.setVariable("identityDisplayName", identity.getDisplayName());
        wfcontext.setVariable("workItemOwner", "spadmin");
        wfcontext.setVariable("workItemName", "ServiceNow Approval for access request: " + identityRequestId);
        wfcontext.setVariable("snApprovalStartDt", snApprovalStartDt);
        wfcontext.setVariable("snApprovalEndDt", snApprovalEndDt);
        wfcontext.setVariable("snApprovalComments", reqId + ": " + snApprovalComments);
        
        return globalSet;

      </Source>
      </Script>
      <Transition to="Auto Approve SN Request"/>
    </Step>
    <Step icon="Approval" name="Auto Approve SN Request" posX="280" posY="10">
      <Approval description="ref:workItemName" name="ref:workItemName" owner="ref:workItemOwner" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,identityRequestId,snApprover,snApprovalEndDate,snApprovalStartDate,snApprovalComments">
        <Arg name="workItemDescription" value="ref:workItemName"/>
        <Arg name="workItemRequester" value="spadmin"/>
        <Arg name="workItemOwner" value="ref:workItemOwner"/>
        <Arg name="workItemName" value="ref:workItemName"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      </Approval>
      <Transition to="Update Identity Request Worflow Summary" when="approved"/>
    </Step>
    <Step name="Update Identity Request Worflow Summary">
      <Script>
        <Source>
        import sailpoint.object.IdentityRequest.ExecutionStatus;
        import sailpoint.object.IdentityRequest;
        
        if(null != caseName) {
        
        	sailpoint.object.TaskResult taskResultSNApproval= context.getObjectByName(sailpoint.object.TaskResult.class, caseName);
						
					if(!taskResultSNApproval.isComplete()) {
            
						sailpoint.object.WorkflowSummary wfSummary = (sailpoint.object.WorkflowSummary) taskResultSNApproval.getAttribute("workflowSummary");

						if(null != wfSummary) {
        			List interacations = wfSummary.getInteractions();
        			sailpoint.object.WorkflowSummary.ApprovalSummary approvalSummary = interacations.get(0);
        			approvalSummary.setOwner(snApprover);
        			approvalSummary.setCompleter(snApprover);
        			approvalSummary.setState(sailpoint.object.WorkItem.State.Finished);
        
        			if( null != snApprovalStartDt)
        				approvalSummary.setStartDate(snApprovalStartDt);
        
        			if( null != snApprovalEndDt)
        				approvalSummary.setEndDate(snApprovalEndDt);
        			else
        				approvalSummary.setEndDate(new Date());
        
        			approvalSummary.getApprovalSet().getItems().get(0).setState(sailpoint.object.WorkItem.State.Finished);
        
        			if( null != snApprovalStartDt)
        				approvalSummary.getApprovalSet().getItems().get(0).setStartDate(snApprovalStartDt); 
        
        			if( null != snApprovalEndDt)
        				approvalSummary.getApprovalSet().getItems().get(0).setEndDate(snApprovalEndDt);
        			else
        				approvalSummary.getApprovalSet().getItems().get(0).setEndDate(new Date());
        
        			if(snApprovalComments != null &amp;&amp; snApprovalComments.length() > 0) {
        				List comments = new ArrayList();
        				comments.add(new sailpoint.object.Comment(snApprovalComments, "spadmin"));
        				approvalSummary.getApprovalSet().getItems().get(0).setComments(comments);
        			}
        
        			if (identityRequestId != null) {
        				IdentityRequest ir = context.getObjectByName(sailpoint.object.IdentityRequest.class, identityRequestId);
        				String mainTaskResultId = ir.getTaskResultId();
        				if(null != mainTaskResultId) {
        					sailpoint.object.TaskResult taskResultMain = sailpoint.api.ObjectUtil.lockObject(context, sailpoint.object.TaskResult.class, mainTaskResultId, context.getObjectById(sailpoint.object.TaskResult.class, mainTaskResultId).getName(), sailpoint.api.PersistenceManager.LOCK_TYPE_TRANSACTION);
        					sailpoint.object.WorkflowSummary wfSummaryMain = (sailpoint.object.WorkflowSummary) taskResultMain.getAttribute("workflowSummary");
        					if(null != wfSummaryMain) {
        						List interactionsMain = wfSummaryMain.getInteractions();
        						if(interactionsMain != null &amp;&amp; !interactionsMain.isEmpty()) {
        							
        							interactionsMain.addAll(interacations);
        							wfSummaryMain.setInteractions(interactionsMain);
        						} else {
        							wfSummaryMain.setInteractions(interacations);
        						}
        					} else {
        						 wfSummaryMain = new sailpoint.object.WorkflowSummary();
        						 wfSummaryMain.setInteractions(interacations);
        					}
        					taskResultMain.setAttribute("workflowSummary", wfSummaryMain);
                  context.saveObject(taskResultMain);
          				context.commitTransaction();
          				context.unlockObject(taskResultMain);                					
        
        					String executionStatus = ir.getExecutionStatus().toString();
        
        					if(taskResultMain.isComplete() &amp;&amp; !"Executing".equalsIgnoreCase(executionStatus)) {
        
        						ir.setAttribute("approvalSummaries", interacations);
        						context.saveObject(ir);
          					context.commitTransaction();			        
        					}
        				}
        			}
						}
					}
       }
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="694" posY="3"/>
  </Workflow>
  <Workflow created="1612980825791" explicitTransitions="true" id="0a111e587774115781778d262ebf33ed" libraries="Identity" modified="1613130942367" name="CF-AttrobuteChange-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable name="plan" type="sailpoint.object.ProvisioningPlan"/>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent. It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Check dn"/>
    </Step>
    <Step name="Check dn" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Description>Checking the dn.</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
       import sailpoint.object.*;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.Filter;
        
        
      Identity identity =context.getObjectByName(Identity.class, identityName);
	  String userModifiedDN="";

  System.out.println("Inside AD DN Creation Rule");

  System.out.println("Inside AD DN Creation Rule:"+identity);
  public boolean dnValidation(String dn) {
    if (dn != null) {
      QueryOptions qo = new QueryOptions();
      qo.addFilter(Filter.eq("nativeIdentity", dn));
      qo.addFilter(Filter.eq("application.name", "Active Directory"));

      if (context.countObjects(Link.class, qo) > 0) {
        System.out.println("Inside Rule: CF-DN-Rule, inside method: dnValidation, inside if block, DN already exists.");
        return false;
      }else{
        System.out.println("Inside Rule: CF-DN-Rule, inside method: dnValidation, inside if block, DN available.");
        return true;
      }
    }
  } 
 String firstname = "";
  if(identity != null){
if(identity.getAttribute("prefFirstName") != null){
firstname = identity.getAttribute("prefFirstName");
}
else{
 firstname =  identity.getFirstname();
}
   
    String lastname =  identity.getLastname();
    System.out.println("In DN Rule firstname is:::"+firstname);
    String employeeType  = identity.getAttribute(ATR_EMPLOYEETYPE);
    String userDN ="";
    int count=1;
    char ch='A';
    //System.out.println("In DN Rule, user type: OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com:"+ASSOCIATEOU);
    System.out.println("In DN Rule, user type: OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com:");
    //System.out.println("In DN Rule, user type: OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com:"+ASSOCIATEOU);
    System.out.println("In DN Rule, user type: OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com:");
    if(null != employeeType @and employeeType.equalsIgnoreCase(STR_EMPLOYEE)){
      System.out.println("In DN Rule, user type: Employee, setting DN:::"+userDN);

     // userDN = "cn="+lastname+"\\, "+firstname+","+"OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
      userDN = "cn="+lastname+"\\, "+firstname+","+"OU=AzureUsers,OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";

    }else{
      userDN ="cn="+lastname+"\\, "+firstname+","+"OU=AzureUsers,OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
   //  userDN ="cn="+lastname+"\\, "+firstname+","+"OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
    }
    System.out.println("Inside  DN Rule, user  Dn******"+userDN);

    if(dnValidation(userDN)){
      System.out.println("................................................................."+dnValidation(userDN));
      userModifiedDN=userDN;
    }else{
      if(null != employeeType @and employeeType.equalsIgnoreCase(STR_EMPLOYEE)){
        System.out.println("In DN Rule, user type: Employee, setting DN:::"+userDN);
        if(identity.getAttribute("middleName")!=null){
          userDN = "cn="+lastname+" "+identity.getAttribute("middleName").toString()+" UAT\\, "+firstname+","+"OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";

          if(dnValidation(userDN)){
            userModifiedDN=userDN;
          }else{
            userDN = "cn="+lastname+" "+"X"+" UAT\\, "+firstname+","+"OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
            if(dnValidation(userDN)){
              userModifiedDN=userDN;
            }else{
              while(count @lt 26){
                userDN = "cn="+lastname+" "+Character.toString(ch)+" UAT\\, "+firstname+","+"OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
                if(dnValidation(userDN)){
                  userModifiedDN=userDN;
                }else{

                  ch=(char)(ch + count);
                  count++;
                }

              }
            }
            System.out.println("In DN Rule, user type: Employee, setting DN:::"+userDN);
          }
        }
        else{
          while(count @lt 26){
            userDN = "cn="+lastname+" "+Character.toString(ch)+" UAT\\, "+firstname+","+"OU=Associates,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";

            if(dnValidation(userDN)){
              userModifiedDN=userDN;
            }else{
              ch=(char)(ch + count);
              count++;
            }

          }
        }

      }else{
        if(identity.getAttribute("middleName")!=null){
          userDN = "cn="+lastname+" "+identity.getAttribute("middleName").toString()+" UAT\\, "+firstname+","+"OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
          if(dnValidation(userDN)){
            userModifiedDN=userDN;
          }else{
            userDN = "cn="+lastname+" "+"X"+" UAT\\, "+firstname+","+"OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";
            if(dnValidation(userDN)){
              userModifiedDN=userDN;
            }else{
              while(count @lt 26){
                userDN = "cn="+lastname+" "+Character.toString(ch)+" UAT\\, "+firstname+","+"OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";

                if(dnValidation(userDN)){
                  userModifiedDN=userDN;
                }else{
                  ch=(char)(ch + count);
                  count++;
                }

              }
            }
            System.out.println("In DN Rule, user type: Employee, setting DN:::"+userDN);
          }
        }
        else{
          while(count @lt 26){
            userDN = "cn="+lastname+" "+Character.toString(ch)+" UAT\\, "+firstname+","+"OU=Contractors,OU=Users,OU=Corporate,DC=carefirsttest,DC=com";

            if(dnValidation(userDN)){
              userModifiedDN=userDN;
            }else{
              ch=(char)(ch + count);
              count++;
            }

          }
        }


      }
    }
  }
        
   String[] words=userModifiedDN.split(",");//splits the string based on string
int first = userModifiedDN.indexOf(",");
 int second = userModifiedDN.indexOf(",", first + 1);
//using java foreach loop to print elements of string array
String actualdn="";
for(int i=2;i @lt words.length;i++){
actualdn=actualdn+words[i];
}
String dnValue="";
String dnFinalValue="";
if(actualdn.contains("OU=")){

dnValue=actualdn.replace("OU=",",OU=");
}else{
dnValue=actualdn;
}
if(dnValue.contains("DC=")){

dnFinalValue=dnValue.replace("DC=",",DC=");
}else{
dnFinalValue=dnValue;
}

System.out.println(dnFinalValue.substring(1));


   
        System.out.println("..........."+userModifiedDN+userModifiedDN.substring(0, second));
        
if(userModifiedDN !=null){
        System.out.println("userModifiedDN........"+dnFinalValue);
        
        System.out.println("userModifiedDN........"+dnFinalValue.substring(1));

plan=buildAttributePlan(identity,dnFinalValue.substring(1),userModifiedDN.substring(0, second));
        
         System.out.println("plan.................."+plan);
        return plan;
        }

      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Provisioning Status"/>
    </Step>
    <Step name="Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Arg name="project" value="ref:project"/>
      <Script>
        <Source>
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow.Check Provisioning Status");

        List errors=new ArrayList();
        try{
        errors=getErrors(context,project);

        if(errors!=null @and errors.size()>0){
        Map errorsMap = new HashMap();

        errorsMap.put(identityName,Util.listToCsv(errors));
        workflow.put("failedMap",errorsMap);
        log.info("failed map is " +failedMap);
        return false;
        }
        return true;
        }
        catch(Exception ex){
        return ex;
        }


      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;
        Attributes attributes = new Attributes();

        import org.apache.log4j.Logger;


        Logger log = Logger.getLogger("com.carefirst.MoverWorkflowTest");
        log.info("Inside Mover  identityName in SendProvisioningSuccessEmail  "+identityName);
        Identity identity = getIdentityObj(identityName);

        if(identity != null){

        String userType = identity.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null){
        if(userType.equalsIgnoreCase(STR_EMPLOYEE)){
        attributes.put(STR_OLD_USER_TYPE,STR_CONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);
        }else if(userType.equalsIgnoreCase(STR_CONTRACTOR)){
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        attributes.put(STR_OLD_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_CONTRACTOR);
        }else if(userType.equalsIgnoreCase(STR_FEPOCEMPLOYEE)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCCONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCEMPLOYEE);
        attributes.put(STR_ATR_ASSOCIATE,STR_FEPOCASSOCIATEBIZROLE);
        }
        else if(userType.equalsIgnoreCase(STR_FEPOCCONTRACTOR)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCEMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCCONTRACTOR);
        attributes.put(STR_ATR_CONTRACTOR,STR_FEPOCCONTRACTORBIZROLE);
        }
        }
        sendEmailNotification(identityName,STR_PROVISIONING_SUCCESS_EMAIL_TEMPLATE_MOVER,"");
        createAuditEvent(STR_ADUIT_MOVER_SUCCESS_NOTIFICATION,null,null,STR_ADUIT_MOVER_SUCCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        }
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;

        Attributes attributes = new Attributes();
        Identity identity =getIdentityObj(identityName);

        if(identity != null){
        String userType = identity.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null){
        if(userType.equalsIgnoreCase(STR_EMPLOYEE)){
        attributes.put(STR_OLD_USER_TYPE,STR_CONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);
        }else if(userType.equalsIgnoreCase(STR_CONTRACTOR)){
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        attributes.put(STR_OLD_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_CONTRACTOR);
        }else if(userType.equalsIgnoreCase(STR_FEPOCEMPLOYEE)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCEMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCCONTRACTOR);
        }
        else if(userType.equalsIgnoreCase(STR_FEPOCCONTRACTOR)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCCONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCEMPLOYEE);
        }
        }
        sendEmailNotification(identityName,failedMap,STR_PROVISIONING_FAILURE_EMAIL_TEMPLATE);
        createAuditEvent(STR_ADUIT_MOVER_FAILURE_NOTIFICATION,null,null,STR_ADUIT_MOVER_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        }
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1614259937001" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5877c419108177d963dee93ec9" libraries="Identity,BatchRequest" modified="1615281539028" name="CF-DisconnectedAPP-Workflow" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="requester">
      <Description>
      The person who has requested the update.
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="identityName">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="identityNameinform">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="launcher">
      <Description>
      Shows the requester.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="requester">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable initializer="true" name="transient">
      <Description>
      Set to false to cause workflow-related objects, such as approval
        work items, to be saved in the database even if they are only
        viewed by the person registering.
	
            
        			Set to true to cause workflow-related objects, such as approval
        work items, not saved in the database even if they are only
        viewed by the person registering.
      </Description>
    </Variable>
    <Description>
    Initialize the data in the model.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
          System.out.println("identityModelooooooooooooooooooooooo..................................."+identityModel);
        return identityModel;

      </Source>
      </Script>
      <Transition to="App Display Form"/>
    </Step>
    <Step icon="Approval" name="App Display Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-RequestDisconnectedApp-Form"/>
        <Arg name="workItemForm" value="CF-RequestDisconnectedApp-Form"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="Confirmation Form" when="lastApprovalState.equalsIgnoreCase(&quot;Finished&quot;);"/>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Approval" name="Confirmation Form" posX="269" posY="10">
      <Approval mode="serial" owner="ref:launcher" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-ConfirmationRequestDisconnectedApp-Form"/>
        <Arg name="workItemForm" value="CF-ConfirmationRequestDisconnectedApp-Form"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
      </Approval>
      <Transition to="Set identity name" when="lastApprovalState.equalsIgnoreCase(&quot;Finished&quot;);"/>
      <Transition to="Stop"/>
    </Step>
    <Step name="Set identity name" posX="507" posY="6" resultVariable="identityName">
      <Arg name="identityModel" value="ref:identityModel"/>
      <Description>
      Set the identityName workflow variable based on the form input.
    </Description>
      <Script>
        <Source>
        return identityModel.get("displayname");
      </Source>
      </Script>
      <Transition to="provisionPlan"/>
    </Step>
    <Step name="provisionPlan" posX="507" posY="6" resultVariable="plan">
      <Arg name="identityModel" value="ref:identityModel"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Description>
      Set the identityName workflow variable based on the form input.
    </Description>
      <Script>
        <Source>
         import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        
        
        import sailpoint.object.*;
        
        plan = new ProvisioningPlan();
        
        System.out.println("identityName..................."+identityName+plan);
     Identity identity=context.getObjectByName(Identity.class,identityName);
         System.out.println("identity..................."+identity+identity.getName()+identityModel.get("applications"));

      AccountRequest acctReqIIQ = new AccountRequest();
      acctReqIIQ.setOperation(AccountRequest.Operation.Create);
      acctReqIIQ.setApplication(identityModel.get("applications").toString());
      //acctReqIIQ.setNativeIdentity(identity.getName());
        acctReqIIQ.setNativeIdentity(identity.getAttribute("userid"));
        AttributeRequest attReq = new AttributeRequest();
        attReq.setName("Entitlement");
        attReq.setValue(identityModel.get("comments").toString());
        attReq.setOperation(ProvisioningPlan.Operation.Add);
        acctReqIIQ.add(attReq);
        
      
       //acctReqIIQ.setOperation(ProvisioningPlan.AccountRequest.Operation.Create);

     System.out.println("plan,,,,,,,,,,,,,, "+plan);
      plan.add(acctReqIIQ);
      plan.setIdentity(identity);
         
    //}
    System.out.println("Joiner:: Plan "+plan.toXml());
    return plan; 
      </Source>
      </Script>
      <Transition to="lcmworkflow"/>
    </Step>
    <Step name="lcmworkflow" posX="231" posY="18">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityModel" value="ref:identityModel"/>
      <Arg name="workItemType" value="Form"/>
      <Arg name="workItemDescription" value="CF-RequestDisconnectedApp-Form"/>
      <Arg name="plan" value="ref:plan"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c77a51bf38177f1874baf5bf2" name="CF-MulitpleRequest-LCMProvisioning"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end"/>
  </Workflow>
  <Workflow created="1614930708046" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5877c419108178015f064e298e" libraries="Identity,BatchRequest" modified="1616963732065" name="CF-Workflow-DisconnectedApplication-NativeIdentity" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="requester">
      <Description>
      The person who has requested the update.
    </Description>
    </Variable>
    <Variable initializer="true" name="transient">
      <Description>
      transient
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="identityName" type="input">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="launcher">
      <Description>
      Shows the requester.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="requester">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Description>
    Initialize the data in the model.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        return identityModel;

      </Source>
      </Script>
      <Transition to="App Display Form"/>
    </Step>
    <Step icon="Approval" name="App Display Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-Form-UserDisconnectedAppDetails"/>
        <Arg name="workItemForm" value="CF-Form-UserDisconnectedAppDetails"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="AddUserDetailsToDatabase"/>
    </Step>
    <Step name="AddUserDetailsToDatabase">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import java.text.DateFormat; 
        import java.text.SimpleDateFormat;
        import java.util.Date; 
        import org.apache.log4j.Logger;
		  import java.util.List;
  import java.util.HashMap;
  import sailpoint.tools.Util;
  import sailpoint.object.Application;
  import sailpoint.object.Bundle;
  import sailpoint.object.Custom;
  import sailpoint.object.Classification;
  import sailpoint.object.ObjectClassification;
  import sailpoint.object.Identity;
  import sailpoint.object.IdentitySelector;
  import sailpoint.object.IdentitySelector.MatchExpression;
  import sailpoint.object.IdentitySelector.MatchTerm;
  import sailpoint.object.IdentitySelector.MatchTerm.Type;
  import sailpoint.object.Link;
  import sailpoint.object.Profile;
  import sailpoint.object.Filter;
  import sailpoint.object.Filter.LeafFilter;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.Schema;
  import sailpoint.object.ManagedAttribute;
  import sailpoint.tools.RFC4180LineIterator;
  import sailpoint.tools.RFC4180LineParser;
  import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.*;
 
 String username = "identityiqdev";
    String password = "Identityiq123$";
    String url = "jdbc:sqlserver://sv-spidsql-d1.carefirst.com";
    Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
    Connection connection = DriverManager.getConnection(url, username, password);
  System.out.println("connection............................"+connection);
   PreparedStatement statement = null;
   //statement = connection.prepareStatement(sqlQuery);

	String identityName = identityModel.get("identityName");
	String userid = identityModel.get("userid");
	String applicationName = identityModel.get("applicationName");
	String nativeIdentity = identityModel.get("nativeIdentity");
	String comments = identityModel.get("comments");

    String sqlQuery = "INSERT INTO [identityiqdev].[discApp_details](identityName,userid,applicationName,nativeIdentity,comments) values(?,?,?,?,?)";
    statement = connection.prepareStatement(sqlQuery);
    if(identityName!=null){
      statement.setString(1,identityName);
    }else {
      statement.setString(1, "");
    }
    if(userid!=null){
      statement.setString(2,userid);
    }else {
      statement.setString(2, "");
    }
    if(applicationName!=null){
      statement.setString(3,applicationName);
    }else {
      statement.setString(3, "");
    }
    if(nativeIdentity!=null){
      statement.setString(4,nativeIdentity);

    } else {
      statement.setString(4, "");

    }
    if(comments!=null){
      statement.setString(5,comments);
    }else {
      statement.setString(5, "");
    }
    
    statement.executeUpdate();

    statement.close();
  
 
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end"/>
  </Workflow>
  <Workflow created="1614930792423" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5877c41910817801604fe72992" libraries="Identity,BatchRequest" modified="1616963624520" name="CF-Workflow-View-DisconnectedApplication-NativeIdentity" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="requester">
      <Description>
      The person who has requested the update.
    </Description>
    </Variable>
    <Variable initializer="true" name="transient">
      <Description>
      transient
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="identityName" type="input">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="launcher">
      <Description>
      Shows the requester.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="requester">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Description>
    Initialize the data in the model.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        return identityModel;

      </Source>
      </Script>
      <Transition to="App Display Form"/>
    </Step>
    <Step icon="Approval" name="App Display Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-Form-View-UserDisconnectedAppDetails"/>
        <Arg name="workItemForm" value="CF-Form-View-UserDisconnectedAppDetails"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="FetchUserDetailsToDatabase"/>
    </Step>
    <Step name="FetchUserDetailsToDatabase" resultVariable="nativeIdentity">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import java.text.DateFormat; 
        import java.text.SimpleDateFormat;
        import java.util.Date; 
        import org.apache.log4j.Logger;
		  import java.util.List;
  import java.util.HashMap;
  import sailpoint.tools.Util;
  import sailpoint.object.Application;
  import sailpoint.object.Bundle;
  import sailpoint.object.Custom;
  import sailpoint.object.Classification;
  import sailpoint.object.ObjectClassification;
  import sailpoint.object.Identity;
  import sailpoint.object.IdentitySelector;
  import sailpoint.object.IdentitySelector.MatchExpression;
  import sailpoint.object.IdentitySelector.MatchTerm;
  import sailpoint.object.IdentitySelector.MatchTerm.Type;
  import sailpoint.object.Link;
  import sailpoint.object.Profile;
  import sailpoint.object.Filter;
  import sailpoint.object.Filter.LeafFilter;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.Schema;
  import sailpoint.object.ManagedAttribute;
  import sailpoint.tools.RFC4180LineIterator;
  import sailpoint.tools.RFC4180LineParser;
  import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.*;
 
 String username = "identityiqdev";
    String password = "Identityiq123$";
    String url = "jdbc:sqlserver://sv-spidsql-d1.carefirst.com";
    Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
    Connection connection = DriverManager.getConnection(url, username, password);
  System.out.println("connection............................"+connection);
   
	String identityName = identityModel.get("identityName");
	String userid = identityModel.get("userid");
	String applicationName = identityModel.get("applicationName");
	Statement stmt = connection.createStatement();
	String sqlQuery = "select nativeIdentity from discApp_details where identityName='"+identityName+"' and applicationName='"+applicationName+"'";
	ResultSet rs = stmt.executeQuery(sqlQuery);
	String nativeIdentity = "";
    
	while ( rs.next() ) {
                nativeIdentity = rs.getString("nativeIdentity")+","+nativeIdentity;
                System.out.println("Native Identity: "+nativeIdentity);
            }
    connection.close();
        nativeIdentity = nativeIdentity.substring(0, nativeIdentity.length() - 1);
 	return nativeIdentity;
      </Source>
      </Script>
      <Transition to="View NativeID Form"/>
    </Step>
    <Step icon="Approval" name="View NativeID Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel,nativeIdentity">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-Form-View-NativeID-UserDisconnectedAppDetails"/>
        <Arg name="workItemForm" value="CF-Form-View-NativeID-UserDisconnectedAppDetails"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end"/>
  </Workflow>
  <Workflow created="1614930863309" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5877c419108178016164cd2996" libraries="Identity,BatchRequest" modified="1616963676377" name="CF-Workflow-Delete-DisconnectedApplication-NativeIdentity" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="requester">
      <Description>
      The person who has requested the update.
    </Description>
    </Variable>
    <Variable initializer="true" name="transient">
      <Description>
      transient
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="identityName" type="input">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="launcher">
      <Description>
      Shows the requester.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="requester">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Description>
    Initialize the data in the model.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        return identityModel;

      </Source>
      </Script>
      <Transition to="App Display Form"/>
    </Step>
    <Step icon="Approval" name="App Display Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-Form-Delete-UserDisconnectedAppDetails"/>
        <Arg name="workItemForm" value="CF-Form-Delete-UserDisconnectedAppDetails"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="FetchUserDetailsToDatabase"/>
    </Step>
    <Step name="FetchUserDetailsToDatabase" resultVariable="nativeIdentity">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import java.text.DateFormat; 
        import java.text.SimpleDateFormat;
        import java.util.Date; 
        import org.apache.log4j.Logger;
		  import java.util.List;
  import java.util.HashMap;
  import sailpoint.tools.Util;
  import sailpoint.object.Application;
  import sailpoint.object.Bundle;
  import sailpoint.object.Custom;
  import sailpoint.object.Classification;
  import sailpoint.object.ObjectClassification;
  import sailpoint.object.Identity;
  import sailpoint.object.IdentitySelector;
  import sailpoint.object.IdentitySelector.MatchExpression;
  import sailpoint.object.IdentitySelector.MatchTerm;
  import sailpoint.object.IdentitySelector.MatchTerm.Type;
  import sailpoint.object.Link;
  import sailpoint.object.Profile;
  import sailpoint.object.Filter;
  import sailpoint.object.Filter.LeafFilter;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.Schema;
  import sailpoint.object.ManagedAttribute;
  import sailpoint.tools.RFC4180LineIterator;
  import sailpoint.tools.RFC4180LineParser;
  import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.*;
 
 String username = "identityiqdev";
    String password = "Identityiq123$";
    String url = "jdbc:sqlserver://sv-spidsql-d1.carefirst.com";
    Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
    Connection connection = DriverManager.getConnection(url, username, password);
  System.out.println("connection............................"+connection);
   
	String identityName = identityModel.get("identityName");
	String userid = identityModel.get("userid");
	String applicationName = identityModel.get("applicationName");
	Statement stmt = connection.createStatement();
	String sqlQuery = "select nativeIdentity from discApp_details where identityName='"+identityName+"' and applicationName='"+applicationName+"'";
	ResultSet rs = stmt.executeQuery(sqlQuery);
	String nativeIdentity = "";
  if(rs!=null){  
	while ( rs.next() ) {
                
        				//nativeIdentity.add(rs.getString("nativeIdentity"));
        nativeIdentity=rs.getString("nativeIdentity")+","+nativeIdentity;
               
            }
        }
    connection.close();
        identityModel.put("nativeIdentity",nativeIdentity);
        System.out.println("nativeIdentity.."+identityModel);
 	return nativeIdentity;
      </Source>
      </Script>
      <Transition to="View NativeID Form"/>
    </Step>
    <Step icon="Approval" name="View NativeID Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel,nativeIdentity">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CF-Form-Delete-NativeID-UserDisconnectedAppDetails"/>
        <Arg name="workItemForm" value="CF-Form-Delete-NativeID-UserDisconnectedAppDetails"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launche+identityModelr);
    </Description>
      <Transition to="DeleteUserDetailsFromDatabase"/>
    </Step>
    <Step name="DeleteUserDetailsFromDatabase">
      <Script>
        <Source>
      import sailpoint.object.Identity;
        import java.text.DateFormat; 
        import java.text.SimpleDateFormat;
        import java.util.Date; 
        import org.apache.log4j.Logger;
		  import java.util.List;
  import java.util.HashMap;
  import sailpoint.tools.Util;
  import sailpoint.object.Application;
  import sailpoint.object.Bundle;
  import sailpoint.object.Custom;
  import sailpoint.object.Classification;
  import sailpoint.object.ObjectClassification;
  import sailpoint.object.Identity;
  import sailpoint.object.IdentitySelector;
  import sailpoint.object.IdentitySelector.MatchExpression;
  import sailpoint.object.IdentitySelector.MatchTerm;
  import sailpoint.object.IdentitySelector.MatchTerm.Type;
  import sailpoint.object.Link;
  import sailpoint.object.Profile;
  import sailpoint.object.Filter;
  import sailpoint.object.Filter.LeafFilter;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.Schema;
  import sailpoint.object.ManagedAttribute;
  import sailpoint.tools.RFC4180LineIterator;
  import sailpoint.tools.RFC4180LineParser;
  import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.*;
 
 String username = "identityiqdev";
    String password = "Identityiq123$";
    String url = "jdbc:sqlserver://sv-spidsql-d1.carefirst.com";
    Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
    Connection connection = DriverManager.getConnection(url, username, password);
  System.out.println("connection............................"+connection);
   
	String identityName = identityModel.get("identityName");
  String userid = identityModel.get("userid");
	String applicationName = identityModel.get("applicationName");
  String nativeIdentity = identityModel.get("natId");
   System.out.println("Identity Name:---------"+identityName+" Application Name:-----------"+applicationName+" Native Identity:--------"+nativeIdentity); 
	     
	String sqlQuery = "DELETE FROM discApp_details WHERE identityName='"+identityName+"' and nativeIdentity='"+nativeIdentity+"' and applicationName='"+applicationName+"'";
        PreparedStatement stmt = connection.prepareStatement(sqlQuery);
	stmt.executeUpdate();
	connection.close();  
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end"/>
  </Workflow>
  <Workflow created="1606981663940" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5a7623139d817627923cc40530" libraries="Identity,BatchRequest" modified="1611740815399" name="CareFirst-Workflow-ImmediateTermination" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="requester">
      <Description>
      The person who has requested the update.
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="identityName" type="input">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="launcher">
      <Description>
      Shows the requester.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="requester">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable initializer="true" name="transient">
      <Description>
      Set to false to cause workflow-related objects, such as approval
        work items, to be saved in the database even if they are only
        viewed by the person registering.
	
            
        			Set to true to cause workflow-related objects, such as approval
        work items, not saved in the database even if they are only
        viewed by the person registering.
      </Description>
    </Variable>
    <Description>
    Initialize the data in the model.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        return identityModel;

      </Source>
      </Script>
      <Transition to="App Display Form"/>
    </Step>
    <Step icon="Approval" name="App Display Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CareFirst-Form-UserImmediateTermination"/>
        <Arg name="workItemForm" value="CareFirst-Form-UserImmediateTermination"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="Confirmation Form"/>
    </Step>
    <Step icon="Approval" name="Confirmation Form" posX="269" posY="10">
      <Approval mode="serial" owner="ref:launcher" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CareFirst-Form-ImmediateUserTermination-Confirmatin-Form"/>
        <Arg name="workItemForm" value="CareFirst-Form-ImmediateUserTermination-Confirmation"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
      </Approval>
      <Description>
      Display the confirmation form to the registrant.
    </Description>
      <Transition to="Set identity name"/>
    </Step>
    <Step name="Set identity name" posX="507" posY="6" resultVariable="identityName">
      <Description>
      Set the identityName workflow variable based on the form input.
    </Description>
      <Script>
        <Source>
        return identityModel.get("identityName");
      </Source>
      </Script>
      <Transition to="Build Plan"/>
    </Step>
    <Step name="Build Plan" resultVariable="plan">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import java.text.DateFormat; 
        import java.text.SimpleDateFormat;
        import java.util.Date; 

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.ImmediateTrigger");
        log.info("identityName in BuildPlan step "+identityName);

        Identity identity =context.getObjectByName(Identity.class,identityName);
        if(identity != null){
          identity.setInactive(true);
          identity.setAttribute("action","TER");
          identity.setAttribute("employeestatus","Terminate");
          Date date = new Date(); 
          DateFormat dateFormat = new SimpleDateFormat("dd-MMM-yy");  
          String strDate = dateFormat.format(date); 
          identity.setAttribute("enddate",strDate);
          context.saveObject(identity);
          context.commitTransaction();
        }

      </Source>
      </Script>
      <Transition to="TriggerLeaverWorkflow"/>
    </Step>
    <Step name="TriggerLeaverWorkflow">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Description>
      Calling the leaver workflow to disable the accounts.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c758812a9817588d9c5d00004" name="CF-Leaver-Workflow"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end"/>
  </Workflow>
  <Workflow created="1603889311690" id="0a111e5c756f1eb681756f40afc9002e" modified="1603889311880" name="Identity Request Violation Review" type="Subprocess">
    <Variable initializer="false" name="trace">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="project" required="true">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="plan" required="true">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="source"/>
    <Variable input="true" name="optimisticProvisioning" required="true">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable input="true" name="policyScheme"/>
    <Variable input="true" name="asyncCacheRefresh">
      <Description>
      Set to true to enable asynchronous refresh of the policy and role
      caches.  This speeds up response time for the LCM user, but you
      may want to disable this during demonstrations after editing
      the role or policy models.  This may also be enabled globally
      in the system configuration.  This variable overrides the system
      configuration if it has a value.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority of the IdentityRequest.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attribute is passed in and contains the current
       set of approvalItems in the request. When a user chooses
       to remove a problematic approval item from the request, we
       update this value before returning to the calling workflow.
    </Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="allowRequestsWithViolations">
      <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request.
    </Description>
    </Variable>
    <Variable input="true" name="requireViolationReviewComments">
      <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations.
     </Description>
    </Variable>
    <Variable name="violationReviewDecision">
      <Description>
       Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

       -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

    </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
      Completion comments added if the user decides to proceed with the
      request without addressing the policy violations. These comments
      will be propagated to all other approvals.
    </Description>
    </Variable>
    <Variable name="originalPlan">
      <Description>
      The original plan calculated for the request.  As request modifications
      are submitted and resubmitted after violation review, we will revert to
      the original plan, so that the new selections can be calculated starting
      from a clean slate. 
    </Description>
    </Variable>
    <Description>
   This sub-process determines if there are any violations which will be
   caused by the request specified in the plan. If the policy scheme is
   'interactive' the user will be presented with a form which details
   the actions they can take to deal with the violations. Otherwise,
   control is returned to the calling process.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="22" posY="13">
      <Transition to="Save Original Plan"/>
    </Step>
    <Step name="Save Original Plan" posX="118" posY="13">
      <Description>
      When a policyScheme of "interactive" is set, the user has an opportunity
      to resolve the violation by removing requests.  Multiple iterations of
      this form may be submitted.  Each submission must reset the plan so that
      when the plan is compiled anew with the new set of decisions, the
      original master plan is utilized.  This step saves that master plan.
      It is reloaded in the "Reset Original Plan" step.
    </Description>
      <Script>
        <Source>
        import sailpoint.object.ProvisioningPlan;
        
        if (null != project) {
            ProvisioningPlan master = project.getMasterPlan();
            if (null != master) {
                ProvisioningPlan copy = (ProvisioningPlan) master.deepCopy(wfcontext.getSailPointContext());
                workflow.put("originalPlan", copy);
            }
        }
      </Source>
      </Script>
      <Transition to="Check Policies"/>
    </Step>
    <Step action="checkPolicyViolations" icon="Task" name="Check Policies" posX="220" posY="13" resultVariable="policyViolations">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policies" value="ref:policiesToCheck"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="asyncCacheRefresh" value="ref:asyncCacheRefresh"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Transition to="Reset Original Plan" when="script:((!&quot;ignore&quot;.equals(violationReviewDecision) &amp;&amp; !&quot;cancel&quot;.equals(violationReviewDecision) ) &amp;&amp; size(policyViolations) > 0 &amp;&amp; (policyScheme.equals(&quot;interactive&quot;)))"/>
      <Transition to="end"/>
    </Step>
    <Step name="Reset Original Plan" posX="378" posY="9">
      <Description>
      In this step, we need to reload the original plan because previous
      decisions may have modified the plan, so start with the original complete
      plan.  Also see the step "Save Original Plan".
    </Description>
      <Script>
        <Source>
        if (null != originalPlan) {
            plan = (ProvisioningPlan) originalPlan.deepCopy(wfcontext.getSailPointContext());
            workflow.put("plan", plan);
        }
      </Source>
      </Script>
      <Transition to="Violation Review"/>
    </Step>
    <Step icon="Approval" name="Violation Review" posX="446" posY="210">
      <Approval mode="ref:approvalMode" owner="ref:launcher" renderer="lcmViolationReviewRenderer.xhtml" send="identityDisplayName,identityName,policyViolations,approvalSet,violationReviewDecision,requireViolationReviewComments,allowRequestsWithViolations">
        <AfterScript>
          <Source>
          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;
          import sailpoint.object.ProvisioningPlan;
          import sailpoint.object.Comment;


          if (item == null) {
              return;
          }

          workflow.put("violationReviewDecision", item.get("violationReviewDecision"));
          
          // Assimilate all of the approvalItem changes into our global
          // approval set
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              Identity id = item.getOwner();
              String ownerName = null;
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, false);
          } else {
              throw new GeneralException("ApprovalSet not found in afterscript.");
          }
          
          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
        </Source>
        </AfterScript>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Policy Violation Review - Account Changes for User: $(identityDisplayName)"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemType" value="ViolationReview"/>
      </Approval>
      <Description>
      Give the user the option of either removing problematic request items, or
      affirm that they are aware of the violations and wish to continue.
    </Description>
      <Transition to="Handle Violation Review Decision"/>
    </Step>
    <Step icon="Task" name="Handle Violation Review Decision" posX="248" posY="210">
      <Description>

    </Description>
      <Transition to="Process Violation Review Decisions"/>
    </Step>
    <Step action="call:processPlanApprovalDecisions" icon="Task" name="Process Violation Review Decisions" posX="60" posY="210" resultVariable="plan">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="disableAudit" value="true"/>
      <Description>
      Process the decisions made by the user. This will update the plan by removing
      any items that were rejected by the user.
    </Description>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Task" name="Compile Project" posX="114" posY="134" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Description>Recompile the provisioning plan into a provisioning project, taking into
      consideration any items removed on the violation review form.</Description>
      <Transition to="Save Original Plan"/>
      <Transition to="end" when="script:(&quot;cancel&quot;.equals(violationReviewDecision) || &quot;ignore&quot;.equals(violationReviewDecision))"/>
    </Step>
    <Step icon="Stop" name="end" posX="288" posY="131"/>
  </Workflow>
  <Workflow created="1603889311710" id="0a111e5c756f1eb681756f40afde002f" libraries="Identity,IdentityRequest" name="Identity Request Initialize" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="plan" required="true">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="optimisticProvisioning" required="true">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable input="true" name="asyncCacheRefresh">
      <Description>
      Set to true to enable asynchronous refresh of the policy and role
      caches.  This speeds up response time for the LCM user, but you
      may want to disable this during demonstrations after editing
      the role or policy models.  This may also be enabled globally
      in the system configuration.  This variable overrides the
      system configuration if it has a value.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable input="true" name="allowRequestsWithViolations">
      <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request.
    </Description>
    </Variable>
    <Variable input="true" name="requireViolationReviewComments">
      <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations.
     </Description>
    </Variable>
    <Variable initializer="Identity Update" input="true" name="formTemplate">
      <Description>
      Template used when processing provisioning forms.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      interactive -  allow requester to remove request items which are causing violations

      continue -  continue if policy violations are found

      fail -  fail and exit the workflow if any policy violations are found

    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority any generated workitems. It will
      also configure the priority of the request as
      on the generated Access Request.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable name="project" output="true">
      <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
    </Variable>
    <Variable name="policyViolations" output="true">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable name="approvalSet" output="true">
      <Description>
       This attribute is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved.

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable name="identityRequest">
      <Description>
       The request object we get back from the create call. This is
       primarily useful for debugging.
    </Description>
    </Variable>
    <Variable name="identityRequestId">
      <Description>
        The id of the IdentityRequest created.
    </Description>
    </Variable>
    <Variable name="violationReviewDecision" output="true">
      <Description>
     Decision made by the user in the Policy Violation Review step.
     This may be one of three choices:

     -ignore:   User is ignoring the violations and letting the request continue. If
                 requireViolationReviewComments=true the user will be required to enter
                 comments indicating why they are allowing the violations.

     -remediate: Indicates that the user removed the request items that were causing the
                 violations

     -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

    </Description>
    </Variable>
    <Variable initializer="script:( Util.otob(getConfiguration(&quot;lcmEnableApprovalRecommendations&quot;)))" input="true" name="enableApprovalRecommendations">
      <Description>
        Flag to determine if recommendations should be gathered for the approvals.
      </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
      Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.
    </Description>
    </Variable>
    <Description>
      This workflow subprocess is used to initialize the various
      object necessary when executing workflows that deal
      with provisioning.

      This subprocess was added in 5.5 in an effort to
      break groups of related steps into a single call
      from the top level workflow.

      It now encapsulates the following services:

        - Compliation of the plan into a project
        - Build an approval set
           defaults to using buildApprovalSet but allows it to be passed in
        - Audit Start
        - Create the IdentityRequest object for the request tracking
        - Check policies
        - Build required forms for the launcher

  </Description>
    <Step icon="Start" name="Start" posX="25" posY="15">
      <Transition to="Compile Project"/>
    </Step>
    <Step action="call:compileProvisioningProject" icon="Task" name="Compile Project" posX="121" posY="15" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
      <Arg name="noApplicationTemplates">
        <Script>
          <Source>
            boolean ignoreForms = false;
            if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
               ignoreForms = true;
            }
            return ignoreForms;
        </Source>
        </Script>
      </Arg>
      <Arg name="noLocking">
        <Script>
          <Source>
            boolean noLocking = false;
            if ("Lifecycle".equals(flow)) {
               noLocking = true;
            }
            return noLocking;
        </Source>
        </Script>
      </Arg>
      <Description>Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.</Description>
      <Transition to="end" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="end" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Build Approval Set" when="script:isNull(approvalSet)"/>
      <Transition to="Rebuild Approval Set"/>
    </Step>
    <Step action="call:buildApprovalSet" condition="script:isNull(approvalSet)" name="Build Approval Set" posX="260" posY="92" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Check Policies"/>
    </Step>
    <Step condition="script:(!policyScheme.equals(&quot;none&quot;))" name="Check Policies" posX="391" posY="92">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="asyncCacheRefresh" value="ref:asyncCacheRefresh"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
      <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="project" to="project"/>
      <Return name="plan" to="plan"/>
      <Return name="violationReviewDecision" to="violationReviewDecision"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afc9002e" name="Identity Request Violation Review"/>
      </WorkflowRef>
      <Transition to="end" when="script:(&quot;cancel&quot;.equals(violationReviewDecision))"/>
      <Transition to="end" when="script:((policyScheme.equals(&quot;fail&quot;) &amp;&amp; (size(policyViolations) > 0 )  ))"/>
      <Transition to="Rebuild Approval Set"/>
    </Step>
    <Step action="call:buildApprovalSet" name="Rebuild Approval Set" posX="187" posY="252" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Build Approval Recommendations"/>
    </Step>
    <Step action="call:populateRecommendationsInApprovalSet" condition="ref:enableApprovalRecommendations" name="Build Approval Recommendations" posX="322" posY="252" resultVariable="approvalSet">
      <Arg name="identitySource" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Audit Start"/>
    </Step>
    <Step action="call:auditLCMStart" icon="Audit" name="Audit Start" posX="439" posY="252">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Transition to="Create Identity Request"/>
    </Step>
    <Step action="call:createIdentityRequest" icon="Task" name="Create Identity Request" posX="577" posY="252" resultVariable="identityRequest">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Transition to="Do Provisioning Forms Pre-Approval"/>
    </Step>
    <Step icon="Task" name="Do Provisioning Forms Pre-Approval" posX="741" posY="252">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="formTemplate" value="ref:formTemplate"/>
      <Arg name="requiredOwner" value="ref:sessionOwner"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms that can be filled out before approvals.
    </Description>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c4689ef016a" name="Do Provisioning Forms"/>
      </WorkflowRef>
      <Transition to="Assimilate Account Id Changes"/>
    </Step>
    <Step action="call:assimilateAccountIdChanges" icon="Task" name="Assimilate Account Id Changes" posX="740" posY="119" resultVariable="approvalSet">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Description>
      Assimilate the result of any accountId changes that may have been compiled into the plan back onto the ApprovalSet and IdentityRequest.
    </Description>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="740" posY="12"/>
  </Workflow>
  <Workflow created="1603889311760" id="0a111e5c756f1eb681756f40b00f0030" name="Identity Request Approve" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestId">
      <Description>
      Batch request id.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable initializer="script:getIdentityProperty(identityName, &quot;id&quot;)" input="true" name="identityId">
      <Description>
      The id of the identity being updated.
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
       The ID of the IdentityRequest for this request.
    </Description>
    </Variable>
    <Variable input="true" name="approvalScheme" required="true">
      <Description>
      A csv string that specifies how approvals should be generated for
      the incoming request.

      The value can be any of the values below, combined together but
      are always processed in this order:

      1. manager
      2. owner
      3. securityOfficer

      Any rejected items from previous approvals will be omitted from the
      next phase of approvers.

      none - disabled approvals

      owner - the object owner gets the approval
              For Role approvals this is the Role object owner. When dealing
              with things like Unlock and other account level changes
              the approvals will be assigned to the the application owner.

      manager - The manager will get all approvals

      securityOfficer - The identity named security the security in the variable
                        securityOfficerName.

    </Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
     A string that specifies how we should handle the approvals.

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.

     parallelPoll
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable input="true" name="fallbackApprover" required="true">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestApprover">
      <Description>
       Identity responsible for approving batch requests.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="includeRejectedItemsInApprovalChain">
      <Description>
       When using multi approvalSchemes a flag to indicate if new
       approvals in the chain will include rejected items.
    </Description>
    </Variable>
    <Variable input="true" name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="approvalSet" output="true">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="managerEmailTemplate">
      <Description>
       Name of the email template to use when manager of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
       Name of the email template to use when notifying the owner of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="securityOfficerEmailTemplate">
      <Description>
       Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="Batch Approval" input="true" name="batchApproverEmailTemplate">
      <Description>
       Name of the email template to use when notifying the batch approver of pending approval.
    </Description>
    </Variable>
    <Variable input="true" name="workItemComments">
      <Description>
       List of global workflow comments to be appended to the approval workitem.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="batchApproverElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the batch approver when performing batch operations.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority of the workitems generated
      as part of any generated approvals.
    </Description>
    </Variable>
    <Variable name="tmpApprovalSet">
      <Description>
       Temporary and transient  ApprovalSet used to hold filtered
       approval sets as we transition through the approval chain.
    </Description>
    </Variable>
    <Variable name="tmpApproval">
      <Description>
       Temporary and transient list of Approval object used to hold filtered
       approval as we transition through the approval chain.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Start Approval"/>
    </Step>
    <Step icon="Task" name="Start Approval" posX="28" posY="149">
      <Transition to="Manager Approval" when="script:isApprovalEnabled(approvalScheme, &quot;manager&quot;)"/>
      <Transition to="Build Owner ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;owner&quot;)"/>
      <Transition to="Build Security Officer ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;securityOfficer&quot;)"/>
      <Transition to="Batch Request Approval" when="script:isApprovalEnabled(approvalScheme, &quot;batchRequest&quot;)"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Approval" name="Manager Approval" posX="172" posY="7">
      <Approval mode="serial" owner="call:buildManagerApproval" renderer="lcmWorkItemRenderer.xhtml" send="approvalSet,identityDisplayName,identityName,policyViolations">
        <AfterScript>
          <Source>
          import sailpoint.workflow.IdentityRequestLibrary;

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
            auditDecisions(item);
        </Source>
        </AfterScript>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemElectronicSignature" value="ref:managerElectronicSignature"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Manager Approval - Account Changes for User: $(identityDisplayName)"/>
        <Arg name="workItemNotificationTemplate" value="ref:managerEmailTemplate"/>
        <Arg name="workItemTargetClass" value="sailpoint.object.Identity"/>
        <Arg name="workItemTargetName" value="$(identityName)"/>
        <Arg name="workItemTargetId" value="$(identityId)"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
      </Approval>
      <Description>
      If approvalScheme contains manager, send an approval for all
      requested items in the request. This approval will get the entire
      approvalSet as part of the workitem.
    </Description>
      <Transition to="Build Owner ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;owner&quot;)"/>
      <Transition to="Build Security Officer ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;securityOfficer&quot;)"/>
      <Transition to="end"/>
    </Step>
    <Step action="script:filterApprovalSet(approvalSet,includeRejectedItemsInApprovalChain,false)" icon="Task" name="Build Owner ApprovalSet" posX="237" posY="212" resultVariable="tmpApprovalSet">
      <Transition to="Owner Approval"/>
    </Step>
    <Step icon="Approval" name="Owner Approval" posX="389" posY="211">
      <Approval mode="ref:approvalMode" owner="call:buildOwnerApprovals" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations">
        <AfterScript>
          <Source>

          import sailpoint.workflow.IdentityRequestLibrary;

          if ( item == null )
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          auditDecisions(item);
        </Source>
        </AfterScript>
        <Arg name="approvalSet" value="ref:tmpApprovalSet"/>
        <Arg name="workItemDescription" value="Owner Approval - Account Changes for User: $(identityDisplayName)"/>
        <Arg name="workItemElectronicSignature" value="ref:ownerElectronicSignature"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemNotificationTemplate" value="ref:ownerEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
      </Approval>
      <Description>
      If approvalScheme contains owner, send approvals out to all
      of the owners for items in the request. The main approvalSet
      is broken up into owner specific approval sets and assimilated
      back into the main approvalset as decisions are made.

      The previous decisions made on the items will be present along
      with any comments made by the manager.

      This step will be skipped if all items are
      rejected and includeRejectedItemsInApprovalChain is set to false
    </Description>
      <Transition to="Build Security Officer ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;securityOfficer&quot;)"/>
      <Transition to="end"/>
    </Step>
    <Step action="script:filterApprovalSet(approvalSet,includeRejectedItemsInApprovalChain,false)" icon="Task" name="Build Security Officer ApprovalSet" posX="309" posY="61" resultVariable="tmpApprovalSet">
      <Transition to="Security Officer Approval"/>
    </Step>
    <Step condition="script:!isNull(tmpApprovalSet) &amp;&amp; !tmpApprovalSet.isEmpty()" icon="Approval" name="Security Officer Approval" posX="698" posY="59">
      <Approval mode="serial" owner="call:buildSecurityOfficerApproval" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations">
        <AfterScript>
          <Source>
          import sailpoint.workflow.IdentityRequestLibrary;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
        </Source>
        </AfterScript>
        <Arg name="approvalSet" value="ref:tmpApprovalSet"/>
        <Arg name="workItemElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Security Officer Approval - Account Changes for User: $(identityDisplayName)"/>
        <Arg name="workItemNotificationTemplate" value="ref:securityOfficerEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemTargetClass" value="sailpoint.object.Identity"/>
        <Arg name="workItemTargetName" value="ref:identityName"/>
        <Arg name="workItemTargetId" value="ref:identityId"/>
      </Approval>
      <Description>
     If approvalScheme contains securityOfficer and the securityOfficeName is
     non null this step will send items with decisions and comments
     from the cart for final decision.

     The previous decisions made on the item will be present along with
     any comments made in previous approval steps.
    </Description>
      <Transition to="Batch Request Approval"/>
    </Step>
    <Step icon="Approval" name="Batch Request Approval" posX="833" posY="59">
      <Approval mode="serial" owner="ref:batchRequestApprover" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName">
        <AfterScript>
          <Source>
          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
        </Source>
        </AfterScript>
        <Arg name="approvalSet" value="ref:approvalSet"/>
        <Arg name="workItemDescription" value="Batch Request Approval requested by $(launcher)"/>
        <Arg name="workItemElectronicSignature" value="ref:batchApproverElectronicSignature"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemNotificationTemplate" value="ref:batchApproverEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemTargetClass" value="sailpoint.object.BatchRequest"/>
        <Arg name="workItemTargetId" value="ref:batchRequestId"/>
      </Approval>
      <Description>
     If approvalScheme contains batchRequest and the batchRequestApprover is
     non null this step will send items with decisions and comments
     from the cart for final decision.
    </Description>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="920" posY="1"/>
  </Workflow>
  <Workflow created="1603889311789" id="0a111e5c756f1eb681756f40b02d0031" libraries="IdentityRequest" name="Identity Request Notify" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable initializer="user,requester" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.

     securityOfficer
       The identity named in the securityOfficerNameVariable will be notified.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
      The name of the security officer identity.
    </Description>
    </Variable>
    <Variable input="true" name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="approvalScheme">
      <Description>
       A string that specifies how approvals should be generated for
       this workflow.
       
       This is usefull for the notification subprocess incase
       the template wants to render specific text in the email
       when certain schemes are configured.
    </Description>
    </Variable>
    <Variable input="true" name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan for the request.</Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
       Name of the email template to use when notifying the user.
    </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
       Name of the email template to use when notifying the manager.
    </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
       Name of the email template to use when notifying the requester.
    </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="securityOfficerEmailTemplate">
      <Description>
       Name of the email template to use when notifying the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that was used
      to set the priority on the access request and
      any workitems.
    </Description>
    </Variable>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Notify User"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;user&quot;)" icon="Email" name="Notify User" posX="98" posY="10">
      <Arg name="template" value="ref:userEmailTemplate"/>
      <Arg name="to" value="script:getUserEmail(identityName, plan)"/>
      <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
      <Transition to="Notify Requester"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;requester&quot;)" icon="Email" name="Notify Requester" posX="216" posY="10">
      <Arg name="template" value="ref:requesterEmailTemplate"/>
      <Arg name="to" value="script:getEmail(launcher)"/>
      <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
      <Transition to="Notify Manager"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;manager&quot;)" icon="Email" name="Notify Manager" posX="351" posY="10">
      <Arg name="template" value="ref:managerEmailTemplate"/>
      <Arg name="to" value="script:getManagersEmail(identityName, plan)"/>
      <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
      <Transition to="Notify Security Officer"/>
    </Step>
    <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;securityOfficer&quot;)" icon="Email" name="Notify Security Officer" posX="483" posY="10">
      <Arg name="template" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="to" value="script:getEmail(securityOfficerName)"/>
      <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="602" posY="10"/>
  </Workflow>
  <Workflow created="1603889311825" id="0a111e5c756f1eb681756f40b0510032" libraries="Identity,IdentityRequest" name="Identity Request Provision" type="Subprocess">
    <Variable editable="true" initializer="false" input="true" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" input="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the resutls of the request.
    </Description>
    </Variable>
    <Variable input="true" name="fallbackApprover" required="true">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any manual actions  where the owner of the approver
      can't be resolved.
    </Description>
    </Variable>
    <Variable input="true" name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="Identity Update" input="true" name="formTemplate">
      <Description>
      Template used when processing provisioning forms.
    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>
      The plan may be passed in from the Create/Update Identity workflows.
      Otherwise the passed in project's master plan is typically used.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="recompile">
      <Description>
       Option that can be used to prevent recompilation after approval
       changes have been applied to the plan/project.
    </Description>
    </Variable>
    <Variable initializer="Pending Manual Changes" input="true" name="manualActionsEmailTemplate">
      <Description>
       Option that can be used to prevent recompilation after approval
       changes have been applied to the plan/project.
    </Description>
    </Variable>
    <Variable input="true" name="workItemComments">
      <Description>
       Global comments which should be appended to each approval item.
    </Description>
    </Variable>
    <Variable input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approvals should be generated for
      the incoming request.

      The value can be any of the values below, combined together but
      are always processed in this order:

      1. manager
      2. owner
      3. securityOfficer

      Any rejected items from previous approvals will be omitted from the
      next phase of approvers.

      none - disabled approvals

      owner - the object owner gets the approval
              For Role approvals this is the Role object owner. When dealing
              with things like Unlock and other account level changes
              the approvals will be assigned to the the application owner.

      manager - The manager will get all approvals

      securityOfficer - The identity named security the security in the variable
                        securityOfficerName.

    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
       The ID of the IdentityRequest.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority on any generated workitems for
      of forms or manual actions.
    </Description>
    </Variable>
    <Variable input="true" name="splitProvisioning">
      <Description>
          True to denote this is a partial of the full ProvisioningPlan. This should be true in the case of LCM Provisioning
          splits.
      </Description>
    </Variable>
    <Variable initializer="true" input="true" name="saveUnmanagedPlan">
      <Description>
      When true we will save unmanaged plan as ProvisioningRequest.
    </Description>
    </Variable>
    <Variable input="true" name="project" output="true">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Description>
      This workflow subprocess is used to provision a
      project.

      This subprocess was added in 5.5 in an effort to
      break groups of related steps into a single call
      from the top level workflow.

      It now encapsulates the following services:

        - Process approval decisions
           -- which recompiles the project
        - Post provisioning forms for user's outside of the requester

  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="15" posY="12">
      <Transition to="Start Provisioning Process"/>
    </Step>
    <Step action="call:addMessage" icon="Message" name="Start Provisioning Process" posX="130" posY="12">
      <Arg name="message" value="Modifications to $(identityDisplayName) are being provisioned."/>
      <Transition to="Process Approval Decisions"/>
    </Step>
    <Step action="call:processApprovalDecisions" condition="script:!isNull(approvalSet)" icon="Task" name="Process Approval Decisions" posX="309" posY="11" resultVariable="project">
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="recompile" value="ref:recompile"/>
      <Arg name="disableAudit" value="true"/>
      <Description>
      Dig through the ApprovalSets found in the Approval step and build an audit
      trail for the decisions.  Then for any rejected items remove them from
      the provisioning plan so they are not part of the provisioning request.
    </Description>
      <Transition to="Do Provisioning Forms Post-Approval"/>
    </Step>
    <Step icon="Task" name="Do Provisioning Forms Post-Approval" posX="511" posY="12">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="formTemplate" value="ref:formTemplate"/>
      <Arg name="preferredOwner" value="ref:sessionOwner"/>
      <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms that remain after approvals.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c4689ef016a" name="Do Provisioning Forms"/>
      </WorkflowRef>
      <Transition to="Pre Provision"/>
    </Step>
    <Step action="call:assimilateAccountIdChanges" icon="Task" name="Pre Provision" posX="682" posY="13" resultVariable="approvalSet">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Description>
      Before we approve assimilate the result of any accountId changes that may have been compiled
      into the plan back onto the ApprovalSet and IdentityRequest.
    </Description>
      <Transition to="Refresh Identity Request"/>
    </Step>
    <Step action="call:refreshIdentityRequestAfterApproval" icon="Task" name="Refresh Identity Request" posX="813" posY="13">
      <Arg name="project" value="ref:project"/>
      <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
      <Description>
       Assimilate any approval summaries that were built up during
       the provisioning process.
    </Description>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Task" name="Provision" posX="941" posY="13">
      <Arg name="project" value="ref:project"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
      <Arg name="recompileBeforeProvisioning" value="!ref:foregroundProvisioning"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
      <Return name="retries" to="retries"/>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a26016d" name="Provision with retries"/>
      </WorkflowRef>
      <Transition to="Wait for Queued Items"/>
    </Step>
    <Step icon="Task" name="Wait for Queued Items" posX="1074" posY="13">
      <Arg name="project" value="ref:project"/>
      <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
      <Arg name="trace" value="ref:trace"/>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a2e016e" name="Check Status of queued items"/>
      </WorkflowRef>
      <Transition to="Post Provision"/>
    </Step>
    <Step icon="Task" name="Post Provision" posX="1205" posY="13">
      <Script>
        <Source>
        import sailpoint.api.ObjectUtil;
        import sailpoint.tools.Util;
        import sailpoint.object.ProvisioningProject;

        if ( approvalSet != null ) {
            // Set state to pending
            approvalSet.initializeProvisioningState();
            if ( Util.otob(trace) ) {
                 System.out.println("ApprovalSet:\n" + approvalSet.toXml());
            }
        }
        if ( project != null ) {
            if ( Util.otob(trace) ) {
                 // clone and scrub the project so passwords are not visible
                 ProvisioningProject clonedProject = project.deepCopy(wfcontext.getSailPointContext());
                 ObjectUtil.scrubPasswords(clonedProject);
                 System.out.println("Project Executed in identitiy:\n" + clonedProject.toXml());
            }
        }
      </Source>
      </Script>
      <Transition to="Manual Actions"/>
    </Step>
    <Step condition="script:project.getUnmanagedPlan() != null" icon="Approval" name="Manual Actions" posX="1316" posY="13">
      <Approval mode="parallelPoll" owner="rule:Build Manual Action Approvals" renderer="lcmManualActionsRenderer.xhtml" send="identityDisplayName,identityName,policyViolations">
        <AfterScript>
          <Source>
          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;
          import sailpoint.object.WorkItem;
          import sailpoint.workflow.IdentityRequestLibrary;
          import sailpoint.workflow.IdentityLibrary;
          import sailpoint.tools.Util;

          if (item == null) {
              // must not be a leaf approval...
              return;
          }

          // mark all of the items finished once the item is complete
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              List approvalItems = set.getItems();
              for ( ApprovalItem approvalItem : approvalItems ) {
                  approvalItem.setState(WorkItem.State.Finished);
                  // update identity request provisioning state
                  IdentityRequestLibrary.updateIdentityRequestItemProvisioningState(approvalItem, wfcontext);
              }
          }
          
          //save unmanaged plan as ProvisioningRequest
          if ( Util.otob(saveUnmanagedPlan) ) {
              IdentityLibrary.saveUnmanagedPlan(wfcontext);
          }
          
          // Audit the manual change
          auditManualAction(item);
        </Source>
        </AfterScript>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemDescription" value="Manual Changes requested for User: $(identityDisplayName)"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemType" value="ManualAction"/>
        <Arg name="workItemNotificationTemplate" value="ref:manualActionsEmailTemplate"/>
      </Approval>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="1419" posY="13"/>
  </Workflow>
  <Workflow created="1603889311850" id="0a111e5c756f1eb681756f40b06a0033" libraries="Identity,IdentityRequest" name="Identity Request Finalize" type="Subprocess">
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
      From the project the IdentityRequestItem model will be updated.
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId" output="true">
      <Description>
       The ID ot the identitytRequestId.

       This step will update the identityRequest status and completion
       status.
    </Description>
    </Variable>
    <Variable input="true" name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
    </Variable>
    <Variable input="true" name="ticketDataGenerationRule">
      <Description>
      A rule that builds up the ticketing provisioning plan based on the workflow
      context.  This rule gets all of the arguments to this subprocess
      plus the curreent workflow context.  The rule can return either a
      ProvisioningPlan or a Map of name value pairs.

      The rule name can be specified here on the subprocess or on the
      ticketManagementApplication config under the same name as this
      variable.
    </Description>
    </Variable>
    <Variable name="autoVerifyIdentityRequest">
      <Description>
      Flag to indicate when finishing the request we should
      automatically mark it verified. Currently used by
      the change password workflow so we don't wait to
      verify since passwords can't be verifed.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that was used
      to set the priority of the IdentityRequest and
      workitems.
    </Description>
    </Variable>
    <Step icon="Start" name="Start" posX="15" posY="12">
      <Transition to="Audit Completion"/>
    </Step>
    <Step action="call:auditLCMCompletion" icon="Audit" name="Audit Completion" posX="115" posY="12">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Transition to="Complete Identity Request"/>
    </Step>
    <Step action="call:completeIdentityRequest" icon="Task" name="Complete Identity Request" posX="261" posY="12" resultVariable="identityRequest">
      <Arg name="project" value="ref:project"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="autoVerify" value="$(autoVerifyIdentityRequest)"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Transition to="Update Ticket On Complete"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket On Complete" posX="443" posY="12">
      <Arg name="action" value="complete"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="601" posY="13"/>
  </Workflow>
  <Workflow created="1603889311862" explicitTransitions="true" id="0a111e5c756f1eb681756f40b0760034" name="Identity Request Approve Identity Changes" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
       The ID of the IdentityRequest.
    </Description>
    </Variable>
    <Variable input="true" name="plan" required="true">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable initializer="LCM Identity Approval" input="true" name="formTemplate">
      <Description>Name of the form Template to use when building provisioning form.</Description>
    </Variable>
    <Variable input="true" name="approvalSet" output="true">
      <Description>
       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable input="true" name="approvers">
      <Description>Owners that should recieve the approval.</Description>
    </Variable>
    <Variable input="true" name="approvalScheme">
      <Description>
      A String that specifies how approvals should be generated for
      this workflow there are five built-in modes

      none - disabled approvals

      manager - The user's current manager will get approvals

      newManager - The newly assigned manager will get approvals when
                   manager transfers occur. Otherwise the user's manager
                   current manager will be the approver.

      securityOfficer - The identity in the securityOfficerName variable
                        will get approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
    </Variable>
    <Variable name="approvalForm">
      <Description>The generated form that is displayed to the user during the approval.</Description>
    </Variable>
    <Variable input="true" name="fallbackApprover" required="true">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any manual actions  where the owner of the approver
      can't be resolved.
    </Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
     A string that specifies how we should handle the approvals.

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.

     parallelPoll
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable input="true" name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority of any generated approval
      workitems.
    </Description>
    </Variable>
    <Variable input="true" name="approverElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the batch approver when performing batch operations.
    </Description>
    </Variable>
    <Description>
     The subprocess that drives the Create and Update Identity workflows.
     This is different then the Identity Request Approve subprocess because this
     approval process produces a form with the approval so that
     approvers can update values while approving.

     This subprocess builds the form necessary for the editable approvals
     and then assimilates that data entered back to the plan, which
     can be returned from the subprocess.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="14" posY="12">
      <Transition to="Build Approval Form"/>
    </Step>
    <Step action="call:buildPlanApprovalForm" icon="Task" name="Build Approval Form" posX="106" posY="12" resultVariable="approvalForm">
      <Arg name="plan" value="ref:plan"/>
      <Arg name="template" value="ref:formTemplate"/>
      <Transition to="Customize Approval Form"/>
    </Step>
    <Step name="Customize Approval Form" posX="247" posY="12" resultVariable="approvalForm">
      <Description>
       using the form that was generaed, mMrk the password field read only so approvers
       can't change it.  Also associate a Rule with the name so name changes during
       approvals can be validate.
    </Description>
      <Script>
        <Source>
        import sailpoint.object.Field;
        import sailpoint.object.Form;
        import sailpoint.object.Rule;
        import sailpoint.object.Configuration;
        import sailpoint.tools.Util;

        if ( approvalForm != null ) {
            Field passwordField = approvalForm.getField("IIQ:password");
            if ( passwordField != null ) {
                passwordField.setReadOnly(true);

                Configuration config = wfcontext.getSailPointContext().getObject(Configuration.class, Configuration.OBJ_NAME);
                boolean requirePassword = Util.atob(config.getString(Configuration.LCM_REQUIRE_PASSWORD_IDENTITY_CREATE));
                passwordField.setRequired(requirePassword);
            }
            Field userId = approvalForm.getField("IIQ:name");
            if ( userId != null ) {
                String ruleName = "LCM Validate Identity Name";
                Rule rule = wfcontext.getSailPointContext().getObject(Rule.class, ruleName);
                if ( rule != null ) {
                    userId.setValidationRule(rule);
                }
            }
            Field manager = approvalForm.getField("IIQ:manager");
            if ( manager != null ) {
                // tell the FormBean to output the value as a name
                // instead of ID which is the default
                manager.addAttribute(Field.ATTR_VALUE_PROPERTY, "name");
            }
        }
        return approvalForm;
      </Source>
      </Script>
      <Transition to="Build Approvers If Necessary"/>
    </Step>
    <Step action="call:getIdentityCreateUpdateApprovals" condition="script:isNull(approvers)" icon="Task" name="Build Approvers If Necessary" posX="429" posY="12" resultVariable="approvers">
      <Description>
      If the approvals weren't passed in then build them up using our
      default rule.
    </Description>
      <Transition to="Approval"/>
    </Step>
    <Step icon="Approval" name="Approval" posX="577" posY="12">
      <Approval mode="ref:approvalMode" owner="ref:approvers" renderer="lcmEditableWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations, approvalSet">
        <AfterScript>
          <Source>
          import sailpoint.workflow.IdentityRequestLibrary;

          import sailpoint.object.ApprovalSet;
          import sailpoint.object.WorkItem;
          import sailpoint.object.WorkflowCase;
          import sailpoint.object.Form;
          import sailpoint.object.ProvisioningPlan.AccountRequest;
          import sailpoint.object.ProvisioningPlan.AttributeRequest;
          import sailpoint.util.GeneralException;

          if (item == null) {
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          //
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its
              // one or the other
              String completionComments = item.getCompletionComments();
              Identity id = item.getOwner();
              String ownerName = null;
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in afterscript.");
          }

          // djs: this is kind of a hack, do I have alternatives?
          // come back to this
          // jsl: Yes, I think you want &lt;Return name='workItemForm' to='approvalForm'/>
          Form form = (Form)item.get("workItemForm");
          if ( form != null ) {
              WorkflowCase c = wfcontext.getWorkflowCase();
              if ( c != null ) {
                  c.put("approvalForm", form);
              }
          }

          // bug#9611 if we notice that the manager request was edited,
          // change the next approval
          if (approvalScheme == null ||
              approvalScheme.contains("manager") ||
              approvalScheme.contains("newManager")) {
              Form form = item.getForm();
              if (form != null) {
                  Field field = form.getField("IIQ:manager");
                  if (field != null) {
                      String newManager = field.getValue();
                      if (newManager != null) {
                          Approval newApproval = null;
                          if (approval != null) {
                              Approval parent = approval.getParent();
                              if (parent != null) {
                                  // find the one after us
                                  List approvals = parent.getChildren();
                                  if (approvals != null) {
                                      Approval prev = null;
                                      for (int i = 0 ; i &lt; approvals.size() ; i++) {
                                          Approval a = (Approval)approvals.get(i);
                                          if (prev == approval) {
                                             newApproval = a;
                                             break;
                                          }
                                          else
                                            prev = a;
                                      }
                                  }
                              }
                          }

                          // newApproval can be null if the user didn't start
                          // with a manager or if the current manager requested
                          // the change
                          if (newApproval != null) {
                              String oldManager = newApproval.getOwner();

                              // If the managers aren't equal, this *could* be a manager change
                              // or it could just be some other type of approval.
                              if (!newManager.equals(oldManager)) {

                                  // Get the manager that was submitted in the plan.
                                  String planager = null;
                                  if (null == plan) {
                                      log.warn("Expected a plan variable in identity request " +
                                               "approval AfterScript.");
                                  }
                                  else {
                                      AccountRequest iiqReq = plan.getIIQAccountRequest();
                                      if (null != iiqReq) {
                                          AttributeRequest managerReq =
                                              iiqReq.getAttributeRequest("manager");
                                          if (null != managerReq) {
                                              planager = managerReq.getValue();

                                              // May have an ID or name, so load it to get the name.
                                              Identity manager =
                                                  context.getObject(Identity.class, planager);
                                              if (null != manager) {
                                                  planager = manager.getName();
                                              }
                                          }
                                      }
                                  }

                                  // If the newManager is the same as what was originally submitted
                                  // then we haven't really changed the manager ... the newApproval
                                  // was for a different type of approver (eg - securityOfficer).
                                  if ((null == planager) || !planager.equals(newManager)) {
                                      log.info("Changing new manager approval owner from " +
                                               oldManager + " to " + newManager);
                                      newApproval.setOwner(newManager);

                                      // The old owner could have been cached.  Clear it to
                                      // make sure this goes to the right guy.
                                      newApproval.setIdentity(null);
                                  }
                              }
                          }
                      }
                  }
              }
          }

          //
          // If they are all rejected mark the Approval Rejected.
          // This allows the Transition to execute once we
          // get a rejection.
          //
          if ( approvalSet.isAllRejected() ) {
              approval.setState(WorkItem.State.Rejected);
          }

          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
          auditDecisions(item);
        </Source>
        </AfterScript>
        <Arg name="workItemDescription" value="Account Changes for User: $(identityDisplayName)"/>
        <Arg name="workItemElectronicSignature" value="ref:approverElectronicSignature"/>
        <Arg name="workItemForm" value="ref:approvalForm"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="workItemType" value="Approval"/>
      </Approval>
      <Transition to="Assimilate Form Changes"/>
    </Step>
    <Step action="call:assimilatePlanApprovalForm" icon="Task" name="Assimilate Form Changes" posX="712" posY="12" resultVariable="plan">
      <Arg name="form" value="ref:approvalForm"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="plan" value="ref:plan"/>
      <Description>
      This step takes the form from the workitem and applys any edits that were
      made back into the plan.
    </Description>
      <Transition to="Check Plan and Update Cart"/>
    </Step>
    <Step icon="Task" name="Check Plan and Update Cart" posX="877" posY="12" resultVariable="plan">
      <Description>
      This step takes looks for name changes during creates and updates
      the stub identity on the plan accordingly.
    </Description>
      <Script>
        <Source>
        
        import sailpoint.api.ObjectUtil;
        import sailpoint.object.ApprovalSet;
        import sailpoint.object.ApprovalItem;
        import sailpoint.object.Filter;
        import sailpoint.object.Identity;
        import sailpoint.object.ProvisioningPlan;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.QueryOptions;

        List accountRequests = plan.getAccountRequests(ProvisioningPlan.APP_IIQ);

        if ( accountRequests != null &amp;&amp; !accountRequests.isEmpty() &amp;&amp; accountRequests.get(0) != null) {
            AccountRequest iiq = accountRequests.get(0);
            // Look for the name attribute
            boolean nameChanged = false;
            String idName = identityName;
            AttributeRequest name = iiq.getAttributeRequest("name");
            if ( name != null ) {
                String nameStr = Util.otoa(name.getValue());
                if ( nameStr != null ) {
                    nameStr = nameStr.trim();
                    // If they don't match this indicates a form
                    // update changes the accountId
                    if ( identityName.compareTo(nameStr) != 0 ) {
                        // If this is a create request, then it is a new identity, and we need to
                        // re-verify that the identity does not exist. This is validated at the form level so should never
                        // happen in the normal course of events, but important to check in case of http request manipulation.
                        if (AccountRequest.Operation.Create.equals(iiq.getOperation())) {
                            QueryOptions qo = new QueryOptions();
                            Filter filter  = Filter.or(Filter.eq("id", nameStr), Filter.ignoreCase(Filter.eq("name", nameStr)));
                            qo.add(new Filter[]{filter});
                            qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());
                            int count = wfcontext.getSailPointContext().countObjects(Identity.class, qo);
                            if (count > 0) {
                                throw new GeneralException("User '"+ nameStr + "' already exists.");
                            }
                        }

                        idName = nameStr;
                        nameChanged = true;
                         // update the plan with the new/correct account ID
                        iiq.setNativeIdentity(idName);
                    }
                }
            }
            Identity planIdentity = plan.getIdentity();
            if ( ( planIdentity == null ) || ( nameChanged ) ) {
                SailPointContext ctx = wfcontext.getSailPointContext();
                Identity stub = ctx.getObjectByName(Identity.class, idName);
                if ( stub == null ) {
                    stub = new Identity();
                    stub.setName(idName);
                }
                plan.setIdentity(stub);
            }

            //
            // Update the approval item with any changes that
            // were made during the approval process
            //
            if ( approvalSet != null ) {
                List approvalItems =  approvalSet.getItems();
                // in the default case there is always just one item for all the changes
                if ( Util.size(approvalItems) == 1 ) {
                    // Re-flatten the attribute values so they are accurate when auditing changes
                    // and notifying. The values may have been updated in the approvalForm.
                    ApprovalItem item = approvalItems.get(0);
                    List attrRequestFlat = flattenAttributeRequests(iiq.getAttributeRequests());
                    if ( attrRequestFlat != null ) {
                        item.setValue(attrRequestFlat);
                    }
                    if ( nameChanged ) {
                        item.setNativeIdentity(idName);
                    }
                }
            }
        }
        return plan;
        
      </Source>
      </Script>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="1021" posY="12"/>
  </Workflow>
  <Workflow created="1603889311947" explicitTransitions="true" id="0a111e5c756f1eb681756f40b0cb0035" modified="1607330049442" name="Approve and Provision Subprocess" type="Subprocess">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
            The displayName of the identity being updated.
            Query for this using a projection query and fall back to the name.
        </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
            The name of the LCM flow that launched this workflow.

            This is one of these three values:

            AccountsRequest
            EntitlementsRequest
            RolesRequest
        </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
            Set to true to enable optimistic provisioning.  This will cause
            changes to the entitlements compiled from role assignments to be
            applied immediately to the identity cube rather than waiting
            for the next refresh/reaggregation after the provisioning system
            completes the request.
        </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
            Normally provisioning is done in a step that uses the "background"
            option to force the workflow to be suspend and be resumed in a
            background task thread.  This prevents the browser session from
            hanging since provision can sometimes take a long time.  For demos
            and testing it can be better to do this in the foreground so that
            provisioning will have been performed when control is returned to the
            user.  This prevents having to run the Perform Maintenance task to
            see the results of the request.
        </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
            Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
        </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
            The email template to use for user notification.
        </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
            The email template to use for requester notification.
        </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
            The email template to use for manager notification.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
            The email template to use for security officer notification.
        </Description>
    </Variable>
    <Variable initializer="parallel" input="true" name="approvalMode">
      <Description>
            A string that specifies how we should handle the approvals.

            By default this is serial since most of these request with
            the exception of manager transfers will have only one approver.

            parallel
            Approvals are processed concurrently and there must be consensus,
            we wait for all approvers to approve.  The first approver that
            rejects terminates the entire approval.

            parallelPoll
            Approvals are processed concurrently but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.

            serial
            Approvals are processed one at a time and there must be consensus.
            The first approver that rejects terminates the entire approval.

            serialPoll
            Approvals are processed in order but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.  In effect we are "taking a poll" of the approvers.

            any
            Approvals are processed concurrently, the first approver to
            respond makes the decision for the group.
        </Description>
    </Variable>
    <Variable initializer="owner" input="true" name="approvalScheme">
      <Description>
            A csv string that specifies how approval items should be generated
            for the incoming request.

            The value can be "none", in which case approvals are disabled.

            The value can also be a combination of any of the values below
            in any order, separated by commas. The order in which they are
            specified is the order in which they are processed:

            owner
            The object owner gets the approval item.
            For Role approvals this is the Role object owner.
            For Entitlement approvals this is the Entitlement object owner.

            manager
            The manager gets the approval item.

            securityOfficer
            The identity in the variable securityOfficerName gets the approval item.

            identity
            The identities/workgroups in the variable approvingIdentities get the approval item.
        </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
            The email template to use for approval notifications.
        </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
            The String version of a WorkItem.Priority. This variable is
            used to set the priority on all of the workitems generated
            as part of this workflow and also set on the IdentityRequest
            object.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
            The name of the identity that will be sent approvals
            during security officer approvals.
        </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
            A String that specifies the name of the Identity that will
            be assigned any approvals where the owner of the approver
            can't be resolved. Example if the scheme is "owner" and the
            application doesn't specify and owner.
        </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
            When set to true it will disable the workflow retry loop and let the
            Provision step launch requests to handle the retries.  Enabling
            this flag will enable some older functionality.
        </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to LCM.
        </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
            Used for debugging this workflow and when set to true trace
            will be sent to stdout.
        </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
            This attributes is set during the "Build Approval Set" step,
            which builds this list by going through the ProvisioningPlan
            to build the line items that need to be approved,

            This variable includes all ApprovalItems that are part of
            the request process and is updated during the AfterScript
            of the approval process by assimilating the decisions
            and comments from the Approvals copy of the ApprovalItem.
        </Description>
    </Variable>
    <Variable input="true" name="approvalAssignmentRule"/>
    <Variable name="project">
      <Description>
            ProvisioningProject which is just a compiled version of the ProvisioningPlan.
        </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
            List of policy violations that were found during our initial policy scan.
            This list is passed into each work item so the approvers can see
            pending violations.
        </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
            The sequence id of the Identity request object which is stored in
            the name field of the identity request and auto-incremented.
        </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
            Global comments accumulated during the workflow which should be shared
            with other approvals. When a new approval is created, the comments in this
            list will be added to the work item.
        </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
            Name of the application that can handle ticket requests.
            When non-null the Manage Ticket Steps will be visited to open
            tickets during the workflow lifecycle.
        </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by a manager.
        </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by object owners.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by the security officer.
        </Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable input="true" name="approvalSplitPoint">
      <Description>Approval Scheme to split on.</Description>
    </Variable>
    <Variable input="true" name="clearApprovalDecisions">
      <Description>
            True to clear any decisions on approvals built with buildCommonApprovals
        </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
            List of identities and/or workgroups names/ids that should be involved in the approval
            process.
        </Description>
    </Variable>
    <Variable input="true" name="formTemplate"/>
    <Variable input="true" name="manualActionsEmailTemplate"/>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
            Name of the email template to use when notifying the owner of pending approvals.
        </Description>
    </Variable>
    <Variable initializer="false" input="true" name="splitProvisioning">
      <Description>
            True to tell IdentityRequest Provisioning subprocess that this is a subset of the initial provisioning plan
        </Description>
    </Variable>
    <Description>Subprocess to approve and provision immediately. This is used after splitting an ApprovalSet into individual items to run in parallel.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="20" posY="20">
      <Transition to="Compile Project"/>
    </Step>
    <Step action="call:compileProvisioningProject" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Compile Project" posX="120" posY="20" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="noApplicationTemplates">
        <Script>
          <Source>
                    boolean ignoreForms = false;
                    if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
                    ignoreForms = true;
                    }
                    return ignoreForms;
                </Source>
        </Script>
      </Arg>
      <Transition to="Build Approval Set"/>
    </Step>
    <Step action="call:buildSplitApprovalSet" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Build Approval Set" posX="220" posY="20" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Approve"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" configForm="Provisioning Approval Step Form" icon="Approval" name="Approve" posX="320" posY="20">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature"/>
      <Arg name="identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="workItemComments"/>
      <Arg name="clearApprovalDecisions" value="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c46935f0198" name="Provisioning Approval Subprocess"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Approval"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="470" posY="20">
      <Arg name="action" value="postApproval"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Provision" name="Provision" posX="600" posY="20">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
      <Description>
            Call the standard subprocess that will process the
            approval decisions and do provisioning.  This
            includes calling any configured provisioning
            connectors and building manual actions.
        </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Provision"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="700" posY="20">
      <Arg name="action" value="postProvisioning"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
    </Step>
  </Workflow>
  <Workflow configForm="Provisioning Workflow Config Form" created="1603889311969" explicitTransitions="true" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c756f1eb681756f40b0e10036" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" modified="1617886785548" name="LCM Provisioning" taskType="LCM" type="LCMProvisioning">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.</Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>The name of the LCM flow that launched this workflow.

      This is one of these three values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest</Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.</Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>Normally provisioning is done in a step that uses the &amp;quot;background&amp;quot;
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.</Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.</Description>
    </Variable>
    <Variable name="batchRequest">
      <Script>
        <Source>
        import sailpoint.object.*;

        if(batchRequestItemId!=null){
        BatchRequestItem batchReqItem=context.getObjectById(BatchRequestItem.class,batchRequestItemId);
        System.out.println("batchReqItem===="+batchReqItem.toXml());
        if(batchReqItem!=null){
        BatchRequest batchReq=batchReqItem.getBatchRequest();
        if(batchReq!=null){
        if(batchReq.getFileContents()!=null){
        return Util.arrayToList(batchReq.getFileContents().split("\n")).get(0);
        }
        }
        }
        }

        return null;
      </Source>
      </Script>
    </Variable>
    <Variable name="batchRequestRow">
      <Script>
        <Source>
        import sailpoint.object.*;

        if(batchRequestItemId!=null){
        BatchRequestItem batchReqItem=context.getObjectById(BatchRequestItem.class,batchRequestItemId);
        if(batchReqItem!=null){
        String row=batchReqItem.getRequestData();
        if(row!=null){
        return row.split(",");
        }
        }
        }

        return null;
      </Source>
      </Script>
    </Variable>
    <Variable editable="true" initializer="false" name="doRefresh">
      <Description>Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.</Description>
    </Variable>
    <Variable initializer="none" input="true" name="notificationScheme">
      <Description>A string that specifies who should be notified when the request has been complete.
      The value can be null or a csv of one or more of the following options.

      none or null
      disable notifications

      user
      Identity that is being update will be notified.

      manager
      The manager of the Identity that is being updated will be notified.

      requester
      The person that has requested the update will be notified.</Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>The email template to use for user notification.</Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>The email template to use for requester notification.</Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>The email template to use for manager notification.</Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>The email template to use for security officer notification.</Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>A string that specifies how we should handle the approvals.

      By default this is serial since most of these request with
      the exception of manager transfers will have only one approver.

      parallel
      Approvals are processed concurrently and there must be consensus,
      we wait for all approvers to approve.  The first approver that
      rejects terminates the entire approval.

      parallelPoll
      Approvals are processed concurrently but consensus is not required.
      All approvals will be processed, we don&amp;#39;t stop if there are any
      rejections.

      serial
      Approvals are processed one at a time and there must be consensus.
      The first approver that rejects terminates the entire approval.

      serialPoll
      Approvals are processed in order but consensus is not required.
      All approvals will be processed, we don&amp;#39;t stop if there are any
      rejections.  In effect we are &amp;quot;taking a poll&amp;quot; of the approvers.

      any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.</Description>
    </Variable>
    <Variable initializer="owner" input="true" name="approvalScheme">
      <Description>A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be &amp;quot;none&amp;quot;, in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
      The object owner gets the approval item.
      For Role approvals this is the Role object owner.
      For Entitlement approvals this is the Entitlement object owner.

      manager
      The manager gets the approval item.

      securityOfficer
      The identity in the variable securityOfficerName gets the approval item.

      identity
      The identities/workgroups in the variable approvingIdentities get the approval item.</Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>The email template to use for approval notifications.</Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>The String version of a WorkItem.Priority. This variable is
      used to set the priority on all of the workitems generated
      as part of this workflow and also set on the IdentityRequest
      object.</Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>The name of the identity that will be sent approvals
      during security officer approvals.</Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can&amp;#39;t be resolved. Example if the scheme is &amp;quot;owner&amp;quot; and the
      application doesn&amp;#39;t specify and owner.</Description>
    </Variable>
    <Variable initializer="none" input="true" name="policyScheme">
      <Description>A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      continue -  continue if policy violations are found

      interactive -  allow requester to remove request items which are causing violations

      fail -  this option will cause the workflow to terminate immediately if any policy violations are found.
      Note that the requester will not be notified that the workflow has terminated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.</Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.</Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.</Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>Used for debugging this workflow and when set to true trace
      will be sent to stdout.</Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>This attributes is set during the &amp;quot;Build Approval Set&amp;quot; step,
      which builds this list by going through the ProvisioningPlan
      to build the line items that need to be approved,

      This variable includes all ApprovalItems that are part of
      the request process and is updated during the AfterScript
      of the approval process by assimilating the decisions
      and comments from the Approvals copy of the ApprovalItem.</Description>
    </Variable>
    <Variable initializer="true" name="allowRequestsWithViolations">
      <Description>If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request. This is only relevant
      if policyScheme=interactive.</Description>
    </Variable>
    <Variable initializer="true" name="requireViolationReviewComments">
      <Description>If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations. This
      is only relevant if policyScheme=interactive.</Description>
    </Variable>
    <Variable name="project">
      <Description>ProvisioningProject which is just a compiled version of the ProvisioningPlan.</Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>List of policy violations that were found during our initial policy scan.
      This list is passed into each work item so the approvers can see
      pending violations.</Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>The sequence id of the Identity request object which is stored in
      the name field of the identity request and auto-incremented.</Description>
    </Variable>
    <Variable name="violationReviewDecision">
      <Description>Decision made by the user in the Policy Violation Review step.
      This may be one of three choices:

      -ignore:   User is ignoring the violations and letting the request continue. If
      requireViolationReviewComments=true the user will be required to enter
      comments indicating why they are allowing the violations.

      -remediate: Indicates that the user removed the request items that were causing the
      violations

      -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.</Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.</Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.</Description>
    </Variable>
    <Variable name="ticketId">
      <Description>The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the &amp;quot;open&amp;quot; call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.</Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>The name of the electronic signature object that should be used when workitems
      are completed by a manager.</Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>The name of the electronic signature object that should be used when workitems
      are completed by object owners.</Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>The name of the electronic signature object that should be used when workitems
      are completed by the security officer.</Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>List of identities and/or workgroups names/ids that should be involved in the approval
      process.</Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.</Description>
    </Variable>
    <Variable input="true" name="identityEmailTemplate">
      <Description>Name of the email template to use when notifying the identities/workgroups of pending approvals.</Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable initializer="owner" name="approvalSplitPoint">
      <Description>Variable to determine when to split into parallel processing.
      This should map to a configured approvalScheme. We will process all schemes up until
      the approvalSplitPoint in the Pre Split approvals, and the remaining schemes after
      we split the items. If this is not specified, we will not split the Provisioning
      project, and process the entire project as a whole.</Description>
    </Variable>
    <Variable name="splitPlans">
      <Description>List of ProvisioningPlan that is generated from the splitPlans step if approvalSplitPoint is set.</Description>
    </Variable>
    <Variable name="splitProjects">
      <Description>Variable to store the returns if approvalSplitPoint is set. This will contain a List&amp;lt;ProvisioningProject&amp;gt;</Description>
    </Variable>
    <Variable name="splitApprovalSet">
      <Description>Variable to store the list of approvalSets returned from the split subprocess if approvalSplitPoint is set.</Description>
    </Variable>
    <Variable name="splitWorkItemComments">
      <Description>Variable to store the list of WorkItem comments returned from the split subprocess if approvalSplitPoint is set.</Description>
    </Variable>
    <Variable input="true" name="identityModel"/>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5877c41910817802825f2c2caa" name="CF-RoleSensitivity-CommonLibrary"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="122" posY="126">
      <Transition to="Check Operation"/>
    </Step>
    <Step name="ValidateRole" posX="1342" posY="474" resultVariable="continueFlag">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="action" value="open"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="ticketDataGenerationRule"/>
      <Description>
      To check the user fulfilling the conditions for requested role
    </Description>
      <Script>
        <Source>
        import sailpoint.object.Bundle;
        import java.util.ArrayList;
        import java.util.Arrays;
        import java.util.HashMap;
        import sailpoint.object.Configuration;
        import sailpoint.object.ProvisioningPlan.AbstractRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.EmailTemplate;
        import sailpoint.object.EmailOptions;
        import sailpoint.object.IdentityRequest;
        import sailpoint.object.IdentityRequestItem;
        import sailpoint.object.PersistentIdentityItem;
        import sailpoint.tools.Message;

        public void sendMail(String EmailTemplate,String userEmailID,String requesterName,String requestedRoleName,String brName){
        EmailTemplate template = context.getObjectByName(EmailTemplate.class, EmailTemplate);
        // String email = "Admin@carefirst.com";
        EmailOptions options = new EmailOptions();
        options.setTo(userEmailID);                
        options.setVariable("requesterName", requesterName);
        options.setVariable("requestedRoleName", requestedRoleName);
        options.setVariable("brName", brName);

        context.sendEmailNotification(template, options);

        }

        String roleName;
        String assignmentType=null;
        //System.out.println("plan "+plan.toXml());
        //System.out.println("launcher"+launcher);
        boolean launcherFlag;
        String identityEmail="";

        Identity identity=context.getObjectByName(Identity.class,identityName);
        //System.out.println("identityName"+identityName);
        //System.out.println("identity "+identity);
        //System.out.println("identity.getManager() "+identity.getManager());



        //System.out.println("ACC getAccountRequests "+plan.getAccountRequests("IIQ"));
        if(plan.getAccountRequests("IIQ")!=null){
        if((plan.getAccountRequests("IIQ").size()>=1)){
        int i=0;
        List removeList = new ArrayList();
        List removeRoleList = new ArrayList();
        for(i=0; i&lt;plan.getAccountRequests("IIQ").size();i++){
        //System.out.println("AAAAAAAAAAAA ");
        //System.out.println("ACC req "+plan.getAccountRequests("IIQ").get(i).toXml());
        AccountRequest accReq = plan.getAccountRequests("IIQ").get(i);
        if(accReq.getAttributeRequest("assignedRoles")!=null){
        //System.out.println("BBBBBBBBB ");

        AttributeRequest attReq = accReq.getAttributeRequest("assignedRoles");
        //System.out.println("attReq "+attReq.toXml());
        //System.out.println("attReq op "+attReq.getOp());
        String operation = attReq.getOp().toString();
        if(operation.equals("Add")){
        //System.out.println("CCCCCCCC ");
        //System.out.println("attReq "+attReq.getValue());
        roleName = attReq.getValue();
        if(roleName!=null){
        Bundle role=context.getObjectByName(Bundle.class,roleName);
        if(role!=null){
        assignmentType=role.getAttribute("assignment");
        //System.out.println("assignmentType "+assignmentType);


        if(assignmentType!=null @and assignmentType.equals("Discretionary_IT")){
        Bundle itRole=context.getObjectByName(Bundle.class,roleName);
        if(itRole!=null){
        String ciamBR=itRole.getAttribute("ciamBusinessRoleName");
        String userBR=identity.getAssignedRoleSummary();
        //System.out.println("ciamBR "+ciamBR);
        //System.out.println("userBR "+userBR);
        if(userBR!=null){
        if(ciamBR!=null){
        ArrayList ciamBRList = new ArrayList(Arrays.asList(ciamBR.split(",")));
        ArrayList userBRList = new ArrayList(Arrays.asList(userBR.split(", ")));
        //System.out.println("ciamBRList "+ciamBRList);
        //System.out.println("userBRList "+userBRList);
        boolean itRoleFlag = false;
        for(String ciamRole : ciamBRList){
        //System.out.println("ciamRole "+ciamRole);
        //System.out.println("userBRList.contains(ciamRole) "+userBRList.contains(ciamRole));


        if(userBRList.contains(ciamRole)){
        itRoleFlag=true;
        break;
        }
        }
        if(!itRoleFlag){
        //System.out.println("outside DR for ");
        // sendMail("For requseting the role "+roleName+" User should have one of these role :"+ciamBR);

        if(identity.getEmail()!=null){
        identityEmail=identity.getEmail();
        }else{
        identityEmail="Admin@carefirst.com";
        }
        String displayNameNew = identity.getDisplayName();



        sendMail("CF-IncorrectRole-EmailTemplate",identityEmail,displayNameNew,roleName,ciamBR);
        removeList.add(accReq);
        removeRoleList.add(roleName);
        //return false;
        }
        }
        else{
        //return false;
        }
        }
        else{
        //return false;
        }
        }
        //System.out.println("Test");
        }

        else{






        //System.out.println("111111111111111111 ");







        String ac = role.getAttribute("assignment_condition");
        ArrayList acList= new ArrayList();
        if(ac!=null){
        acList = new ArrayList(Arrays.asList(ac.split("\\|\\|")));
        //System.out.println("acList "+acList);
        }
        /*else{
        return true;
        }*/
        //System.out.println("role "+role);

        boolean businessRoleFlag = false;
        try {
        for(String st : acList){
        //System.out.println("SSSSS"+st);
        boolean flag = true;
        ArrayList conditionList = new ArrayList(Arrays.asList(st.split("\\|")));
        for(String condition : conditionList) {
        //System.out.println(condition);
        String [] attributes = condition.split(":");

        //System.out.println(identity.getAttribute(attributes[0]));
        //System.out.println(attributes[1]);
        if(identity.getAttribute(attributes[0])!=null){
        if(!(identity.getAttribute(attributes[0]).equalsIgnoreCase(attributes[1]))) {
        flag = false;
        }
        }else {
        flag=false;
        }

        }
        //System.out.println("flag "+flag);
        if(flag) {
        businessRoleFlag = true;
        break;
        }
        }
        }
        catch(Exception e) {
        System.out.println(e);
        return false;
        }
        if(!businessRoleFlag){
        //System.out.println("after for");
        //System.out.println("id "+identity);
        // sendMail("User is not eligible for this role "+roleName+". If you still need this role ask your manager to request for you"); 
        //  String identityEmail="";
        if(identity.getEmail()!=null){
        //System.out.println("id mail "+identity.getEmail());
        identityEmail=identity.getEmail();
        }else{
        identityEmail="Admin@carefirst.com";
        }
        System.out.println("id "+identity.getDisplayName());
        sendMail("CF-IncorrectRole-EmailTemplate",identityEmail,identity.getDisplayName(),roleName,"");
        removeList.add(accReq);
        removeRoleList.add(roleName);

        //return false;
        }



        }
        }
        }
        }
        }
        }
        //System.out.println("33333333333333333333 "+removeList);
        if(removeList!=null &amp;&amp; !removeList.isEmpty()){
        IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
        //System.out.println("*****AAAA*******idReq "+idReq.toXml());

        for(AccountRequest ar:removeList){
        plan.remove(ar);
        }
        List reqItems = idReq.getItems();
        for(IdentityRequestItem reqItem : reqItems){
        //System.out.println("Value **** "+reqItem.getValue());
        if(removeRoleList.contains(reqItem.getValue())){
        reqItem.setApprovalState(WorkItem.State.Rejected);
        reqItem.setProvisioningState(ApprovalItem.ProvisioningState.Failed);
        Message reqMessage = new Message();
        reqMessage.setType(Message.Type.Info);
        reqMessage.setKey("The requested role "+reqItem.getValue()+" cannot be assigned to you due to CareFirst Security Policy.");
        idReq.addMessage(reqMessage);
        }
        }

        //System.out.println("PROV PLAN AFTER REMOVAL "+plan.toXml());
        context.saveObject(idReq);
        context.commitTransaction();
        }
        }
        }
        //System.out.println("33333333333333 ");







        //System.out.println("Role"+pts.get(0).getRole());
        //System.out.println("TESTTTTT");

        return true;
      </Source>
      </Script>
      <Transition to="RoleCommentMapping" when="script:continueFlag"/>
      <Transition to="Exit On Assignment condition"/>
    </Step>
    <Step name="RoleCommentMapping" posX="1560" posY="474">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="action" value="open"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="ticketDataGenerationRule"/>
      <Description>
      To check the user fulfilling the conditions for requested role
    </Description>
      <Script>
        <Source>
        import sailpoint.object.Bundle;
        import java.util.ArrayList;
        import java.util.Arrays;
        import java.util.HashMap;
        import sailpoint.object.Configuration;
        import sailpoint.object.ProvisioningPlan.AbstractRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.EmailTemplate;
        import sailpoint.object.EmailOptions;
        import sailpoint.object.IdentityRequest;
        import sailpoint.object.IdentityRequestItem;

        System.out.println("**************--------------Plan to get comments---------------************"+plan.toXml());
        List accounts = plan.getAccountRequests();
        Map roleComment = new HashMap();
        if (accounts != null)
        {
        for ( sailpoint.object.ProvisioningPlan.AccountRequest acctRequest : accounts )
        {
        AttributeRequest attrReq = acctRequest.getAttributeRequest("assignedRoles");
        String roleName = "";
        String comment = "";
        if ( attrReq != null ) {
        Object obj = attrReq.getValue();
        if(obj instanceof String){
        roleName = attrReq.getValue();
        comment = attrReq.get("comments");
        roleComment.put(roleName,comment);
        System.out.println("*********Getting Object inside 1st If **********"+roleName+"********** Comments********"+comment);
        }
        if(obj instanceof List){
        roleName = attrReq.getValue().get(0);

        comment = attrReq.get("comments");
        roleComment.put(roleName,comment);
        System.out.println("*********Getting Object inside 2nd If **********"+roleName+"********** Comments********"+comment);
        }
        }
        }
        }
        System.out.println("*********Role to comment Map**********"+roleComment);
        String identityRequestId = plan.getArguments().getMap().get("identityRequestId");
        if(identityRequestId!=null){
        IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
        idReq.getAttributes().put("customComment",roleComment);
        context.saveObject(idReq);
        context.commitTransaction();
        }

        return true;
      </Source>
      </Script>
      <Transition to="Create Ticket" when="script:continueFlag"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="1180" posY="126">
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
      <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
      <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
      <Arg name="identityRequest"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="enableApprovalRecommendations"/>
      <Arg name="asyncCacheRefresh"/>
      <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
      project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="violationReviewDecision" to="violationReviewDecision"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c785d172f817863f5c1491b2e" name="CF-IdentityRequestInitialize-Workflow"/>
      </WorkflowRef>
      <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Exit On Policy Violation">
        <Script>
          <Source>("cancel".equals(violationReviewDecision) || ((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals("fail"))))</Source>
        </Script>
      </Transition>
      <Transition to="ValidateRole"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="1774" posY="474">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="action" value="open"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketProject"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Arg name="ticketDataGenerationRule"/>
      <Arg name="ticketPlan"/>
      <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <Return name="ticketId" to="externalTicketId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Pre Split Approve" when="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Transition to="Approve and Provision"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" icon="Task" name="Pre Split Approve" posX="1924" posY="474">
      <Arg name="approvalScheme">
        <Script>
          <Source>
          import java.util.List;
          import java.util.ArrayList;
          import java.util.Iterator;
          import sailpoint.tools.Util;

          List schemes = Util.csvToList(approvalScheme);
          List preSchemes = new ArrayList&lt;String>();
          for (String s : Util.safeIterable(schemes)) {
          if (s.equals(approvalSplitPoint)) {
          break;
          } else {
          preSchemes.add(s);
          }
          }
          return Util.listToCsv(preSchemes);
        </Source>
        </Script>
      </Arg>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemComments"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="workItemDescription"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="dontUpdatePlan"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="clearApprovalDecisions"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Description>
      Call to our standard subprocess to handle the default approvals for
      manager, owner and security officer.
    </Description>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c46935f0198" name="Provisioning Approval Subprocess"/>
      </WorkflowRef>
      <Transition to="Split Plan"/>
    </Step>
    <Step action="call:splitProvisioningPlan" icon="Task" name="Split Plan" posX="2106" posY="474" resultVariable="splitPlans">
      <Arg name="project" value="ref:project"/>
      <Description>
      Step to split the provisioning project into individual projects for each item requested.
      This will only run if the approvalSplitPoint is configured.
    </Description>
      <Transition to="Approve and Provision Split"/>
    </Step>
    <Step icon="Task" name="Approve and Provision Split" posX="2216" posY="474">
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="enableRetryRequest"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="endOnManualWorkItems"/>
      <Arg name="userEmailTemplate"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="batchRequestItemId"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="splitProvisioning" value="true"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="clearApprovalDecisions"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="requesterEmailTemplate"/>
      <Arg name="approvalEmailTemplate"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="approvalScheme">
        <Script>
          <Source>
          import java.util.List;
          import java.util.Iterator;
          import sailpoint.tools.Util;
          List schemes = Util.csvToList(approvalScheme);
          Iterator it = schemes.iterator();
          while (it.hasNext()) {
          String s = it.next();
          if (!s.equals(approvalSplitPoint)) {
          it.remove();
          } else {
          break;
          }
          }
          return Util.listToCsv(schemes);
        </Source>
        </Script>
      </Arg>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="endOnProvisioningForms"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Description>
      Call the Approve and Provision Subprocess for each Provisioning Project generated in the Split Plan step.
    </Description>
      <Replicator arg="plan" items="splitPlans"/>
      <Return name="project" to="splitProjects"/>
      <Return name="workItemComments" to="splitWorkItemComments"/>
      <Return name="approvalSet" to="splitApprovalSet"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c758812a9817588ed87a2001d" name="CF-ApproveAndProvisionSubprocess-Workflow"/>
      </WorkflowRef>
      <Transition to="Assimilate Splits"/>
    </Step>
    <Step action="call:joinLCMProvWorkflowSplits" icon="Task" name="Assimilate Splits" posX="2462" posY="474">
      <Arg name="splitProjects" value="ref:splitProjects"/>
      <Arg name="splitApprovalSet" value="ref:splitApprovalSet"/>
      <Arg name="splitWorkItemComments" value="ref:splitWorkItemComments"/>
      <Description>
      Assimilate all projects returned from the split into the global project.
    </Description>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step icon="Task" name="Approve and Provision" posX="1908" posY="590">
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="enableRetryRequest"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="endOnManualWorkItems"/>
      <Arg name="userEmailTemplate"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="batchRequestItemId"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="splitProvisioning" value="false"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="clearApprovalDecisions"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="requesterEmailTemplate"/>
      <Arg name="approvalEmailTemplate"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="endOnProvisioningForms"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Description>
      Finish any remaining approvals and provision.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0cb0035" name="Approve and Provision Subprocess"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="2628" posY="474">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Description>
      Add arguments as necessary to enable refresh features.  Typically you
      only want this to correlate roles.  Don't ask for provisioning  since that
      can result in provisioning policies that need to be presented and it's
      too late for that.  This is only to get role detection and exception
      entitlements in the cube.
    </Description>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Task" name="Notify" posX="2786" posY="474">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b02d0031" name="Identity Request Notify"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Policy Violation" posX="1294" posY="358">
      <Arg name="message" value="Failed due to policy violation(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Manual Work Items" posX="1290" posY="126">
      <Arg name="message" value="Failed due to manual work item(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Provisioning Form" posX="1290" posY="242">
      <Arg name="message" value="Failed due to provisioning form"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Assignment condition" posX="1520" posY="706">
      <Arg name="message" value="Failed due to Assignment condition"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Finalize" posX="28" posY="10">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="autoVerifyIdentityRequest"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Default" name="Check Operation" posX="192" posY="126" resultVariable="operation">
      <Script>
        <Source>
        import java.util.List;

        import sailpoint.object.ProvisioningPlan;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        AttributeRequest attrReqs = new ProvisioningPlan.AttributeRequest();
        import sailpoint.object.ProvisioningPlan.Operation;
        System.out.println("Inside Check operaiton");
        List listOfAttr = new ArrayList();

        List listAccountRequests = plan.getAccountRequests("IIQ");
        System.out.println("list accountrequest "+listAccountRequests);
        String operation = null;
        List listOperation = null;
        Operation op = null;
        //System.out.println("List accountrequest plan *************"+listAccountRequests.toXml());
        for(ProvisioningPlan.AccountRequest acctReq : listAccountRequests)
        {
        listOfAttr = acctReq.getAttributeRequests();
        System.out.println("Inside accountrequest for loop");
        }
        for(ProvisioningPlan.AttributeRequest attrReqs1 : listOfAttr)
        {
        operation = attrReqs1.getOp().getMessageKey();
        System.out.println(operation);
        //op = attrReqs1.getOp().valueOf(operation);
        System.out.println("Inside attrreq for loop");
        }
        return operation;
        System.out.println("******************************"+op);

      </Source>
      </Script>
      <Transition to="Initialize IdentityModel">
        <Script>
          <Source>if(!(operation.equals("provisioning_plan_op_remove")))
          {
          return true;
          }</Source>
        </Script>
      </Transition>
      <Transition to="Initialize">
        <Script>
          <Source>if(operation.equals("provisioning_plan_op_remove"))
          {
          return true;
          }</Source>
        </Script>
      </Transition>
    </Step>
    <Step action="getIdentityModel" icon="Default" monitored="true" name="Initialize IdentityModel" posX="342" posY="126" resultVariable="identityModel">
      <Transition to="Create Identity Model"/>
    </Step>
    <Step icon="Default" monitored="true" name="Create Identity Model" posX="564" posY="126" resultVariable="identityModel">
      <Script>
        <Source>import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        return identityModel;</Source>
      </Script>
      <Transition to="Fetch Selected Role"/>
    </Step>
    <Step icon="Default" monitored="true" name="Fetch Selected Role" posX="762" posY="126" resultVariable="finalRoleList">
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>import java.util.Arrays;
        import java.util.List;
        import java.util.Collections;
        import sailpoint.object.ProvisioningTarget; 
        import sailpoint.object.Bundle;

        import java.util.ArrayList;
        import sailpoint.api.SailPointContext;
        import sailpoint.tools.GeneralException;


        //*****************************************************Fetch Requested Roles from ProvisioningTargets***************************

        String roles = "";
        List provTarget = plan.getProvisioningTargets();

        int count = 0;
        for(ProvisioningTarget provTgt : provTarget)
        {
        roles = provTgt.getRole()+","+roles;
        count++;
        
        }

        String[] myArray = roles.split(",");
        System.out.println("Array of String***"+Arrays.toString(myArray));
        List &lt;String> myList= Arrays.asList(myArray);
        Collections.reverse(myList);

        //*****************************************************End Fetch Requested Roles from ProvisioningTargets***************************


        //*****************************************************Calculate Role is having Disconnected/Connected Application***************************


        List finalRoleList= getRoleSensitivityStatus(myList);
        /* 
        Set&lt;Application> setOfApps = null;
        Bundle roleObject = null;
        List removalList = new ArrayList();

        for(String fetchedroles : finalRoleList)
        {

        try {
        roleObject = context.getObjectByName(Bundle.class,fetchedroles);
        } catch (GeneralException e) {

        e.printStackTrace();
        }

        setOfApps = roleObject.getApplications();
        for(Application applications : setOfApps){
        String appNames = applications.getName();
        if(appNames.equals("Active Directory") || appNames.equals("BizAppAD") || appNames.equals("ISAM LDAP"))
        removalList.add(fetchedroles);

        }
        }
        finalRoleList.removeAll(removalList);*/

        //*****************************************************Calculate Role is having Disconnected/Connected Application***************************


       

        //*****************************************************End of Send Email Notification if request have Multiple-User ***************************

        System.out.println("-----Final Roles-----"+finalRoleList);
        return finalRoleList;</Source>
      </Script>
      <Transition to="Comment Step">
        <Script>
          <Source>
          import sailpoint.object.EmailTemplate;
          import sailpoint.object.EmailOptions;
          boolean ans = finalRoleList.isEmpty();
          if (ans == false){
          EmailTemplate template = context.getObjectByName(EmailTemplate.class,"CF-EmailNotification-MultiUser-RoleSensitivereq");
         
          Identity identity = context.getObjectByName(Identity.class,launcher);
          String identityEmail = identity.getEmail();
          EmailOptions options = new EmailOptions();
          options.setTo(identityEmail);  
          options.setVariable("requesterName", identity.getDisplayName());
          options.setVariable("requestedFor",identityDisplayName);
          context.sendEmailNotification(template, options);
          
          return true;
          }
        </Source>
        </Script>
      </Transition>
      <Transition to="Initialize">
        <Script>
          <Source>boolean ans = finalRoleList.isEmpty();
          if (ans == true){
          
          return true;
          }</Source>
        </Script>
      </Transition>
    </Step>
    <Step icon="Default" monitored="true" name="Comment Step" posX="944" posY="126">
      <Approval name="Comment Step" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel,finalRoleList" send="identityModel,finalRoleList">
        <Arg name="workItemDescription" value="Business Justification for Roles"/>
        <Arg name="workItemType" value="Form"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
        <Arg name="workItemForm" value="CF-Form-Show-DisconnectedApplicationAndRole"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="identityName" value="ref:identityName"/>
        <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      </Approval>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Adding RoleJustification to Comment"/>
    </Step>
    <Step icon="Default" monitored="true" name="Adding RoleJustification to Comment" posX="1070" posY="126" resultVariable="plan">
      <Arg name="RoleComment" value="ref:RoleComment"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="identityModel" value="ref:identityModel"/>
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>

        import sailpoint.object.IdentityRequest;
        import sailpoint.object.Attributes;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.Form;
        import sailpoint.object.Field;
        import sailpoint.util.*;
        import sailpoint.object.ProvisioningTarget;
        import sailpoint.object.AccountSelection;

        List&lt;String> listOfAllComments = new ArrayList&lt;String>();



        listOfAllComments.add(identityModel.get("roleCommentOne"));
        listOfAllComments.add(identityModel.get("roleCommentTwo"));
        listOfAllComments.add(identityModel.get("roleCommentThree"));
        listOfAllComments.add(identityModel.get("roleCommentFour"));
        listOfAllComments.add(identityModel.get("roleCommentFive"));
        listOfAllComments.add(identityModel.get("roleCommentSix"));
        listOfAllComments.add(identityModel.get("roleCommentSeven"));
        listOfAllComments.add(identityModel.get("roleCommentEight"));
        listOfAllComments.add(identityModel.get("roleCommentNine"));
        listOfAllComments.add(identityModel.get("roleCommentTen"));




        int count = 0;

        // ************************************************************* Get account Reuqest and Comment******************************************
        ProvisioningPlan.AttributeRequest attrReqs = new ProvisioningPlan.AttributeRequest();
        List listAccountRequests = plan.getAccountRequests("IIQ");

        List provTarget = plan.getProvisioningTargets();

        int count = 0;

        String roles ="";

        for(ProvisioningPlan.AccountRequest acctReq : listAccountRequests)
        {


        attrReqs = acctReq.getAttributeRequest("assignedRoles");
        String roleValue = attrReqs.getValue();

        if(finalRoleList.contains(roleValue))
        {
        try{
        if(listOfAllComments.get(count) !=null){

        attrReqs.setComments(listOfAllComments.get(count));
        count++;
        }
        }catch(Exception e){}
        }
        else
        {
        continue;
        }


        }


        // ************************************************************* End of Get account Reuqest and Comment******************************************



        return plan;


      </Source>
      </Script>
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Stop" name="end" posX="1620" posY="126"/>
  </Workflow>
  <Workflow configForm="Provisioning Workflow Config Form" created="1603889312028" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c756f1eb681756f40b11b0037" libraries="Identity,BatchRequest" name="LCM Create and Update" taskType="LCM" type="LCMIdentity">
    <Variable input="true" name="identityName">
      <Description>The name of the identity we're supposed to update.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these two values:

      IdentityCreateRequest
      IdentityEditRequest
    </Description>
    </Variable>
    <Variable editable="true" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
    </Variable>
    <Variable editable="true" name="doRefresh">
      <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable initializer="user,requester" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
     The email template to use for user notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
     The email template to use for requester notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
     The email template to use for manager notification.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
     The email template to use for security officer notification.
    </Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
     A string that specifies how we should handle the approvals.

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.

     parallelPoll
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="manager, newManager" input="true" name="approvalScheme">
      <Description>
      A String that specifies how approvals should be generated for
      this workflow there are three built-in modes

      none - disabled approvals

      manager - The user's current manager will get approvals

      newManager - The newly assigned manager will get approvals when
                   manager transfers occur. Otherwise the user's manager
                   current manager will be the approver.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      fail -  fail and exit the workflow if any policy violations are found

      continue -  continue if policy violations are found
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
    </Variable>
    <Variable name="ticketId">
      <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="approvalForm">
      <Description>
       The form that is generated based on the changes that were made.  This
       form will be sent into the workitem and allow editing of the
       requested values during the approval process. This is generated
       in "Build Approval Form" based on the passed-in plan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request.
    </Description>
    </Variable>
    <Variable input="true" name="approverElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the batch approver when performing batch operations.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="14" posY="12">
      <Transition to="Build Approval Set"/>
    </Step>
    <Step action="rule:LCM Build Identity ApprovalSet" icon="Task" name="Build Approval Set" posX="98" posY="12" resultVariable="approvalSet">
      <Description>
       The rule will go through the plan and build an approvalItem for each AccountRequest,
       typically there is just one for the IIQ application requests.

       The rule will also annotate the plan with the previousValues so that they
       can be assimilated onto the Form that is build, which is used during the approval
       process for edits.

       Because this has some special handling keep it here in the workflow
       and pass the approval set into the initialization process.
    </Description>
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="183" posY="12">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="false"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
      <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
      a project and checking policy violations.
    </Description>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afde002f" name="Identity Request Initialize"/>
      </WorkflowRef>
      <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Exit On Policy Violation" when="script:((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))"/>
      <Transition to="Create Ticket"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="403" posY="8">
      <Arg name="action" value="open"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <Return name="ticketId" to="externalTicketId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Approve"/>
    </Step>
    <Step icon="Task" name="Approve" posX="488" posY="8">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="approverElectronicSignature" value="ref:approverElectronicSignature"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemComments"/>
      <Description>
      Call the standard subprocess that will handle the built-in
      owner, manager and security officer approval schemes.
    </Description>
      <Return name="approvalSet"/>
      <Return name="plan"/>
      <Return name="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0760034" name="Identity Request Approve Identity Changes"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Approval"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="599" posY="8">
      <Arg name="action" value="postApproval"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.

    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Process Approval Decisions"/>
    </Step>
    <Step action="call:processPlanApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="764" posY="9" resultVariable="plan">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="disableAudit" value="true"/>
      <Transition to="Notify" when="script:approvalSet.hasRejected()"/>
      <Transition to="Recompile Project"/>
    </Step>
    <Step action="call:recompileProvisioningProject" icon="Task" name="Recompile Project" posX="913" posY="5" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Description>Recompile the provisioning project with the plan.
      The plan may contain modifications from the original plan if
      it was modified during the approval process.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.</Description>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Task" name="Provision" posX="1014" posY="6">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="recompile" value="false"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that will process the
      approval decisions and do provisioning.  This
      includes calling any configured provisioning
      connectors and building manual actions.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Post Provision"/>
    </Step>
    <Step action="script:approvalSet.setAllProvisioned();" icon="Task" name="Post Provision" posX="1110" posY="7">
      <Description>
      Mark all of the items in the approvalset provisioned since these
      are all synchronous activities.
    </Description>
      <Transition to="Update Ticket Post Provision"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="1111" posY="115">
      <Arg name="action" value="postProvisioning"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.

    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="954" posY="114">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Arg name="provision" value="true"/>
      <Arg name="synchronizeAttributes" value="true"/>
      <Description>
      Add arguments as necessary to enable refresh features.  Typically you only want this
      to correlate roles and possibly provision if we notice new assigned roles.
      Note that provisioning will be done in the Identity Refresh workflow so if there
      are any provisioning forms to display we won't feed them directly to the
      current user, they'll have to return to the inbox.
    </Description>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Task" name="Notify" posX="830" posY="114">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="source" value="ref:source"/>
      <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b02d0031" name="Identity Request Notify"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Policy Violation" posX="250" posY="225">
      <Arg name="message" value="Failed due to policy violation(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Manual Work Items" posX="280" posY="141">
      <Arg name="message" value="Failed due to manual work item(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Provisioning Form" posX="361" posY="78">
      <Arg name="message" value="Failed due to provisioning form"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Finalize" posX="759" posY="284">
      <Arg name="project" value="ref:project"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
    </Step>
    <Step icon="Stop" name="end" posX="830" posY="225"/>
  </Workflow>
  <Workflow configForm="Provisioning Workflow Config Form" created="1603889312091" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c756f1eb681756f40b15b0038" libraries="Identity,BatchRequest" name="LCM Registration" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" name="transient">
      <Description>
      Set to false to cause workflow-related objects, such as approval
      work items, to be saved in the database even if they are only
      viewed by the person registering.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.  
    </Description>
    </Variable>
    <Variable initializer="Registration" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.
    </Description>
    </Variable>
    <Variable editable="true" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
    </Variable>
    <Variable editable="true" name="doRefresh">
      <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable initializer="user,manager" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options. 

     none or null
       disable notifications

     user 
       Identity that is registering will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     securityOfficer
       The identity named in the variable securityOfficerName will be notified.
    </Description>
    </Variable>
    <Variable initializer="LCM Registration User Notification" input="true" name="userEmailTemplate">
      <Description>
     The email template to use for user notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Registration Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
     The email template to use for manager notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Registration Security Officer Notification" input="true" name="securityOfficerEmailTemplate">
      <Description>
     The email template to use for security officer notification.
    </Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
     A string that specifies how we should handle the approvals.  

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.
 
     parallelPoll 
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to 
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="securityOfficer" input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approvals should be generated for 
      the incoming request.
 
      The value can be any of the values below, combined together but
      are always processed in this order:
  
      1. manager
      2. securityOfficer

      Any rejected items from previous approvals will be omitted from the  
      next phase of approvers.

      none - disabled approvals

      manager - The manager will get all approvals

      securityOfficer - The identity named in the variable securityOfficerName.
    </Description>
    </Variable>
    <Variable initializer="LCM Registration Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals 
       during security officer approvals.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      fail -  fail and exit the workflow if any policy violations are found

      continue -  continue if policy violations are found
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.      
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="approverElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems 
       are completed by the approver.
    </Description>
    </Variable>
    <Variable name="identityName">
      <Description>The name of the identity we're creating.</Description>
    </Variable>
    <Variable name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      A form that gets displayed for confirming the registration.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      The ProvisioningPlan that gets generated from the form input.
    </Description>
    </Variable>
    <Variable name="identityModel">
      <Description>
      The identity model that is used to represent the identity being created.
    </Description>
    </Variable>
    <Variable name="ticketId">
      <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent 
      calls.  It is also stored on the IdentityRequest object under the 
      externalTicketId variable. 
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description> 
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see 
       pending violations.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="15" posY="12">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Description>
       Initialize the data for the identity that we are creating.
    </Description>
      <Transition to="Registration Form"/>
    </Step>
    <Step icon="Approval" name="Registration Form" posX="131" posY="115">
      <Approval mode="serial" owner="ref:launcher" return="identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="Self-service registration form"/>
        <Arg name="workItemForm" value="registerForm"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
      </Approval>
      <Description>
       Display the registration form to collect information about the registrant.
    </Description>
      <Transition to="Build Confirmation Form"/>
    </Step>
    <Step action="call:buildReadOnlyForm" name="Build Confirmation Form" posX="131" posY="10" resultVariable="confirmationForm">
      <Arg name="form" value="registerForm"/>
      <Arg name="helpText" value="lcm_registration_confirmation_text"/>
      <Arg name="nextButtonLabel" value="label_confirm"/>
      <Description>
       Create the confirmation form to be displayed.
    </Description>
      <Transition to="Confirmation Form"/>
    </Step>
    <Step icon="Approval" name="Confirmation Form" posX="269" posY="10">
      <Approval mode="serial" owner="ref:launcher" return="identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="Confirmation form"/>
        <Arg name="workItemForm" value="ref:confirmationForm"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
      </Approval>
      <Description>
       Display the confirmation form to the registrant.
    </Description>
      <Transition to="Registration Form" when="!approved"/>
      <Transition to="Verify"/>
    </Step>
    <Step icon="Analysis" name="Verify" posX="403" posY="6">
      <Description>
      This is a place-holder step where verification of the information could
      occur before a creation request is launched.  This could potentially call
      out to an external system to verify some unique information (eg - employeeId)
      before continuing on.
    </Description>
      <Transition to="Set identity name"/>
    </Step>
    <Step name="Set identity name" posX="507" posY="6" resultVariable="identityName">
      <Description>
      Set the identityName workflow variable based on the form input.
    </Description>
      <Script>
        <Source>
        String name = (String)identityModel.get("name");
        if (name != null) {
          name = name.trim();
        }

        return name;
      </Source>
      </Script>
      <Transition to="Build Provisioning Plan"/>
    </Step>
    <Step action="call:buildPlanFromIdentityModel" name="Build Provisioning Plan" posX="646" posY="6" resultVariable="plan">
      <Arg name="identityModel" value="ref:identityModel"/>
      <Description>
      Convert the registration request into a provisioning plan.
    </Description>
      <Transition to="Submit Registration Request"/>
    </Step>
    <Step icon="Task" name="Submit Registration Request" posX="646" posY="110">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="doRefresh" value="ref:doRefresh"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="approverElectronicSignature" value="ref:approverElectronicSignature"/>
      <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the LCM Create and Update workflow with the plan that was created.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b11b0037" name="LCM Create and Update"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="646" posY="217"/>
  </Workflow>
  <Workflow configForm="LCM Manage Passwords Config Form" created="1603889312140" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c756f1eb681756f40b18c0039" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" name="LCM Manage Passwords" taskType="LCM" type="LCMProvisioning">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the flow that launched this workflow.

      This is one of these three values:

      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="user" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
    </Variable>
    <Variable initializer="LCM Password Change Notification" input="true" name="userEmailTemplate">
      <Description>
     The email template to use for user notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Password Change Notification" input="true" name="requesterEmailTemplate">
      <Description>
     The email template to use for requester notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Password Change Notification" input="true" name="managerEmailTemplate">
      <Description>
     The email template to use for manager notification.
    </Description>
    </Variable>
    <Variable name="ticketId">
      <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="isProvisioningFailed" output="true">
      <Description>
      This variable will keep track of provisioning errors reported
      in the Identity Request Items within the Identity Request object,
      so that we can prevent from notifying the user about provisioning
      actions status on failure.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="12">
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="118" posY="11">
      <Arg name="flow" value="ref:flow"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="false"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="policyScheme" value="none"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
      <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
      a project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afde002f" name="Identity Request Initialize"/>
      </WorkflowRef>
      <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Create Ticket"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="279" posY="8">
      <Arg name="action" value="openNoApproval"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <Return name="ticketId" to="externalTicketId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Task" name="Provision" posX="369" posY="8">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="fallbackApprover" value="spadmin"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that will process the
      approval decisions and do provisioning.  This
      includes calling any configured provisioning
      connectors and building manual actions.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Post Provision"/>
    </Step>
    <Step icon="Task" name="Post Provision" posX="472" posY="8" resultVariable="isProvisioningFailed">
      <Script>
        <Source>
        import sailpoint.api.ObjectUtil;
        import sailpoint.tools.Util;
        import sailpoint.object.WorkflowCase;
        import sailpoint.object.TaskResult;
        import sailpoint.object.IdentityRequest;
        import sailpoint.object.IdentityRequestItem;
        import sailpoint.object.ProvisioningProject;

        if ( null != identityRequestId ) {
            IdentityRequest ir = wfcontext.getSailPointContext().getObject(IdentityRequest.class, identityRequestId);
            if ( null != ir ) {
                List requestItems = ir.getItems();
                if ( Util.size(requestItems) > 0 ) {
                    for ( IdentityRequestItem item : requestItems ) {
                        if ( item.isProvisioningFailed() ) {
                            isProvisioningFailed = true;
                            return isProvisioningFailed;
                        }
                    }
                }
            }
        }

        if ( approvalSet != null ) {
            // Set state to provisioned and also mark them all approved
            approvalSet.setAllProvisioned();

            List items = approvalSet.getItems();
            if ( Util.size(items) > 0 ) {
                for ( ApprovalItem item : items ) {
                    item.approve();
                }
            }
            if ( Util.otob(trace) ) {
                System.out.println("ApprovalSet:\n" + approvalSet.toXml());
            }
        }

        // mark this verified to prevent the scanner from processing it
        TaskResult result = wfcontext.getTaskResult();
        if ( result != null ) {
            result.setVerified(new Date());
        }
        if ( project != null ) {
            if ( Util.otob(trace) ) {
                // clone and scrub the project so passwords are not visible
                ProvisioningProject clonedProject = project.deepCopy(wfcontext.getSailPointContext());
                ObjectUtil.scrubPasswords(clonedProject);
                System.out.println("Project Executed in lcm:\n" + clonedProject.toXml());
            }
        }
      </Source>
      </Script>
      <Transition to="end" when="ref:isProvisioningFailed"/>
      <Transition to="Update Ticket Post Provision"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="604" posY="8">
      <Arg name="action" value="postProvisioning"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.

    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Task" name="Notify" posX="719" posY="8">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b02d0031" name="Identity Request Notify"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Manual Work Items" posX="185" posY="164">
      <Arg name="message" value="Failed due to manual work item(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Provisioning Form" posX="231" posY="81">
      <Arg name="message" value="Failed due to provisioning form"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Finalize" posX="666" posY="222">
      <Arg name="project" value="ref:project"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="autoVerifyIdentityRequest" value="true"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
    </Step>
    <Step icon="Stop" name="end" posX="720" posY="163"/>
  </Workflow>
  <Workflow created="1603889312170" explicitTransitions="true" id="0a111e5c756f1eb681756f40b1aa003a" libraries="Identity" name="Lifecycle Event - Joiner" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Description>Process a new employee.</Description>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Process user"/>
    </Step>
    <Step icon="Message" name="Process user" posX="148" posY="10">
      <Description>Process the user that joined.</Description>
      <Script>
        <Source>
      System.out.println("New user was entered the system: " + event.getObject().getDisplayableName());
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1603889312200" explicitTransitions="true" id="0a111e5c756f1eb681756f40b1c8003b" libraries="Identity" name="Lifecycle Event - Leaver" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in 
       the name field of the identity request.
    </Description>
    </Variable>
    <Variable name="cart" output="true">
      <Description>
       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Description>Disable all accounts when an employee leaves the company.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step action="call:buildEventPlan" icon="Start" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="op" value="Disable"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="170" posY="10">
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="none"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="flow" value="Lifecycle"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
       project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="cart"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="policyViolations" to="policyViolations"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afde002f" name="Identity Request Initialize"/>
      </WorkflowRef>
      <Transition to="Provision"/>
    </Step>
    <Step condition="script:!((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Provision" posX="290" posY="10">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyScheme" value="none"/>
      <Arg name="noTriggers" value="true"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that will process the 
      approval decisions and do provisioning.  This
      includes calling any configured provisioning 
      connectors and building manual actions.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Finalize"/>
    </Step>
    <Step catches="complete" condition="script:!((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Finalize" posX="410" posY="10">
      <Arg name="approvalSet" value="ref:cart"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="540" posY="10"/>
  </Workflow>
  <Workflow created="1603889312240" explicitTransitions="true" id="0a111e5c756f1eb681756f40b1f0003c" libraries="Identity" name="Lifecycle Event - Reinstate" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The id of the object that encapsulates the request information
       and status as it goes through the request life cycle. The workflow will create
       and update this object ( through special steps ) as the workflow 
       progresses.
    </Description>
    </Variable>
    <Variable name="cart" output="true">
      <Description>
       This attribute is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved.

       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Description>Enable all accounts when an employee is reinstated.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step action="call:buildEventPlan" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="op" value="Enable"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="170" posY="10">
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="policyScheme" value="none"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="flow" value="Lifecycle"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
       project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="cart"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="policyViolations" to="policyViolations"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afde002f" name="Identity Request Initialize"/>
      </WorkflowRef>
      <Transition to="Provision"/>
    </Step>
    <Step condition="script:!((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Provision" posX="290" posY="10">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyScheme" value="none"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that will process the 
      approval decisions and do provisioning.  This
      includes calling any configured provisioning
      connectors and building manual actions.
    </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Finalize"/>
    </Step>
    <Step catches="complete" condition="script:!((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Finalize" posX="410" posY="10">
      <Arg name="approvalSet" value="ref:cart"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="530" posY="10"/>
  </Workflow>
  <Workflow created="1603889312263" explicitTransitions="true" id="0a111e5c756f1eb681756f40b207003d" libraries="Identity" name="Lifecycle Event - Manager Transfer" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Description>Process a user when they change managers.</Description>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Process user"/>
    </Step>
    <Step icon="Message" name="Process user" posX="148" posY="10">
      <Description>Process the user that transferred managers.</Description>
      <Script>
        <Source>
      
       import sailpoint.object.*;

       String identityFullname = event.getIdentityFullName();
       Identity oldManager = (null != event.getOldObject()) ? event.getOldObject().getManager() : null;
       Identity newManager = (null != event.getObject()) ? event.getObject().getManager() : null;

       String oldManagerName = (null != oldManager) ? oldManager.getDisplayableName() : null;
       String newManagerName = (null != newManager) ? newManager.getDisplayableName() : null;

       System.out.println(identityFullname + " changed managers from " + oldManagerName + " to " + newManagerName);
      
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1603889312272" explicitTransitions="true" id="0a111e5c756f1eb681756f40b210003e" libraries="Identity" name="Lifecycle Event - Email manager for all native changes" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in 
       the name field of the identity request.
    </Description>
    </Variable>
    <Variable name="cart" output="true">
      <Description>
       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Description>
    Send a email to the manager when we notice there are native entitlement
    changes.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step name="start" posX="28" posY="10">
      <Script>
        <Source>
        import sailpoint.tools.Util;
        import sailpoint.object.WorkflowCase;
        import sailpoint.object.TaskResult;

       // System.out.println("Event was fired for identity ["+identityName+"]");
       // System.out.println("                    trigger ["+trigger.toXml()+"]");
       // System.out.println("                    event ["+event.toXml()+"]");
      </Source>
      </Script>
      <Transition to="Notify Manager"/>
    </Step>
    <Step action="call:sendEmail" icon="Email" name="Notify Manager" posX="148" posY="10">
      <Arg name="template" value="Native Account Change Manager Notification"/>
      <Arg name="to" value="script:getManagersEmail(identityName)"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="276" posY="10"/>
  </Workflow>
  <Workflow created="1603889312323" explicitTransitions="true" id="0a111e5c756f1eb681756f40b243003f" libraries="Identity" name="Lifecycle Event - Manager Approval for all native changes" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable initializer="NativeChange" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is the value "NativeChange" and is used to display special approval
      text when rendering the work item generated for the native change. Do not
      change this value.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable initializer="script:( Util.otob(getConfiguration(&quot;lcmEnableApprovalRecommendations&quot;)))" input="true" name="enableApprovalRecommendations">
      <Description>
            Flag to determine if recommendations should be gathered for the approvals.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in 
       the name field of the identity request.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       The variable used to hold the approval set generated from the
       native changes on the event.
    </Description>
    </Variable>
    <Variable initializer="true" name="provisionRejectedItems">
      <Description>
        Flag to indicate if actual provisioning to reverse te native
        change should take place OR if it should just print a plan to 
        stdout. Set this variable to true, if you want it to provision
        the rejected items, otherwise it'll just be printed to stdout. 
     </Description>
    </Variable>
    <Variable name="launcher">
      <Description>The name of the identity that launched the workflow. In cases where workflows are launched by the system an alternate launcher name may be passed as as a variable.</Description>
    </Variable>
    <Variable initializer="Modify" name="operations">
      <Description>CSV list of operations that are part of the native change request, default to Modify but this will be recalculated in the "Build OP String" step.</Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Description>
  An example workflow that requires manager approval
  for all natively detected changes found by IdentityIQ.
  
  Any items rejected by the manager will be reversed and 
  provisioned.    
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="start" posX="23" posY="129">
      <Script>
        <Source>
        import sailpoint.tools.Util;
        if ( Util.otob(trace) ) { 
            System.out.println("Event was fired for identity ["+identityName+"]");
            System.out.println("                    trigger ["+trigger.toXml()+"]");
            System.out.println("                    event ["+event.toXml()+"]");
        }
      </Source>
      </Script>
      <Transition to="Build Op String"/>
      <Transition to="end" when="script:(Util.size(event.getNativeChanges())==0)"/>
    </Step>
    <Step name="Build Op String" posX="81" posY="20" resultVariable="operations">
      <Script>
        <Source>
        import sailpoint.object.NativeChangeDetection;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.tools.Util;
        
        List ops = new ArrayList();
        if ( event != null ) {
            List ncs = event.getNativeChanges();
            if ( ncs != null ) {
                for ( NativeChangeDetection nc : ncs ) {
                    AccountRequest.Operation op = nc.getOperation();
                    if ( op == null ) 
                        opString = "Modify";
                    else
                        opString = op.toString();

                    if ( !ops.contains(opString) ) {
                        ops.add(opString);
                    }
                }
            }
        }
        return Util.listToCsv(ops);
      </Source>
      </Script>
      <Transition to="Build Native Change Approval"/>
    </Step>
    <Step action="call:buildApprovalSetFromNativeChanges" name="Build Native Change Approval" posX="205" posY="20" resultVariable="approvalSet">
      <Arg name="event" value="ref:event"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Build Native Change Recommendations"/>
    </Step>
    <Step action="call:populateRecommendationsInApprovalSet" condition="ref:enableApprovalRecommendations" name="Build Native Change Recommendations" posX="373" posY="20" resultVariable="approvalSet">
      <Arg name="identitySource" value="ref:event"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Approve Native Change"/>
    </Step>
    <Step name="Approve Native Change" posX="533" posY="20">
      <Approval mode="parallel" owner="script:getManagerName(identityName, launcher, fallbackApprover);" renderer="nativeChangeApprovalRenderer.xhtml" send="identityDisplayName,identityName">
        <AfterScript>
          <Source>
          import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);
        </Source>
        </AfterScript>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Arg name="launcher" value="ref:launcher"/>
        <Arg name="approvalSet" value="ref:approvalSet"/>
        <Arg name="operations" value="$(operations)"/>
        <Arg name="workItemDescription" value="Native Account Changes for User: $(identityDisplayName) - Manager Approval"/>
        <Arg name="workItemNotificationTemplate" value="ref:ownerEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="flow" value="ref:flow"/>
      </Approval>
      <Transition to="Process Approval Decisions"/>
    </Step>
    <Step action="call:processNativeChangesApprovalDecisions" name="Process Approval Decisions" posX="715" posY="20" resultVariable="plan">
      <Transition to="Provision Native Change Reversal"/>
    </Step>
    <Step condition="script:( Util.otob(provisionRejectedItems) &amp;&amp; plan != null )" icon="Task" name="Provision Native Change Reversal" posX="881" posY="20">
      <Arg name="flow" value="EntitlementsRequest"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="none"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="approvalScheme" value="none"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="requireViolationReviewComments" value="false"/>
      <Arg name="allowRequestsWithViolations" value="true"/>
      <Arg name="enableRetryRequest" value="false"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="doRefresh" value="true"/>
      <Arg name="trace" value="ref:trace"/>
      <Return name="project" to="project"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0e10036" name="LCM Provisioning"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Complete" posX="658" posY="185">
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request if they are in play. 
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="881" posY="125"/>
  </Workflow>
  <Workflow created="1603889312738" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c756f1eb681756f40b3e2004d" libraries="Identity,BatchRequest,IdentityRequest" name="Batch Request Wrapper" taskType="LCM" type="BatchProvisioning">
    <Variable initializer="parallelPoll" input="true" name="approvalMode">
      <Description>
     A string that specifies how we should handle the approvals.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.
 
     parallelPoll 
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to 
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="batchRequest" input="true" name="approvalScheme">
      <Description>
      For batch requests you should use the batchRequest scheme.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="batchRequestApprover">
      <Description>The name of the batch request approver.</Description>
    </Variable>
    <Variable name="requireBatchRequestApproval">
      <Description>
       True or false. specifies whether or not we need to worry about the approval step.
    </Description>
    </Variable>
    <Variable input="true" name="batchApproverElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems 
       are completed by the batch approver when performing batch operations.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="25" posY="131">
      <Transition to="Approve" when="script:requireBatchRequestApproval"/>
      <Transition to="Launch Batch Workflows"/>
    </Step>
    <Step icon="Task" name="Approve" posX="83" posY="12">
      <Arg name="workItemComments"/>
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="batchRequestId" value="ref:batchRequestId"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="batchRequestApprover" value="ref:batchRequestApprover"/>
      <Arg name="batchApproverElectronicSignature" value="ref:batchApproverElectronicSignature"/>
      <Arg name="batchApproverEmailTemplate" value="Batch Approval"/>
      <Description>
      Call the standard subprocess that will handle the built-in
      owner, manager and security officer approval schemes.
    </Description>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b00f0030" name="Identity Request Approve"/>
      </WorkflowRef>
      <Transition to="Batch Request Rejected" when="script:approvalSet.hasRejected()"/>
      <Transition to="Launch Batch Workflows"/>
    </Step>
    <Step action="call:launchBatchWorkflows" icon="Task" name="Launch Batch Workflows" posX="285" posY="127">
      <Arg name="batchRequestId" value="ref:batchRequestId"/>
      <Arg name="background" value="ref:requireBatchRequestApproval"/>
      <Description>
      Call library method to launch all the workflows
    </Description>
      <Transition to="end"/>
    </Step>
    <Step action="call:requestRejected" icon="Task" name="Batch Request Rejected" posX="339" posY="8">
      <Arg name="batchRequestId" value="ref:batchRequestId"/>
      <Description>
      Update request with rejected status and result
    </Description>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="444" posY="127"/>
  </Workflow>
  <Workflow created="1604318362317" explicitTransitions="true" id="0a111e5c758812a9817588d37aca0000" libraries="Identity" modified="1616666050415" name="CF-PowerShell-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable name="provisioningCheckStatusInterval">
      <Description>
      provisioningCheckStatusInterval 
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable input="true" name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="WaitingforprovisionSync"/>
    </Step>
    <Step name="WaitingforprovisionSync" wait="1">
      <Transition to="ProvisionSkypeAccess"/>
    </Step>
    <Step name="ProvisionSkypeAccess" posX="28" posY="10">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Application;


        import sailpoint.object.Rule;
        import sailpoint.object.RpcRequest;
        import sailpoint.object.RpcResponse;
        import sailpoint.connector.RPCService;

        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.ProvisioningProject;

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.ProvisionSkypeAccess.step");
        
        log.info("**** Starting new log ****");
       
        
        log.info("Inside Powershell Workflow ProvisionSkypeAccess Step project "+project);
        log.info("Inside Powershell Workflow ProvisionSkypeAccess Step identityName "+identityName);
        log.info("ExchangeRemoteMailbox Step");
        try{
        log.info("ExchangeRemoteMailbox Step project is "+project);
        if(project != null){
        ProvisioningPlan adPlan = project.getPlan("Active Directory");
        if(null != adPlan){
        AccountRequest accountRequest = adPlan.getAccountRequest("Active Directory");
        log.info("ExchangeRemoteMailbox Step accountRequest is "+accountRequest.toXml());
        Map data = new HashMap();
        Rule ruleObj = context.getObjectByName(Rule.class,"CF-ProvisionSkypeAccess-Rule");
        Application appProdObj = context.getObjectByName(Application.class, "Active Directory");
        if(ruleObj != null &amp;&amp; appProdObj != null &amp;&amp; accountRequest != null){
        log.info("ExchangeRemoteMailbox Step Inside If App,Rule,AccReq not null is ");
        data.put("postScript",ruleObj);

        data.put("Application", appProdObj.getAttributes());
        data.put("Request", accountRequest);

        String IQServiceServer = "sv-spidsvc-t3.carefirsttest.com";
        
        int IQServicePort = 5050;
        RPCService service = new RPCService(IQServiceServer,IQServicePort);
        service.setConnectorServices(new sailpoint.connector.DefaultConnectorServices());
        RpcRequest request = new RpcRequest("ScriptExecutor","runAfterScript",data);
        log.info("ProvisionSkypeAccess Step Before Executing Powershell Rule data :::  "+data);
        log.info("ProvisionSkypeAccess Step Before Executing Powershell Rule request :::  "+request.toXml());
        RpcResponse response = service.execute(request);
        log.info("ExchangeRemoteMailbox Step After Executing Powershell Rule ");
        }else{
        log.info("Rule,Application is not found in IIQ in ProvisionSkypeAccess Step ");
        }


        }
        else{
        log.info("Plan is null in ProvisionSkypeAccess Step ");
        }
        }else{
        log.info("Project  is null in ProvisionSkypeAccess Step");
        }
        }
        catch(Exception e){
        }

      </Source>
      </Script>
      <Transition to="EnableRemoteMailBox"/>
    </Step>
    <Step name="EnableRemoteMailBox" posX="28" posY="10">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Application;


        import sailpoint.object.Rule;
        import sailpoint.object.RpcRequest;
        import sailpoint.object.RpcResponse;
        import sailpoint.connector.RPCService;

        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.ProvisioningProject;

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.ExchangeRemoteMailbox.step");
        
        log.info("**** Starting new log ****");
        System.out.println("**************************************************************************8");
        
        System.out.println("Inside Powershell Workflow ExchangeRemoteMailbox Step project "+project);
        System.out.println("Inside Powershell Workflow ExchangeRemoteMailbox Step identityName "+identityName);
        System.out.println("ExchangeRemoteMailbox Step");
        try{
        System.out.println("ExchangeRemoteMailbox Step project is "+project);
        if(project != null){
        ProvisioningPlan adPlan = project.getPlan("Active Directory");
        if(null != adPlan){
        AccountRequest accountRequest = adPlan.getAccountRequest("Active Directory");
        AttributeRequest attributeRequestforEmail=accountRequest.getAttributeRequest("mail");
        String duplicateUser=attributeRequestforEmail.getValue();
        String duplicateUserFlag = "false";
        String[] splitMailValues =duplicateUser.split("@");
  
 String mailDisplayName= splitMailValues[0];
   int count = 0;    
  
       for(int i = 0; i @lt mailDisplayName.length(); i++) {   
  
  char ch=mailDisplayName.charAt(i);
String chartoStringValue=String.valueOf(ch);
         
  if(chartoStringValue.equals(".")) { 
count =count+1;
}
         } 
  if(count @gt 1){
        duplicateUserFlag = "true";
        
        }
  
        System.out.println("ExchangeRemoteMailbox Step accountRequest is "+accountRequest.toXml());
        Map data = new HashMap();
        String exchangeRuleToBeRun = "";
        
        if(duplicateUserFlag == "true"){
        exchangeRuleToBeRun = "CF-ExchangeSetRemoteAttrsWithoutDefaultPolicy-Rule";
        }
        else
        {
        exchangeRuleToBeRun = "CF-ExchangeSetRemoteAttrs-Rule";
        }
        
        Rule ruleObj = context.getObjectByName(Rule.class,exchangeRuleToBeRun);
        Application appProdObj = context.getObjectByName(Application.class, "Active Directory");
        if(ruleObj != null &amp;&amp; appProdObj != null &amp;&amp; accountRequest != null){
        System.out.println("ExchangeRemoteMailbox Step Inside If App,Rule,AccReq not null is ");
        data.put("postScript",ruleObj);

        data.put("Application", appProdObj.getAttributes());
        data.put("Request", accountRequest);
        data.put("duplicateUserFlag", duplicateUserFlag);
        

        String IQServiceServer = "sv-spidsvc-t3.carefirsttest.com";
        //String IQServiceServer = "SV-SPIDSVC-D3.carefirsttest.com";
        int IQServicePort = 5050;
        RPCService service = new RPCService(IQServiceServer,IQServicePort);
        service.setConnectorServices(new sailpoint.connector.DefaultConnectorServices());
        RpcRequest request = new RpcRequest("ScriptExecutor","runAfterScript",data);
        System.out.println("ExchangeRemoteMailbox Step Before Executing Powershell Rule data :::  "+data);
        System.out.println("ExchangeRemoteMailbox Step Before Executing Powershell Rule request :::  "+request.toXml());
        RpcResponse response = service.execute(request);
        System.out.println("ExchangeRemoteMailbox Step After Executing Powershell Rule ");
        }else{
        System.out.println("Rule,Application is not found in IIQ in ExchangeRemoteMailbox Step ");
        }


        }
        else{
        System.out.println("Plan is null in ExchangeRemoteMailbox Step ");
        }
        }else{
        System.out.println("Project  is null in ExchangeRemoteMailbox Step");
        }
        }
        catch(Exception e){
        }

      </Source>
      </Script>
      <Transition to="WaitingforSync"/>
    </Step>
    <Step name="WaitingforSync" wait="30">
      <Transition to="EnableOffice365"/>
    </Step>
    <Step name="EnableOffice365" posX="390" posY="474">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Application;


        import sailpoint.object.Rule;
        import sailpoint.object.RpcRequest;
        import sailpoint.object.RpcResponse;
        import sailpoint.connector.RPCService;

        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.ProvisioningProject;

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.EnableOffice365.step");
        log.info("***** Inside workflow: CF-Powershell-Workflow, entering step:EnableOffice365 *****");

        System.out.println("Inside ExchangeRemoteMailbox Step");
        try{
        System.out.println("ExchangeRemoteMailbox Step project is "+project);
        if(project != null){
        ProvisioningPlan adPlan = project.getPlan("Active Directory");
        if(null != adPlan){
        AccountRequest accountRequest = adPlan.getAccountRequest("Active Directory");
        System.out.println("ExchangeRemoteMailbox Step accountRequest is "+accountRequest);
        Map data = new HashMap();
        Rule ruleObj = context.getObjectByName(Rule.class,"CF-Office365-Enable-Rule");
        Application appProdObj = context.getObjectByName(Application.class, "Active Directory");
        
        log.info("Before entering if block, ruleObj = "+ruleObj.toXml());
        log.info("Before entering if block, appProdObj = "+appProdObj.toXml());
        log.info("Before entering if block, accountRequest = "+accountRequest.toXml());
        
        if(ruleObj != null &amp;&amp; appProdObj != null &amp;&amp; accountRequest != null){
        System.out.println("ExchangeRemoteMailbox Step Inside If App,Rule,AccReq not null is ");
        data.put("postScript",ruleObj);

        data.put("Application", appProdObj.getAttributes());
        data.put("Request", accountRequest);

        // String IQServiceServer = "sv-spidsvc-d1.carefirst.com";
        String IQServiceServer = "sv-spidsvc-t3.carefirsttest.com";
        int IQServicePort = 5050;
        RPCService service = new RPCService(IQServiceServer,IQServicePort);
        service.setConnectorServices(new sailpoint.connector.DefaultConnectorServices());
        RpcRequest request = new RpcRequest("ScriptExecutor","runAfterScript",data);
        System.out.println("ExchangeRemoteMailbox Step Before Executing Powershell Rule data :::  "+data);
        
        log.info("Inside if block, request = "+request.toXml());
        
        System.out.println("ExchangeRemoteMailbox Step Before Executing Powershell Rule request :::  "+request.toXml());
        RpcResponse response = service.execute(request);
        
        log.info("Inside if block, after executing second powershell rule");
        
        System.out.println("ExchangeRemoteMailbox Step After Executing Powershell Rule ");
        
        log.info("***** Inside workflow: CF-Powershell-Workflow, exiting if block in step:EnableOffice365 *****");
        
        }else{
        log.info("***** Inside workflow: CF-Powershell-Workflow, exiting else block in step:EnableOffice365, application not found *****");
        System.out.println("Rule,Application is not found in IIQ in ExchangeRemoteMailbox Step ");
        }


        }
        else{
        log.info("***** Inside workflow: CF-Powershell-Workflow, exiting second else block in step:EnableOffice365, plan is null *****");
        System.out.println("Plan is null in ExchangeRemoteMailbox Step ");
        }
        }else{
        log.info("***** Inside workflow: CF-Powershell-Workflow, exiting third else block in step:EnableOffice365, project is null *****");
        System.out.println("Project  is null in ExchangeRemoteMailbox Step");
        }
        }
        catch(Exception e){
        log.info("***** Error: "+e);
        log.info("***** Error getMessage: "+e.getMessage());
        log.info("***** Error printStackTrace: "+e.printStackTrace());
        log.info("***** Inside workflow: CF-Powershell-Workflow, exiting catch in step:EnableOffice365 because of Exception *****");
        }

      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1604318362323" explicitTransitions="true" id="0a111e5c758812a9817588d37ad30001" libraries="Identity" modified="1618212854856" name="CF-Joiner-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable initializer="joiner" input="true" name="callingWorkflow">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent. It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable name="plan">
      <Description>Plan.</Description>
    </Variable>
    <Variable name="errorMsg">
      <Description>Caputing the error message.</Description>
    </Variable>
    <Description>Process a new employee.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Transition to="Stop">
        <Script>
          <Source>
          import sailpoint.object.Identity;
          
          Identity identityObj = getIdentityObj(identityName);
         
          String action = identityObj.getAttribute(ATR_ACTION);
          if(action != null){
          if(!((action.equals(ATR_HIRE)) @or (action.equals(ATR_REH))@or (action.equals(STR_ACTION_ADD))) ){
          return true;
          }
          }
        </Source>
        </Script>
      </Transition>
      <Transition to="Assign Joiner Role"/>
    </Step>
    <Step name="Assign Joiner Role" resultVariable="plan">
      <Script>
        <Source>

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.joinerWorkflow");

        log.info("####### Start of Assign Joiner Role step #####");
        log.info("####### SOURCE #####"+source);
       

        plan = buildjoinerPlan(identityName);
        //requestDisconnectApplication1("ADUSApp", identityName);
        if(plan != null){
        log.info("####### Plan in Assign Joiner Role step #####"+plan.toXml());
        }
        log.info("####### End of Assign Joiner Role step #####");
        return plan;
      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Provisioning Status"/>
    </Step>
    <Step name="Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Script>
        <Source>
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;
        import sailpoint.tools.GeneralException;

        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow.Check Provisioning Status");

        List errorsList=new ArrayList();
        try{
        
        System.out.println("Inside Workflow:CF-Joiner-Workflow, inside step: Provisioning Status, entering try block project"+project.toXml());
        
        errorsList=getErrors(context,project);

        System.out.println("Inside Workflow:CF-Joiner-Workflow, inside step: Provisioning Status, inside try block, errorsList = "+errorsList);
        
        if(errorsList !=void @and !errorsList.isEmpty() @and errorsList !=null @and  errorsList.size()>0){
        Map errorsMap = new HashMap();

        errorsMap.put(identityName,Util.listToCsv(errorsList));
        workflow.put("failedMap",errorsMap);
        log.info("failed map is " +failedMap);
        return false;
        }
       else{
        return true;
        }
        }
        catch(Exception ex){
        
        throw new GeneralException("Inside Workflow:CF-Joiner-Workflow, inside step: Provisioning Status, inside catch block, errorsList = "+errorsList);
        
        System.out.println("Inside Workflow:CF-Joiner-Workflow, inside step: Provisioning Status, inside catch block, ex = "+ex);
       // return ex;
        }


      </Source>
      </Script>
      <Transition to="fepocUserADAccountandRefresh" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step name="CreateHomeDrive" resultVariable="powershellworkflowFlag">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Application;


        import sailpoint.object.Rule;
        import sailpoint.object.RpcRequest;
        import sailpoint.object.RpcResponse;
        import sailpoint.connector.RPCService;

        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.ProvisioningProject;

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.HomeDriveCreation.step");
        System.out.println("HomeDriveCreation Step");
        try{
        System.out.println("HomeDriveCreation Step project is "+project);
        if(project != null){
        ProvisioningPlan adPlan = project.getPlan("Active Directory");
        if(null != adPlan){
        AccountRequest accountRequest = adPlan.getAccountRequest("Active Directory");
        System.out.println("HomeDriveCreation Step accountRequest is "+accountRequest);
        Map data = new HashMap();
        Rule ruleObj = context.getObjectByName(Rule.class,"CF-HomedriveUpdatedCreation-Rule");
        Application appProdObj = context.getObjectByName(Application.class, "Active Directory");
        if(ruleObj != null &amp;&amp; appProdObj != null &amp;&amp; accountRequest != null){
        System.out.println("HomeDriveCreation Step Inside If App,Rule,AccReq not null is ");
        data.put("postScript",ruleObj);

        data.put("Application", appProdObj.getAttributes());
        data.put("Request", accountRequest);

        String IQServiceServer = "sv-spidsvc-t3.carefirsttest.com";
        // String IQServiceServer = "SV-SPIDSVC-D3.carefirsttest.com";
        int IQServicePort = 5050;
        RPCService service = new RPCService(IQServiceServer,IQServicePort);
        service.setConnectorServices(new sailpoint.connector.DefaultConnectorServices());
        RpcRequest request = new RpcRequest("ScriptExecutor","runAfterScript",data);
          System.out.println("HomeDriveCreation Step Before Executing Powershell Rule data :::  "+data);
        System.out.println("HomeDriveCreation Step Before Executing Powershell Rule request :::  "+request.toXml());
        RpcResponse response = service.execute(request);
        System.out.println("HomeDriveCreation Step After Executing Powershell Rule ");
        }else{
        System.out.println("Rule,Application is not found in IIQ in CreateHomeDrive Step ");
        }


        }
        else{
        System.out.println("Plan is null in CreateHomeDrive Step ");
        }
        }else{
        System.out.println("Project  is null in CreateHomeDrive Step");
        }
        }
        catch(Exception e){
        }
      
      </Source>
      </Script>
      <Transition to="LaunchPowershellWorkflow">
        <Script>
          <Source>
          import sailpoint.object.Identity;
            System.out.println("identityName...."+identityName);
        Identity identityObj = getIdentityObj(identityName);
           System.out.println("identityName....************************************************************************"+identityObj.getAttribute("company"));
if(identityObj.getAttribute("company").toString().equals("SBP")){
      return false;  
        }else{
        return true; 
        }
           </Source>
        </Script>
      </Transition>
      <Transition to="Stop"/>
    </Step>
    <Step name="Provision Skype Attributes">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.api.Provisioner;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.EnableAccountRule");
        Identity identityObj = getIdentityObj(identityName);
       // log.info("Joiner:: Identity object found: "+identityObj);
        
        plan = provisionionSkypeAttributes(identityObj);
        System.out.println("Provision Skype Attributes.."+plan.toXml());
        Provisioner  prov = new Provisioner(context);
        prov.compile(plan);
        prov.execute();

      </Source>
      </Script>
      <Transition to="LaunchPowershellWorkflow"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="callingWorkflow" value="ref:callingWorkflow"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;
       // import sailpoint.api.TaskManager;

       
        Identity identityObj = getIdentityObj(identityName);
     //   TaskManager tm = new TaskManager(context);

    //    HashMap h= new HashMap();
     //   String s="name ==\""+identityObj.getAttribute("employeeid").toString()+"\"";
    //    h.put("filter",s);
     //   int i=0;

      //  while(i @lt 2){

    //    TaskResult result = tm.runSync("CF-ProvisionAssignments-RefreshIdentityCube-TaskDefinition",h);
    //    i++;
    //    }

        Attributes attributes = new Attributes();
      

        String userType = identityObj.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null &amp;&amp; userType.equalsIgnoreCase(STR_EMPLOYEE)){

        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);
        }else{
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        }
         System.out.println("inside sendProv Success email step before sendning ");
        sendEmailNotification(identityName,STR_PROVISIONING_SUCCESS_EMAIL_TEMPLATE_JOINER,"");
        createAuditEvent(STR_AUDIT_JOINER_SUCESS_NOTIFICATION,null,null,STR_AUDIT_JOINER_SUCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
       System.out.println("inside sendProv Success email step  mail send and audit created  ");
        if(callingWorkflow.equals("joiner")){

        //  createAuditEvent(STR_AUDIT_JOINER_SUCESS_NOTIFICATION,null,null,STR_AUDIT_JOINER_SUCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        }
        else {

        createAuditEvent(STR_AUDIT_JOINER_SUCESS_NOTIFICATION,null,null,STR_AUDIT_JOINER_SUCESS_NOTIFICATION,null,identityName,null,null,attributes,"Triggered from Mover",null,null,null);
        }
      </Source>
      </Script>
      <Transition to="PreHire Disable">
        <Script>
          <Source>
          import sailpoint.object.Identity;
          import java.util.Calendar;
          import java.util.Date;

          Identity identityObj = getIdentityObj(identityName);
          SimpleDateFormat sdf = new SimpleDateFormat("dd-MMM-yy");

          String effDate=identityObj.getAttribute("effdt");
          Date currentDate = new Date();
          String currentDateString= sdf.format(currentDate);
          Date actualCurrentDate=  sdf.parse(currentDateString);

          Date actualeffdate=  sdf.parse(effDate);
          String action = identityObj.getAttribute(ATR_ACTION);
          if(action != null){
          if(((action.equals(ATR_HIRE)) @or (action.equals(ATR_REH))@or (action.equals(STR_ACTION_ADD))) @and actualCurrentDate.compareTo(actualeffdate) @lt 0){
          return true;
          }
          }
        </Source>
        </Script>
      </Transition>
      <Transition to="CreateHomeDrive"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Arg name="callingWorkflow" value="ref:callingWorkflow"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;

        Attributes attributes = new Attributes();
        Identity identityObj = getIdentityObj(identityName);

        String userType = identityObj.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null &amp;&amp; userType.equalsIgnoreCase(STR_EMPLOYEE)){
        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);

        }else{
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        }
        sendEmailNotificationForFailure(identityName,failedMap,STR_PROVISIONING_FAILURE_EMAIL_TEMPLATE);
        createAuditEvent(STR_AUDIT_JOINER_FAILURE_NOTIFICATION,null,null,STR_AUDIT_JOINER_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        if(callingWorkflow.equals("joiner")){
        //   createAuditEvent(STR_AUDIT_JOINER_FAILURE_NOTIFICATION,null,null,STR_AUDIT_JOINER_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        }
        else {

        createAuditEvent(STR_AUDIT_JOINER_FAILURE_NOTIFICATION,null,null,STR_AUDIT_JOINER_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,"Triggered from Mover",null,null,null);
        }

      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step name="PreHire Disable">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.api.Provisioner;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.EnableAccountRule");
        Identity identityObj = getIdentityObj(identityName);
        log.info("Joiner:: Identity object found: "+identityObj);
        plan = buildAccountDisablePlan(identityObj);
        Provisioner  prov = new Provisioner(context);
        prov.compile(plan);
      prov.execute();

      </Source>
      </Script>
      <Transition to="CreateHomeDrive"/>
    </Step>
    <Step name="fepocUserADAccountandRefresh">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.api.Provisioner;
        import org.apache.log4j.Logger;
        import sailpoint.api.TaskManager;
        import sailpoint.object.ProvisioningPlan;

        Logger log = Logger.getLogger("com.carefirst.EnableAccountRule");
        Identity identityObj = getIdentityObj(identityName);
       if(identityObj.getAttribute("company").toString().equals("SBP")){
      
        log.info("Joiner:: Identity object found: "+identityObj);
        System.out.println("Joiner:: Identity object found: "+identityObj);
        ProvisioningPlan plan=new ProvisioningPlan();
        plan = buildAccountDisablePlanForAD(identityObj);
         System.out.println("plan...."+plan);
        Provisioner  prov = new Provisioner(context);
        prov.compile(plan);
        prov.execute();
        }
        
         

       
        
       TaskManager tm = new TaskManager(context);

      HashMap h= new HashMap();
     String s="name ==\""+identityObj.getAttribute("employeeid").toString()+"\"";
      h.put("filter",s);
       int i=0;

        while(i @lt 2){

        TaskResult result = tm.runSync("CF-ProvisionAssignments-RefreshIdentityCube-TaskDefinition",h);
       i++;
       }
System.out.println("..................end");
      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail"/>
    </Step>
    <Step name="LaunchPowershellWorkflow">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="project" value="ref:project"/>
      <Description>
      Calling the Powershell workflow to run the powershell scripts
	  the accounts.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c758812a9817588d37aca0000" name="CF-PowerShell-Workflow"/>
      </WorkflowRef>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1604318774738" explicitTransitions="true" id="0a111e5c758812a9817588d9c5d00004" libraries="Identity" modified="1616869503757" name="CF-Leaver-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="message">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="Yes" input="true" name="isSameConversion">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="manager">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="provisioningCheckStatusInterval">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable name="errorMsg">
      <Description>To capture the error message from project </Description>
    </Variable>
    <Variable initializer="CF-LeaverProvisioningSuccess-EmailTemplate" input="true" name="approvalEmailTemplate">
      <Description>
      The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
      The sequence id of the Identity request object which is stored in 
      the name field of the identity request.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
      The String version of a WorkItem.Priority. This variable is 
      used to set the priority on all of the workitems generated 
      as part of this workflow and also set on the IdentityRequest
      object.
    </Description>
    </Variable>
    <Description>Disable all accounts when an employee leaves the company.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590efe226f9" name="CF-LaunchPowerShellRuleLeaverOperation-Rule"/>
    </RuleLibraries>
    <Step action="call:getIdentityModel" icon="Start" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        System.out.println("**** Entering Workflow:CF-Leaver-Workflow ****");
        System.out.println("Inside Workflow:CF-Leaver-Workflow, inside step: Initilize, for user = "+identityName);
        
        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        System.out.println("identityModel"+identityModel);
        return identityModel;

        System.out.println("****** In Levaer Start Step  isSameConversion::: "+isSameConversion);
      </Source>
      </Script>
      <Transition to="Build Provisioning Plan"/>
    </Step>
    <Step icon="Start" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="op" value="Disable"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>
        
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        import sailpoint.api.Provisioner;
        import sailpoint.object.*;
        import java.util.*;

        System.out.println("Inside Workflow:CF-Leaver-Workflow, inside step: Build Provisioning Plan");
        
        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow");
        System.out.println("Inside Leaver Workflow identityName "+identityName);
        Identity identity =getIdentityObj(identityName);
        Identity managerObj;
        String manager_name = null;
        String manager_userid = null;
        if (identity.getManager() != null){
        managerObj = identity.getManager();
        if (managerObj.getName() != null){
        manager_name = managerObj.getName();
        }
        if (managerObj.getAttribute("userid") != null){
        manager_userid = managerObj.getAttribute("userid");
        }
        }			
        System.out.println("manager_name-------"+manager_name+manager_userid);
        workflow.put("manager", manager_name);

        if(identity != null){

        plan = buildAccountDisablePlan(identity);
        // identity.setAttribute(ATR_EMPLOYEESTATUS,STR_TERMINATE);
        // ProvisioningPlan chnageOUplan =changeOU(identity,"OU=Termed Users,OU=Users,OU=Corporate,DC=carefirsttest,DC=com");
        // Provisioner  prov = new Provisioner(context);
        //  prov.compile(chnageOUplan);
        // prov.execute();
        //  plan =changeOU(identity,"OU=Termed Users,OU=Users,OU=Corporate,DC=carefirsttest,DC=com");


        log.info("Inside Leaver Workflow plan after calling the method "+plan.toXml());
        }
        return plan;

      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Check Provisioning Status"/>
    </Step>
    <Step icon="Default" name="Check Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Script>
        <Source> 
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;

        System.out.println("Inside Workflow:CF-Leaver-Workflow, inside step: Check Provisioning Status");
        
        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow.Check Provisioning Status");

           log.info("Inside leaver wf - ENTERING step - Check Provisioning Status");
        
        List errors=new ArrayList();
        try{
        
        log.info("Inside leaver wf - inside step - Check Provisioning Status, errors = "+errors);
        errors=getErrors(context,project);

        if(errors !=null @and errors.size()>0){
        Map failedM = new HashMap();
        if(failedM==null)
        failedM=new HashMap();

        failedM.put(identityName,Util.listToCsv(errors));
        log.info("Inside leaver wf - inside step - Check Provisioning Status, failedM = "+failedM);
        workflow.put("failedMap",failedM);
        
        log.info("Inside leaver wf - inside step - Check Provisioning Status, exiting try block");
        return false;
        }
        log.info("Inside leaver wf - inside step - Check Provisioning Status, exiting if block");
        return true;
        }
        catch(Exception ex){
        log.info("Inside leaver wf - inside step - Check Provisioning Status, inside catch block, exception = "+ex);
        return ex;
        }
        System.out.println("****** In Check Provisioinig status isSameConversion::: "+isSameConversion);
        
        log.info("Inside leaver wf - EXITING step - Check Provisioning Status");

      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step name="Workgroup" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;
        // import java.util.*;

        Identity identity =getIdentityObj(identityName);



        //identity.setAttribute(ATR_EMPLOYEESTATUS,STR_TERMINATE);
        Identity managerID= identity.getManager();
        // ArrayList a=new ArrayList();
        // a=identity.getWorkgroups();
        if(!(identity.getWorkgroups().isEmpty())){
        for(Identity wg:identity.getWorkgroups()){




        identity.remove(wg);

        managerID.add(wg);
        sendEmailNotification(identityName,"CF-WorkgroupManager-EmailTemplate");
        context.saveObject(wg);

        context.commitTransaction();
        }


        }
        context.saveObject(identity);
        context.commitTransaction();







      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;

        System.out.println("Inside Workflow:CF-Leaver-Workflow, inside step: SendProvisioningSuccessEmail");
        //requestDisconnectApplication("Disconnected Application1",identityName);
        
        Identity i= getIdentityObj(identityName);
        Attributes attributes = new Attributes();
        String constant="ATR_APPLICATION";
        int j=1;
        String keyValue="";

        List listofApplications=new ArrayList();
        listofApplications= i.getLinks();
        for(Link l:listofApplications){

        keyValue=constant+j;
        attributes.put(keyValue,l.getApplicationName().toString());
        j++;

        }

        sendEmailNotification(identityName,"CF-LeaverProvisioningSuccess-EmailTemplate","");
        createAuditEvent(STR_ADUIT_LEAVER_SUCCESS_NOTIFICATION,null,null,STR_ADUIT_LEAVER_SUCCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
      </Source>
      </Script>
      <Transition to="HomedriveReassign"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="template" value="CF-ProvisioningFailure-EmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;
        
System.out.println("failedMap.........................."+failedMap);
        Identity i= getIdentityObj(identityName);
        Attributes attributes = new Attributes();
        String constant="ATR_APPLICATION";
        int j=1;
        String keyValue="";

        List listofApplications=new ArrayList();
        listofApplications= i.getLinks();
        for(Link l:listofApplications){

        keyValue=constant+j;
        attributes.put(keyValue,l.getApplicationName().toString());
        j++;
System.out.println("failedMap.........................."+j);
        }
System.out.println("failedMap.........................."+failedMap);
     //  requestDisconnectApplication("Disconnected Application1",identityName);
        
        sendEmailNotification(identityName,failedMap,"CF-ProvisioningFailure-EmailTemplate");
        createAuditEvent(STR_ADUIT_LEAVER_FAILURE_NOTIFICATION,null,null,STR_ADUIT_LEAVER_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10">
      <Script>
        <Source>
         System.out.println("**** Exiting Workflow:CF-Leaver-Workflow ****");
        
        System.out.println("identityMode------------------------l"+identityModel);
      </Source>
      </Script>
    </Step>
    <Step icon="Default" name="HomedriveReassign" posX="50" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Application;


        import sailpoint.object.Rule;
        import sailpoint.object.RpcRequest;
        import sailpoint.object.RpcResponse;
        import sailpoint.connector.RPCService;

        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.ProvisioningProject;

        import org.apache.log4j.Logger;

        System.out.println("Inside Workflow:CF-Leaver-Workflow, inside step: HomedriveReassign");

        String mgrUserId = "";
        String userid = "";
        Identity identity= getIdentityObj(identityName);
        if(identity != null){
        userid=  identity.getAttribute("userid") != null ? identity.getAttribute("userid") : "";
        Identity manager=identity.getManager();
        if(manager == null){
        mgrUserId = "";
        }else{
        mgrUserId =  manager.getAttribute("userid") != null ? manager.getAttribute("userid") : "";

        }
        try{
      
        AccountRequest accountRequest = new AccountRequest();
        accountRequest.setApplication("Active Directory");
        accountRequest.setNativeIdentity(identityName);
        accountRequest.setOperation(ProvisioningPlan.AccountRequest.Operation.Modify);
        accountRequest.add(new AttributeRequest("identityName",ProvisioningPlan.Operation.Set,userid));
        accountRequest.add(new AttributeRequest("manageruserid",ProvisioningPlan.Operation.Set,mgrUserId));
        System.out.println("HomeDriveReassign Step accountRequest is "+accountRequest);
        Map data = new HashMap();
        Rule ruleObj = context.getObjectByName(Rule.class,"CF-HomeDirectoryReassign-Rule");
        Application appProdObj = context.getObjectByName(Application.class, "Active Directory");
        if(ruleObj != null &amp;&amp; appProdObj != null &amp;&amp; accountRequest != null){
        System.out.println("HomeDriveReassign Step Inside If App,Rule,AccReq not null is ");
        data.put("postScript",ruleObj);

        data.put("Application", appProdObj.getAttributes());
        data.put("Request", accountRequest);

        String IQServiceServer = "sv-spidsvc-t3.carefirsttest.com";
        // String IQServiceServer = "SV-SPIDSVC-D3.carefirsttest.com";
        int IQServicePort = 5050;
        RPCService service = new RPCService(IQServiceServer,IQServicePort);
        service.setConnectorServices(new sailpoint.connector.DefaultConnectorServices());
        RpcRequest request = new RpcRequest("ScriptExecutor","runAfterScript",data);
        System.out.println("HomeDriveCreation Step Before Executing Powershell Rule data :::  "+data);
        // System.out.println("HomeDriveReassign Step Before Executing Powershell Rule request :::  "+request.toXml());
        RpcResponse response = service.execute(request);
        System.out.println("HomeDriveCreation Step After Executing Powershell Rule ");
        }else{
        System.out.println("Rule,Application is not found in IIQ in HomeDriveReassign Step ");
        }

        }
        catch(Exception e){
        }

        }

      </Source>
      </Script>
      <Transition to="mailBoxReassign"/>
    </Step>
    <Step icon="Default" name="mailBoxReassign" posX="50" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Application;


        import sailpoint.object.Rule;
        import sailpoint.object.RpcRequest;
        import sailpoint.object.RpcResponse;
        import sailpoint.connector.RPCService;

        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.ProvisioningProject;

        import org.apache.log4j.Logger;

        System.out.println("Inside Workflow:CF-Leaver-Workflow, inside step: mailBoxReassign");

        String mgrUserId = "";
        String userid = "";
        Identity identity= getIdentityObj(identityName);
        if(identity != null){
        userid=  identity.getAttribute("userid") != null ? identity.getAttribute("userid") : "";
         Identity manager=identity.getManager();
        if(manager == null){
        mgrUserId = "";
        }else{
        mgrUserId =  manager.getAttribute("userid") != null ? manager.getAttribute("userid") : "";

        }
        try{
      
        AccountRequest accountRequest = new AccountRequest();
        accountRequest.setApplication("Active Directory");
        accountRequest.setNativeIdentity(identityName);
        accountRequest.setOperation(ProvisioningPlan.AccountRequest.Operation.Modify);
        accountRequest.add(new AttributeRequest("identityName",ProvisioningPlan.Operation.Set,userid));
        accountRequest.add(new AttributeRequest("manageruserid",ProvisioningPlan.Operation.Set,mgrUserId));
        System.out.println("HomeDriveReassign Step accountRequest is "+accountRequest);
        Map data = new HashMap();
        Rule ruleObj = context.getObjectByName(Rule.class,"CF-MailboxReassign-Rule");
        Application appProdObj = context.getObjectByName(Application.class, "Active Directory");
        if(ruleObj != null &amp;&amp; appProdObj != null &amp;&amp; accountRequest != null){
        System.out.println("HomeDriveReassign Step Inside If App,Rule,AccReq not null is ");
        data.put("postScript",ruleObj);

        data.put("Application", appProdObj.getAttributes());
        data.put("Request", accountRequest);

        String IQServiceServer = "sv-spidsvc-t3.carefirsttest.com";
        // String IQServiceServer = "SV-SPIDSVC-D3.carefirsttest.com";
        int IQServicePort = 5050;
        RPCService service = new RPCService(IQServiceServer,IQServicePort);
        service.setConnectorServices(new sailpoint.connector.DefaultConnectorServices());
        RpcRequest request = new RpcRequest("ScriptExecutor","runAfterScript",data);
        System.out.println("HomeDriveCreation Step Before Executing Powershell Rule data :::  "+data);
        // System.out.println("HomeDriveReassign Step Before Executing Powershell Rule request :::  "+request.toXml());
        RpcResponse response = service.execute(request);
        System.out.println("HomeDriveCreation Step After Executing Powershell Rule ");
        }else{
        System.out.println("Rule,Application is not found in IIQ in HomeDriveReassign Step ");
        }


        }
        catch(Exception e){
        }

        }

      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
  </Workflow>
  <Workflow created="1604318997877" explicitTransitions="true" id="0a111e5c758812a9817588dd2d750007" libraries="Identity" modified="1617219054938" name="CF-Mover-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable name="plan" type="sailpoint.object.ProvisioningPlan"/>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent. It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="trace">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="Yes" input="true" name="isSameConversion">
      <Description>The name of the identity.</Description>
    </Variable>
    <Description>Process a new employee.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590e45726cf" name="CF-CIAM-CommonWebServiceRuleLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Check Employee Type"/>
    </Step>
    <Step icon="Start" name="Check Employee Type" posX="50" posY="10" resultVariable="isDirectDomain">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Checking the Employee type .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;


        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
        log.info("Inside Mover Workflow identityName "+identityName);
        Identity identity = getIdentityObj(identityName);
        Identity oldIdentity = event.getOldObject();
        log.info("Inside Mover Workflow oldIdentity "+oldIdentity);

        log.info("****** Inside CF-Mover-Workflow: Inside 'Start' step, Identity: "+identityName);

        boolean isDirectConversion = false;
        if(oldIdentity != null @and identity !=null @and oldIdentity.getAttribute(ATR_EMPLOYEETYPE) !=null @and identity.getAttribute(ATR_EMPLOYEETYPE) !=null ){

String newIdenComapny = identity.getAttribute(ATR_COMPANY);
  String  preIdenComapny = oldIdentity.getAttribute(ATR_COMPANY);

        if(oldIdentity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE)@and identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_CONTRACTOR) @and newIdenComapny.equalsIgnoreCase(preIdenComapny) @and !newIdenComapny.equalsIgnoreCase("SBP")){   
        isDirectConversion = true;
        return true;
        }
        else if(oldIdentity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_CONTRACTOR)@and
        identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE) @and  newIdenComapny.equalsIgnoreCase(preIdenComapny) @and !newIdenComapny.equalsIgnoreCase("SBP")) {  
        isDirectConversion = true;
        return true;
        }

        }

        log.info("****** Inside CF-Mover-Workflow: Inside 'Start' step, isDirectConversion: "+isDirectConversion);
        log.info("****** Inside CF-Mover-Workflow: isDirectDomain: "+isDirectDomain);

      </Source>
      </Script>
      <Transition to="Remove Conversion Employee Type Role" when="script:(isDirectDomain)"/>
      <Transition to="Check FEPOC AD Username"/>
    </Step>
    <Step name="Check FEPOC AD Username" resultVariable="isUserHasFepocUsername">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Check FEPOC AD Username.</Description>
      <Script>
        <Source>
        import sailpoint.tools.Util;
					import org.apache.log4j.Logger;
        import sailpoint.object.Identity;
		
		Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
		
        Identity identity = getIdentityObj(identityName);
        String companyCode = identity.getAttribute(ATR_COMPANY);
        if(Util.isNotNullOrEmpty(companyCode)&amp;&amp; "SBP".equalsIgnoreCase(companyCode))  { 
     String status = getUseridFromFEPOC(identityName);
    log.info("Inside Customization rule  status "+status);
   if(Util.isNotNullOrEmpty(status)&amp;&amp; status.startsWith("sAMAccountName")){
     String userID=status.substring(status.indexOf(":")+2);
          log.info("Check FEPOC AD Username if ****"+userID);
         System.out.println("Check FEPOC AD Username if ****"+userID);
     //identity.setAttribute(ATR_USERID,userID);
	 return true; 
   }else {
        return false;
        }
        }else {
        return true;
        }
        
        </Source>
      </Script>
      <Transition to="Remove Roles" when="script:(isUserHasFepocUsername)"/>
      <Transition to="Stop"/>
    </Step>
    <Step name="Remove Roles">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Script>
        <Source>
     import java.util.List;

import sailpoint.api.Provisioner;
import sailpoint.api.SailPointContext;
import sailpoint.object.Bundle;
import sailpoint.object.Identity;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.tools.GeneralException;
  import org.apache.log4j.Logger;


        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
        
        log.info("****** Start  of Remove Roles Step: "+identityName);
        
    ProvisioningPlan p = new ProvisioningPlan();
        Identity identity = getIdentityObj(identityName);
        log.info("****** Start  of Remove Roles Step identity : "+identity);
		  p.setIdentity(identity);
		  AccountRequest adAccountReq = new AccountRequest();
		   adAccountReq.setApplication("IIQ");
		      adAccountReq.setNativeIdentity(identity.getName());
		  adAccountReq.setOperation(AccountRequest.Operation.Modify);
		  //return existingRA;
		  
		     List assignedRoles = identity.getAssignedRoles();
		    List  detectedRoles = identity.getDetectedRoles();
		  //return bundles;

		 // AttributeRequest attributeRequest = new AttributeRequest();

		  //attributeRequest.setName(ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES);
		 

		  //attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);
		  for(Bundle bundle:assignedRoles){
		    AttributeRequest attributeRequest = new AttributeRequest();

		        attributeRequest.setName(ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES);

		        attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);

		        attributeRequest.setValue(bundle.getName());
		      adAccountReq.add(attributeRequest);
		  }

		  for(Bundle bundle:detectedRoles){
			    AttributeRequest attributeRequest = new AttributeRequest();

			        attributeRequest.setName(ProvisioningPlan.ATT_IIQ_DETECTED_ROLES);

			        attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);

			        attributeRequest.setValue(bundle.getName());
			      adAccountReq.add(attributeRequest);
			  }
		   p.add(adAccountReq);
		  Provisioner  prov = new Provisioner(context);
		  prov.compile(p);
		  prov.execute();
		  context.commitTransaction();
		  context.saveObject(identity);
         log.info("****** END of Remove Roles Step: "+identityName);
			</Source>
      </Script>
      <Transition to="Launch Leaver Workflow"/>
    </Step>
    <Step name="Launch Leaver Workflow">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="isSameConversion" value="No"/>
      <Description>
      Calling the leaver workflow to disable the accounts.
    </Description>
      <Script>
        <Source>
       
  import sailpoint.object.Application;
  import sailpoint.object.Identity;
  import sailpoint.object.Link;
  import sailpoint.object.ProvisioningPlan;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest;
  import sailpoint.object.Link;
  import sailpoint.object.Link;
  import sailpoint.api.Provisioner;
  import sailpoint.api.*;
  import sailpoint.tools.Util;
  import java.text.DateFormat;  
  import java.util.List;
  import sailpoint.api.ObjectUtil;
  import sailpoint.api.SailPointContext;
  import sailpoint.object.*;
  import sailpoint.object.Identity;
   import org.apache.log4j.Logger;

   Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
  
    log.info("****** Start  of Launch Leaver Workflow: "+identityName);    
	Identity identity =getIdentityObj(identityName);
  
  if(identity !=null ){
	ProvisioningPlan plan = buildAccountDeletePlan(identity);
    Provisioner  prov = new Provisioner(context);
    prov.compile(plan);
    prov.execute();
        context.saveObject(identity);
        context.commitTransaction();
    //return prov.getProject();
    //return plan;
    String userName = "";
    String email = "";
  if(identity.getAttribute("userid") != null){
              userName = identity.getAttribute("userid");
            }
  if(identity.getAttribute("email") != null){
              email = identity.getAttribute("email");
            }
        try{
        log.info("Start Terminateio User ****"+userName);
         terminatePerson(userName, email);
        log.info("End Terminateio User ****"+userName);
        }catch(Exception e){
        e.printStackTrace();
        }
        
         log.info("****** END  of Launch Leaver Workflow: "+userName); 
        Application isamLdapappObj  = context.getObjectByName(Application.class, "ISAM LDAP");
    
    
    Link isamLdaplinkObj = identity.getLink(isamLdapappObj);
    log.info("****** ISAM LDAP LINK  : "+isamLdaplinkObj);


    if(isamLdaplinkObj != null){
      
     log.info("ISAM LDAp Native Identity :::"+isamLdaplinkObj.getNativeIdentity());
        identity.remove(isamLdaplinkObj);
         context.saveObject(identity);
        context.commitTransaction();
        Link afterRemovalLink = identity.getLink(isamLdapappObj);
        log.info("ISAM LDAp Native Identity :::"+afterRemovalLink);
        
        }
        }
         
         
        
         
      </Source>
      </Script>
      <Transition to="generate UserID"/>
    </Step>
    <Step name="generate UserID" posX="50" posY="10" resultVariable="identityName">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        import sailpoint.tools.Util;

        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
        log.info("Inside Mover Workflow identityName "+identityName);
        Identity identity = getIdentityObj(identityName);
        String strUserID = "";
        if(identity != null){
        String empType = identity.getAttribute(ATR_EMPLOYEETYPE) != null ? identity.getAttribute(ATR_EMPLOYEETYPE) : "";
       String companyCode = identity.getAttribute(ATR_COMPANY);
        System.out.println("companyCode:::"+identityName);
        System.out.println("companyCode:::"+companyCode);
        if(Util.isNotNullOrEmpty(companyCode)&amp;&amp; "SBP".equalsIgnoreCase(companyCode))  { 
        String status = getUseridFromFEPOC(identityName);
        String upn = getMailFromFEPOC(identityName);
    log.info("Inside Customization rule  status "+status);
   if(Util.isNotNullOrEmpty(status)&amp;&amp; status.startsWith("sAMAccountName")){
        System.out.println("user id ::: "+status.startsWith("sAMAccountName"));
      strUserID=status.substring(status.indexOf(":")+2);
        System.out.println("Final UserId ::: "+strUserID);
        identity.setAttribute(ATR_USERID,strUserID);
        context.saveObject(identity);
        context.commitTransaction();
        if(Util.isNotNullOrEmpty(upn)&amp;&amp; upn.startsWith("mail")){
     log.info("Inside if UPN  ****" + upn);
     log.info("Inside Customization rule Status is Sucess before returning null ");
     String upnValue =upn.substring(upn.indexOf(":")+2);
     identity.setAttribute(ATR_EMAIL,upnValue);
        context.saveObject(identity);
        context.commitTransaction();
      }
        
     }
        }
        else{

        //strUserID = sendRequest(STR_USERID_REQUESTXML,STR_USERID_ENDPOINT,"");
        strUserID = generateNextUserID();
        //strUserID = "aad10959";

        log.info("strUserID from SOAP"+strUserID);
        log.info("******New strUserID:::::::"+strUserID);

        identity.setAttribute(ATR_USERID,strUserID);
        String moverEmail = generateEmailinMoverScenario(identity);
          
        identity.setAttribute(ATR_EMAIL,moverEmail);
        context.saveObject(identity);

        }
        context.commitTransaction();
        }
        return identity.getName();

      </Source>
      </Script>
      <Transition to="Cross Domain Conversion Webservice"/>
    </Step>
    <Step icon="Start" name="Cross Domain Conversion Webservice" posX="50" posY="10" resultVariable="isSameEmpTypeCrossDomain">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Checking the Employee type .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;


        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
        log.info("Inside Step Cross Domain Conversion Webservice "+identityName);
        Identity identity = getIdentityObj(identityName);
        Identity oldIdentity = event.getOldObject();
        log.info("Cross Domain Conversion Webservice "+oldIdentity);

        log.info("****** Cross Domain Conversion Webservice identity Name: "+identityName);

        boolean isSameEmpTypeCrossDomain = false;
        if(oldIdentity != null @and identity !=null @and oldIdentity.getAttribute(ATR_EMPLOYEETYPE) !=null @and identity.getAttribute(ATR_EMPLOYEETYPE) !=null ){
        if(oldIdentity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE)@and identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE) ){  // CF Associate/Contractor to FEPOC Associate/Contractor or FEPOC Associate/Contractor to CF Associate/Contractor
        isSameEmpTypeCrossDomain = true;
        return true;
        }
        else if(oldIdentity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_CONTRACTOR)@and identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_CONTRACTOR) ){  // CareFirst/FEPCO Associate to CareFirst/FEPCO Contractor and 
        isSameEmpTypeCrossDomain = true;
        return true;
        }
        else  {  
        isSameEmpTypeCrossDomain = false;
        return false;
        }

        }

        log.info("****** Inside CF-Mover-Workflow: Inside 'Start' step, isSameEmpTypeCrossDomain: "+isSameEmpTypeCrossDomain);
        log.info("****** Inside CF-Mover-Workflow: isSameEmpTypeCrossDomain: "+isSameEmpTypeCrossDomain);

      </Source>
      </Script>
      <Transition to="Same EmployeeType Cross Domian Conversion" when="script:(isSameEmpTypeCrossDomain)"/>
      <Transition to="Different EmployeeType Cross Domian Conversion"/>
    </Step>
    <Step name="Same EmployeeType Cross Domian Conversion" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Description>Convert Associate To Contractor .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        import java.util.HashMap;
        try{
		Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
		
        Identity identity = getIdentityObj(identityName);
        HashMap userDetailsMap = generateUserDetaislMap(identityName);
        log.info("In Cross Domain Conversio smae employeetype ::"+identityName);
        Identity oldIdentity = event.getOldObject();
        
        String oldUserid = "";
        if(null != oldIdentity){
        if(oldIdentity.getAttribute("userid") != null){
              oldUserid = oldIdentity.getAttribute("userid");
            }
        }
        log.info("Same EmployeeType Cross Domian Conversion old user name is ::"+oldUserid);
        
        userDetailsMap.put("extended1",oldUserid);
       
        boolean isRehire = true;
        if(identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE)){
        updateAssociate(userDetailsMap, isRehire);
        }else{
        updateContractor(userDetailsMap, isRehire);
        }
        
        }catch(Exception e){
        e.printStackTrace();
        }
        
       </Source>
      </Script>
      <Transition to="Launch joiner Workflow"/>
    </Step>
    <Step name="Different EmployeeType Cross Domian Conversion" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Description>Convert Associate To Contractor .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
import org.apache.log4j.Logger;
import java.util.HashMap;
try {
    Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
    Identity identity = getIdentityObj(identityName);
    HashMap userDetailsMap = generateUserDetaislMap(identityName);
    Attributes auditAttributes = new Attributes();
    Identity oldIdentity = event.getOldObject();
    String oldUserid = "";
    if (null != oldIdentity) {
        if (oldIdentity.getAttribute("userid") != null) {
            oldUserid = oldIdentity.getAttribute("userid");
        }
    }
    log.info("Same EmployeeType Cross Domian Conversion old user name is ::" + oldUserid);
    //if(oldIdentity.getAttribute("company").equalsIgnoreCase("SBP") &amp;&amp; identity.getAttribute("company").equalsIgnoreCase("SBP")){
    userDetailsMap.put("extended1", oldUserid);
    //}

    log.info("In Convert Associate To Contractor ::" + identityName);
    if (identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE)) {
        HashMap conConAssoResultMap = convertContractorToAssociateInput(userDetailsMap);
        int faultCode = conConAssoResultMap.get("faultCode");
        String faultReason = conConAssoResultMap.get("faultReason");
        System.out.println("faultCode:::" + faultCode);
        System.out.println("faultCode:::" + faultReason);
        if (faultCode == 9000) {
            System.out.println("convertContractorToAssociateInput SuccessIn if");
        } else {
            System.out.println("ELSE convertContractorToAssociateInput Failed:::");
            conConAssoResultMap.put("User ID", userDetailsMap.get("user_id"));
            conConAssoResultMap.put("Employee ID", userDetailsMap.get("emp_id"));
            conConAssoResultMap.put("UAAS Web Service name", "convertContractorToAssociate");
            sendCiamFailureNotication(conConAssoResultMap);
            source = "createAssociate";
            auditAttributes.put("User ID", userDetailsMap.get("user_id"));
            auditAttributes.put("OLD User ID", userDetailsMap.get("extended1"));
            auditAttributes.put("Employee ID", userDetailsMap.get("emp_id"));
            auditAttributes.put("UAAS Web Service name", "convertContractorToAssociate");
            createCiamAuditEvent(source, identityName, null, STR_AUDIT_CF_SP_CIAMSYNCFAILURE, null, identityName, null, null, auditAttributes, null, null, null, null);
        }
    } else {
        HashMap conAssoConResultMap = convertAssociateToContractor(userDetailsMap);
        int faultCode = conAssoConResultMap.get("faultCode");
        String faultReason = conAssoConResultMap.get("faultReason");
        System.out.println("faultCode:::" + faultCode);
        System.out.println("faultCode:::" + faultReason);
        if (faultCode == 9000) {
            System.out.println("convertContractorToAssociateInput SuccessIn if");
        } else {
            System.out.println("ELSE convertContractorToAssociateInput Failed:::");
            conAssoConResultMap.put("User ID", userDetailsMap.get("user_id"));
            conAssoConResultMap.put("Employee ID", userDetailsMap.get("emp_id"));
            conAssoConResultMap.put("UAAS Web Service name", "convertContractorToAssociate");
            sendCiamFailureNotication(conAssoConResultMap);
            source = "createAssociate";
            auditAttributes.put("User ID", userDetailsMap.get("user_id"));
            auditAttributes.put("OLD User ID", userDetailsMap.get("extended1"));
            auditAttributes.put("Employee ID", userDetailsMap.get("emp_id"));
            auditAttributes.put("UAAS Web Service name", "convertContractorToAssociate");
            createCiamAuditEvent(source, identityName, null, STR_AUDIT_CF_SP_CIAMSYNCFAILURE, null, identityName, null, null, auditAttributes, null, null, null, null);
        }
    }
} catch (Exception e) {
    e.printStackTrace();
}
       </Source>
      </Script>
      <Transition to="Launch joiner Workflow"/>
    </Step>
    <Step name="Launch joiner Workflow">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Description>
      Calling the leaver workflow to disable the accounts.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c758812a9817588d37ad30001" name="CF-Joiner-Workflow"/>
      </WorkflowRef>
      <Transition to="Provisioning Status"/>
    </Step>
    <Step icon="Start" name="Remove Conversion Employee Type Role" posX="50" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>
       import sailpoint.object.QueryInfo;
  	import java.util.List;

import sailpoint.api.Provisioner;
import sailpoint.api.SailPointContext;
import sailpoint.object.Bundle;
import sailpoint.object.Identity;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.tools.GeneralException;
  import org.apache.log4j.Logger;


        Logger log = Logger.getLogger("com.carefirst.moverWorkflow::");
       // String identityName = "390425";
        log.info("****** Start  of Remove Roles Step: "+identityName);
        ProvisioningPlan p = new ProvisioningPlan();
        Identity identity = context.getObjectByName(Identity.class, identityName);
        log.info("****** Start  of Remove Roles Step identity : "+identity);
		  	p.setIdentity(identity);
		  	AccountRequest adAccountReq = new AccountRequest();
		   	adAccountReq.setApplication("IIQ");
		    adAccountReq.setNativeIdentity(identity.getName());
		  	adAccountReq.setOperation(AccountRequest.Operation.Modify);
		    AttributeRequest attributeRequest = new AttributeRequest();
		    attributeRequest.setName(ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES);
		    attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);
        if(null != identity.getAttribute(ATR_EMPLOYEETYPE) &amp;&amp; identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_EMPLOYEE)){
        	attributeRequest.setValue("Contractor Biz Role");
        }else{
        	attributeRequest.setValue("Associate Biz Role");
        }
		    adAccountReq.add(attributeRequest);
		   p.add(adAccountReq);
		  Provisioner  prov = new Provisioner(context);
		  prov.compile(p);
		  prov.execute();
		  context.commitTransaction();
		  context.saveObject(identity);

      </Source>
      </Script>
      <Transition to="Build Mover Plan"/>
    </Step>
    <Step icon="Start" name="Build Mover Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;

        //System.out.println("****** Inside CF-Mover-Workflow: Inside 'Build Mover Plan' step");

        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
         log.info("****** Inside Mover Workflow identityName "+identityName);
        log.info("Inside Mover Workflow identityName "+identityName);
        Identity identity = getIdentityObj(identityName);

        if(identity != null){

        plan = buildMoverPlan(identity);
        if(plan != null)
        log.info("Inside Mover Workflow plan after calling the method "+plan.toXml());
        workflow.put("plan",plan);
        }
        return plan;

      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Conversion WebService Call"/>
    </Step>
    <Step icon="Start" name="Conversion WebService Call" posX="50" posY="10" resultVariable="isAssoToContraConv">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Description>Checking the Employee type .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
         log.info("****** Conversion WebService Call "+identityName);
        Identity identity = getIdentityObj(identityName);
        boolean isAssoToContraConv = false;
        if(identity !=null @and identity.getAttribute(ATR_EMPLOYEETYPE) !=null ){
        if(identity.getAttribute(ATR_EMPLOYEETYPE).equalsIgnoreCase(STR_CONTRACTOR) ){  
        isAssoToContraConv = true;
        return true;
        }
        else {
        isAssoToContraConv = false;
        return false;
        }
        }
      </Source>
      </Script>
      <Transition to="Convert Associate To Contractor" when="script:(isAssoToContraConv)"/>
      <Transition to="Convert Contractor To Associate"/>
    </Step>
    <Step icon="Start" name="Convert Associate To Contractor" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Description>Convert Associate To Contractor .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        import java.util.HashMap;
        try{
		Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
        Identity identity = getIdentityObj(identityName);
        HashMap userDetailsMap = generateUserDetaislMap(identityName);
        log.info("In Convert Associate To Contractor ::"+identityName);
        HashMap conAssoConResultMap = convertAssociateToContractor(userDetailsMap);
		int faultCode = conAssoConResultMap.get("faultCode");
	String faultReason = conAssoConResultMap.get("faultReason");
	System.out.println("faultCode:::"+faultCode);
	System.out.println("faultCode:::"+faultReason);
	if(faultCode == 9000){
		System.out.println("convertContractorToAssociateInput SuccessIn if");
  }else{
    System.out.println("ELSE convertContractorToAssociateInput Failed:::");
      conAssoConResultMap.put("User ID",userDetailsMap.get("user_id"));
     conAssoConResultMap.put("Employee ID",userDetailsMap.get("emp_id"));
     conAssoConResultMap.put("UAAS Web Service name","convertContractorToAssociate");
   		sendCiamFailureNotication(conAssoConResultMap);
     source = "createAssociate";
    auditAttributes.put("User ID",userDetailsMap.get("user_id"));
	auditAttributes.put("OLD User ID",userDetailsMap.get("extended1"));
     auditAttributes.put("Employee ID",userDetailsMap.get("emp_id"));
     auditAttributes.put("UAAS Web Service name","convertContractorToAssociate");
    createCiamAuditEvent(source,identityName,null,STR_AUDIT_CF_SP_CIAMSYNCFAILURE,null,identityName,null,null,auditAttributes,null,null,null,null);
	}
        
        }catch(Exception e){
        e.printStackTrace();
        }
        
       </Source>
      </Script>
      <Transition to="Provisioning Status"/>
    </Step>
    <Step icon="Start" name="Convert Contractor To Associate" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="project" value="ref:project"/>
      <Description>Convert Associate To Contractor .</Description>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        import java.util.HashMap;
        try{
		Logger log = Logger.getLogger("com.carefirst.MoverWorkflow");
        Identity identity = getIdentityObj(identityName);
        log.info("****** Convert Contractor To Associate "+identityName);
       HashMap userDetailsMap = generateUserDetaislMap(identityName);
      HashMap conConAssoResultMap =  convertContractorToAssociateInput(userDetailsMap);
	  int faultCode = conConAssoResultMap.get("faultCode");
	String faultReason = conConAssoResultMap.get("faultReason");
	System.out.println("faultCode:::"+faultCode);
	System.out.println("faultCode:::"+faultReason);
	if(faultCode == 9000){
		System.out.println("convertContractorToAssociateInput SuccessIn if");
  }else{
    System.out.println("ELSE convertContractorToAssociateInput Failed:::");
      conConAssoResultMap.put("User ID",userDetailsMap.get("user_id"));
     conConAssoResultMap.put("Employee ID",userDetailsMap.get("emp_id"));
     conConAssoResultMap.put("UAAS Web Service name","convertContractorToAssociate");
   		sendCiamFailureNotication(conConAssoResultMap);
     source = "createAssociate";
    auditAttributes.put("User ID",userDetailsMap.get("user_id"));
	auditAttributes.put("OLD User ID",userDetailsMap.get("extended1"));
     auditAttributes.put("Employee ID",userDetailsMap.get("emp_id"));
     auditAttributes.put("UAAS Web Service name","convertContractorToAssociate");
    createCiamAuditEvent(source,identityName,null,STR_AUDIT_CF_SP_CIAMSYNCFAILURE,null,identityName,null,null,auditAttributes,null,null,null,null);
	}
        
        }catch(Exception e){
        e.printStackTrace();
        }
        
       </Source>
      </Script>
      <Transition to="Provisioning Status"/>
    </Step>
    <Step icon="Start" name="AD Aggregation" posX="148" posY="10">
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>
        import org.apache.log4j.Logger;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        Logger log = Logger.getLogger("com.carefirst.ADAggregation");
        if(plan != null){
        log.info("Inside ADAggeration plan "+plan.toXml());
        AccountRequest accReq =new AccountRequest();

        accReq =plan.getAccountRequest(STR_ACTIVE_DIRECTORY);
        log.info("Accountrequest "+accReq.toXml());
        String nativeIdentity=accReq.getNativeIdentity();
        log.info("nativeIdentity :: "+nativeIdentity);
        String modifiedIdentity="";
        if(nativeIdentity.contains(STR_ASOCIATES_ORG)){
        modifiedIdentity=nativeIdentity.replaceAll(STR_ASOCIATES_ORG,STR_CONTRACTOR_ORG);
        }else if(nativeIdentity.contains(STR_CONTRACTOR_ORG)){
        modifiedIdentity=nativeIdentity.replaceAll(STR_CONTRACTOR_ORG,STR_ASOCIATES_ORG);
        else{
        modifiedIdentity=nativeIdentity;
        }
        log.info("modifiedIdentity :: "+modifiedIdentity);
        try{

        String statusOfAggregation=singleAccountAggregation(STR_ACTIVE_DIRECTORY,modifiedIdentity);
        log.info("statusOfAggregation :: "+statusOfAggregation);
        }catch(Exception e){
        log.error("Exception in Aggregation");
        }
        }
      </Source>
      </Script>
      <Transition to="Provisioning Status"/>
    </Step>
    <Step name="Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Arg name="project" value="ref:project"/>
      <Script>
        <Source>
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.MoverWorkflow.Check Provisioning Status");

        List errors=new ArrayList();
        try{
        errors=getErrors(context,project);

        if(errors!=null @and errors.size()>0){
        Map errorsMap = new HashMap();

        errorsMap.put(identityName,Util.listToCsv(errors));
        workflow.put("failedMap",errorsMap);
        log.info("failed map is " +failedMap);
        return false;
        }
        return true;
        }
        catch(Exception ex){
        return ex;
        }


      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;
        Logger log = Logger.getLogger("com.carefirst.MoverWorkflowTest");
        log.info("Inside Mover  identityName in SendProvisioningSuccessEmail  "+identityName);
        Attributes attributes = new Attributes();
        Identity identity = getIdentityObj(identityName);

        if(identity != null){

        String userType = identity.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null){
        if(userType.equalsIgnoreCase(STR_EMPLOYEE)){
        attributes.put(STR_OLD_USER_TYPE,STR_CONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);
        }else if(userType.equalsIgnoreCase(STR_CONTRACTOR)){
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        attributes.put(STR_OLD_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_CONTRACTOR);
        }else if(userType.equalsIgnoreCase(STR_FEPOCEMPLOYEE)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCCONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCEMPLOYEE);
        attributes.put(STR_ATR_ASSOCIATE,STR_FEPOCASSOCIATEBIZROLE);
        }
        else if(userType.equalsIgnoreCase(STR_FEPOCCONTRACTOR)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCEMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCCONTRACTOR);
        attributes.put(STR_ATR_CONTRACTOR,STR_FEPOCCONTRACTORBIZROLE);
        }
        }
        sendEmailNotification(identityName,STR_PROVISIONING_SUCCESS_EMAIL_TEMPLATE_MOVER,"");
        createAuditEvent(STR_ADUIT_MOVER_SUCCESS_NOTIFICATION,null,null,STR_ADUIT_MOVER_SUCCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        }
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;

        Attributes attributes = new Attributes();
        Identity identity =getIdentityObj(identityName);

        if(identity != null){
        String userType = identity.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null){
        if(userType.equalsIgnoreCase(STR_EMPLOYEE)){
        attributes.put(STR_OLD_USER_TYPE,STR_CONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);
        }else if(userType.equalsIgnoreCase(STR_CONTRACTOR)){
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        attributes.put(STR_OLD_USER_TYPE,STR_EMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_CONTRACTOR);
        }else if(userType.equalsIgnoreCase(STR_FEPOCEMPLOYEE)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCEMPLOYEE);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCCONTRACTOR);
        }
        else if(userType.equalsIgnoreCase(STR_FEPOCCONTRACTOR)){

        attributes.put(STR_OLD_USER_TYPE,STR_FEPOCCONTRACTOR);
        attributes.put(STR_NEW_USER_TYPE,STR_FEPOCEMPLOYEE);
        }
        }
        sendEmailNotification(identityName,failedMap,STR_PROVISIONING_FAILURE_EMAIL_TEMPLATE);
        createAuditEvent(STR_ADUIT_MOVER_FAILURE_NOTIFICATION,null,null,STR_ADUIT_MOVER_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
        }
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1604319263312" explicitTransitions="true" id="0a111e5c758812a9817588e13a4f0009" libraries="Identity" modified="1617628841622" name="CF-Rehire-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="message">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="manager">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable name="errorMsg">
      <Description>To capture the error message from project </Description>
    </Variable>
    <Variable name="approvalEmailTemplate">
      <Description>
      The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
      The sequence id of the Identity request object which is stored in 
      the name field of the identity request.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
      The String version of a WorkItem.Priority. This variable is 
      used to set the priority on all of the workitems generated 
      as part of this workflow and also set on the IdentityRequest
      object.
    </Description>
    </Variable>
    <Description>Disable all accounts when an employee leaves the company.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="28" posY="10">
      <Transition to="Compare Dates"/>
    </Step>
    <Step name="Compare Dates" resultVariable="plan">
      <Script>
        <Source>
        import java.util.Calendar;
        import java.util.Date;
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;
        import sailpoint.api.Provisioner;
        import sailpoint.object.*;

        Logger log = Logger.getLogger("com.carefirst.RehireWorkflow");
        log.info("####### Start of Rehire Lifecycle #####"+identityName);

        Identity i= getIdentityObj(identityName);
        log.info("####### Start of Rehire Lifecycle #####"+i);
        SimpleDateFormat sdf = new SimpleDateFormat("dd-MMM-yy");

        String effDate=i.getAttribute("effdt");

        Date actualeffdate=  sdf.parse(effDate);


        log.info("####### Start of Compare Dates Step #####");
        Date currentDate = new Date();
        String currentDateString= sdf.format(currentDate);
        Date actualCurrentDate=  sdf.parse(currentDateString);
        Calendar c = Calendar.getInstance();
        c.setTime(currentDate);
        c.add(Calendar.DATE, 60); 



        // convert calendar to date
        Date retentionPeriodinDateFormat = c.getTime();
        String retentionPeriod= sdf.format(retentionPeriodinDateFormat);
        Date actualretentionPeriod=   sdf.parse(retentionPeriod);
        i.setAttribute("inactive","false");
        String strEmpType = i.getAttribute(ATR_EMPLOYEETYPE) != null ? identity.getAttribute(ATR_EMPLOYEETYPE) :"";
        log.info("####### Start of Compare Dates Step #####"+actualretentionPeriod+actualeffdate+STR_EMPLOYEE+strEmpType);

        if(((i.getAttribute("action").equals("REH"))@or(i.getAttribute("action").equals("RFL"))@or(i.getAttribute("action").equals("RFD"))) @and ((actualCurrentDate.compareTo(actualeffdate) == 0) @or (actualeffdate.before(actualretentionPeriod)@and actualeffdate.before(actualCurrentDate))) ){

        plan=createEnablePlan(i);
        i.setAttribute("inactive","false");

workflow.put("approvalEmailTemplate",STR_PROVISIONING_SUCCESS_EMAIL_TEMPLATE_REHIRE);

        }else{
        log.info("----------- Start of Compare Dates Step #####"+actualretentionPeriod+actualeffdate+STR_EMPLOYEE+strEmpType+actualretentionPeriod+actualeffdate);
        System.out.println(".................................");
        workflow.put("approvalEmailTemplate","CF-RehireFutureDate-EmailTemplate");
       // workflow.put("effDate",effDate);

        if(actualeffdate.before(actualretentionPeriod)){
        log.info("####### Start of Compare Dates Step #####"+actualretentionPeriod+actualeffdate+STR_EMPLOYEE+strEmpType);
        String dn="";
        if(STR_EMPLOYEE.equalsIgnoreCase(strEmpType)){
        dn=STR_ASSOCIATE_OU;

        }
        else if(STR_CONTRACTOR.equalsIgnoreCase(strEmpType)){

        dn=STR_CONTRACTOR_OU;
        log.info("####### Start of Compare Dates Step #####"+actualretentionPeriod+actualeffdate+STR_EMPLOYEE+strEmpType);
        }
        else if(STR_FEPOCEMPLOYEE.equalsIgnoreCase(strEmpType)){

        dn=STR_FEPOCASSOCIATE_OU;
        }
        else if(STR_FEPOCCONTRACTOR.equalsIgnoreCase(strEmpType)){

        dn=STR_FEPOCCONTRACTOR_OU;
        }
        //   ProvisioningPlan chnageOUplan =changeOU(i,dn);
        //   Provisioner  prov = new Provisioner(context);
        //  prov.compile(chnageOUplan);
        //   prov.execute();
        log.info("dn"+dn);
        //List listofApp=new ArrayList();
        // listofApp= i.getLinks();
        //for(Link l:listofApp){

        //  if(l.getApplicationName().equals(STR_ACTIVE_DIRECTORY) ){
        // String adAccountName=l.getAttribute(STR_DN).toString();
        // String[] s2=adAccountName.split(",",0);
        //    String aname=s2[0]+","+dn;
        plan =changeOU(i,dn);



        //  }
        // }
        }
        }
       System.out.println("plan....................."+plan+plan.toXml());
        //workflow.put("plan",plan);

        return plan;
      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step name="CheckPlan" resultVariable="compilePlan">
      <Arg name="plan" value="ref:plan"/>
      <Script>
        <Source>
        System.out.println("........."+plan);
        if(plan !=null){
        return true;
        }else{
        return false;
        }
      </Source>
      </Script>
      <Transition to="Compile Project" when="script:(compilePlan)"/>
      <Transition to="Stop"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Check Provisioning Status"/>
    </Step>
    <Step icon="Default" name="Check Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Script>
        <Source> 
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow.Check Provisioning Status");

        List errors=new ArrayList();
        try{
        errors=getErrors(context,project);

        if(errors!=null @and errors.size()>0){
        Map failedM = new HashMap();
        if(failedM==null)
        failedM=new HashMap();

        failedM.put(identityName,Util.listToCsv(errors));
        workflow.put("failedMap",failedM);
        return false;
        }
        return true;
        }
        catch(Exception ex){
        return ex;
        }

      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;
        
        Identity i= getIdentityObj(identityName);
        Attributes attributes = new Attributes();
        String constant="ATR_APPLICATION";
        int j=1;
        String keyValue="";

        List listofApplications=new ArrayList();
        listofApplications= i.getLinks();
        for(Link l:listofApplications){

        keyValue=constant+j;
         attributes.put(keyValue,l.getApplicationName().toString());
        j++;

        }
           
        //sendEmailNotification(identityName,approvalEmailTemplate,"");
        createAuditEvent(STR_ADUIT_REHIRE_SUCCESS_NOTIFICATION,null,null,STR_ADUIT_REHIRE_SUCCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
       

      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="template" value="CareFirst-EmailTemplate-ProvisioningFailure"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
         import sailpoint.object.Identity;
       Identity i= getIdentityObj(identityName);
        Attributes attributes = new Attributes();
        String constant="ATR_APPLICATION";
        int j=1;
        String keyValue="";

        List listofApplications=new ArrayList();
        listofApplications= i.getLinks();
        for(Link l:listofApplications){

        keyValue=constant+j;
         attributes.put(keyValue,l.getApplicationName().toString());
        j++;

        }
        
        
       
        
        sendEmailNotification(identityName,STR_PROVISIONING_FAILURE_EMAIL_TEMPLATE,"");
        createAuditEvent(STR_ADUIT_REHIRE_FAILURE_NOTIFICATION,null,null,STR_ADUIT_REHIRE_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
       
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step name="Stop" posX="268" posY="10"/>
    <Step name="singlAccAggregation" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;

        Identity i =getIdentityObj(identityName);
        String dn="";
        if(STR_EMPLOYEE.equalsIgnoreCase(strEmpType)){
        dn=STR_ASSOCIATE_OU;

        }
        else if(STR_CONTRACTOR.equalsIgnoreCase(strEmpType)){

        dn=STR_CONTRACTOR_OU;
        }
        else if(STR_FEPOCEMPLOYEE.equalsIgnoreCase(strEmpType)){

        dn=STR_FEPOCASSOCIATE_OU;
        }
        else if(STR_FEPOCCONTRACTOR.equalsIgnoreCase(strEmpType)){

        dn=STR_FEPOCCONTRACTOR_OU;
        }else{
        dn="";
        }
        List listofApp=new ArrayList();
        listofApp= i.getLinks();
        for(Link l:listofApp){

        if(l.getApplicationName().equals(STR_ACTIVE_DIRECTORY) ){
        String adAccountName=l.getAttribute(STR_DN).toString();
        String[] s2=adAccountName.split(",",0);
        String aname=s2[0]+","+dn;
        String adResult=  singleAccountAggregation(STR_ACTIVE_DIRECTORY, aname);
        System.out.println("adresult"+adResult);
        }
        }
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
  </Workflow>
  <Workflow created="1604319561564" explicitTransitions="true" id="0a111e5c758812a9817588e5c75c000b" libraries="Identity" name="CF-RLOA-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable name="manageruserid">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable name="manager">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
    </RuleLibraries>
    <Step action="call:getIdentityModel" icon="Start" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        System.out.println("identityModel"+identityModel);
        return identityModel;

      </Source>
      </Script>
      <Transition to="Build Provisioning Plan"/>
    </Step>
    <Step icon="Start" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="op" value="Enable"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>

        import sailpoint.object.Identity;
        import org.apache.log4j.Logger;


        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow");
        System.out.println("Inside Leaver Workflow identityName "+identityName);
        Identity identity =getIdentityObj(identityName);
        Identity managerObj;
        String manager_name = null;
        String manager_userid = null;
        if (identity.getManager() != null){
        managerObj = identity.getManager();
        if (managerObj.getName() != null){
        manager_name = managerObj.getName();
        }
        if (managerObj.getAttribute("userid") != null){
        manager_userid = managerObj.getAttribute("userid");
        }
        }			
        System.out.println("manager_name-------"+manager_name+manager_userid);
        workflow.put("manager", manager_name);
        workflow.put("manageruserid", manager_userid);
        if(identity != null){
        plan = createEnablePlan(identity);
        //  String strEmpType = identity.getAttribute(ATR_EMPLOYEETYPE) != null ? identity.getAttribute(ATR_EMPLOYEETYPE) :"";
        //  if(STR_EMPLOYEE.equalsIgnoreCase(strEmpType)){
        //    dn=STR_ASSOCIATE_OU;

        //   }
        // else if(STR_CONTRACTOR.equalsIgnoreCase(strEmpType)){

        //  dn=STR_CONTRACTOR_OU;
        //  }
        //  else if(STR_FEPOCEMPLOYEE.equalsIgnoreCase(strEmpType)){

        //     dn=STR_FEPOCASSOCIATE_OU;
        //  }
        //  else if(STR_FEPOCCONTRACTOR.equalsIgnoreCase(strEmpType)){

        //   dn=STR_FEPOCCONTRACTOR_OU;
        //  }
        // ProvisioningPlan chnageOUplan =changeOU(i,dn);
        // Provisioner  prov = new Provisioner(context);
        // prov.compile(chnageOUplan);
        //  prov.execute();
        //  plan =changeOU(identity,dn);
        // identity.setAttribute(ATR_EMPLOYEESTATUS,STR_TERMINATE);
        //  plan =changeOU(identity);



        log.info("Inside Leaver Workflow plan after calling the method "+plan.toXml());
        }
        return plan;

      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Check Provisioning Status"/>
    </Step>
    <Step icon="Default" name="Check Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Script>
        <Source> 
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow.Check Provisioning Status");

        List errors=new ArrayList();
        try{
        errors=getErrors(context,project);

        if(errors!=null @and errors.size()>0){
        Map failedM = new HashMap();
        if(failedM==null)
        failedM=new HashMap();

        failedM.put(identityName,Util.listToCsv(errors));
        workflow.put("failedMap",failedM);
        return false;
        }
        return true;
        }
        catch(Exception ex){
        return ex;
        }

      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="callingWorkflow" value="ref:callingWorkflow"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;

        Attributes attributes = new Attributes();
        Identity identityObj = getIdentityObj(identityName);

        String userType = identityObj.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null &amp;&amp; userType.equalsIgnoreCase(STR_EMPLOYEE)){

        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);
        }else{
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        }
        sendEmailNotification(identityName,STR_PROVISIONING_SUCCESS_EMAIL_TEMPLATE_RLOA,"");
        createAuditEvent(STR_ADUIT_RLOA_SUCCESS_NOTIFICATION,null,null,STR_ADUIT_RLOA_SUCCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
      </Source>
      </Script>
      <Transition to="SnowTicket"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import sailpoint.object.Attributes;

        Attributes attributes = new Attributes();
        Identity identityObj = getIdentityObj(identityName);

        String userType = identityObj.getAttribute(ATR_EMPLOYEETYPE);
        if(userType != null &amp;&amp; userType.equalsIgnoreCase(STR_EMPLOYEE)){
        attributes.put(STR_ATR_ASSOCIATE,STR_ASSOCIATEBIZROLE);

        }else{
        attributes.put(STR_ATR_CONTRACTOR,STR_CONTRACTORBIZROLE);
        }
        sendEmailNotification(identityName,failedMap,STR_PROVISIONING_FAILURE_EMAIL_TEMPLATE);
        createAuditEvent(STR_ADUIT_RLOA_FAILURE_NOTIFICATION,null,null,STR_ADUIT_RLOA_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Default" name="SnowTicket" posX="50" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        requestDisconnectApplication("Disconnected Application1",identityName);
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1604319863791" explicitTransitions="true" id="0a111e5c758812a9817588ea63ef0013" libraries="Identity" modified="1616869264006" name="CF-LOA-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable name="errorMsg">
      <Description>To capture the error message from project </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
      The sequence id of the Identity request object which is stored in 
      the name field of the identity request.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
      The String version of a WorkItem.Priority. This variable is 
      used to set the priority on all of the workitems generated 
      as part of this workflow and also set on the IdentityRequest
      object.
    </Description>
    </Variable>
    <Description>Disable all accounts when an employee leaves the company.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="op" value="Disable"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>
        import sailpoint.object.*;
        import org.apache.log4j.Logger;
         import sailpoint.api.Provisioner;
       

        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow");
        log.info("Inside LOA Workflow identityName "+identityName);
        Identity identity =getIdentityObj(identityName);

        if(identity != null){
        System.out.println("buildAccountDisablePlan..............");
        plan = buildAccountDisablePlan(identity);
       
        }
         System.out.println("buildAccountDisablePlan.............."+plan);
        return plan;

      </Source>
      </Script>
      <Transition to="Compile Project"/>
    </Step>
    <Step action="compileProvisioningProject" icon="Catches" monitored="true" name="Compile Project" posX="461" posY="7" resultVariable="project">
      <Arg name="trace" value="ref:trace"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="noLocking" value="true"/>
      <Arg name="plan" value="ref:plan"/>
      <Transition to="Provision"/>
    </Step>
    <Step action="call:provisionProject" icon="Provision" name="Provision">
      <Arg name="noTriggers" value="true"/>
      <Arg name="background" value="false"/>
      <Arg name="project" value="ref:project"/>
      <Transition to="Check Provisioning Status"/>
    </Step>
    <Step icon="Default" name="Check Provisioning Status" posX="390" posY="474" resultVariable="isCommitted">
      <Script>
        <Source> 
        import sailpoint.tools.Util;
        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.LeaverWorkflow.Check Provisioning Status");

        List errors=new ArrayList();
        try{
        errors=getErrors(context,project);

        if(errors!=null @and errors.size()>0){
        Map failedM = new HashMap();
        if(failedM==null)
        failedM=new HashMap();

        failedM.put(identityName,Util.listToCsv(errors));
        workflow.put("failedMap",failedM);
        return false;
        }
        return true;
        }
        catch(Exception ex){
        return ex;
        }

      </Source>
      </Script>
      <Transition to="SendProvisioningSuccessEmail" when="script:(isCommitted)"/>
      <Transition to="SendFailureEmail"/>
    </Step>
    <Step icon="Email" name="SendProvisioningSuccessEmail" posX="148" posY="10">
      <Arg name="identityName" value="ref:identityName"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        import sailpoint.object.Identity;

        Identity identity =getIdentityObj(identityName);

        if(identity != null){

       
        context.saveObject(identity);
        context.commitTransaction();
        }

        Attributes attributes = new Attributes();
        attributes.put("ATR_APPLICATION1",STR_ACTIVE_DIRECTORY);
        attributes.put("ATR_APPLICATION2",STR_ISAM_LDAP);
        attributes.put("ATR_APPLICATION3",STR_JMS_REQ_VALUT_NAME);
        attributes.put("ATR_APPLICATION4",STR_ONESTOP_SERVICENOW);
        sendEmailNotification(identityName,STR_PROVISIONING_SUCCESS_EMAIL_TEMPLATE_LOA,"");
        createAuditEvent(STR_ADUIT_LOA_SUCCESS_NOTIFICATION,null,null,STR_ADUIT_LOA_SUCCESS_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Email" name="SendFailureEmail" posX="148" posY="10">
      <Arg name="template" value="CareFirst-EmailTemplate-ProvisioningFailure"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="failedMap" value="ref:failedMap"/>
      <Script>
        <Source>
        import sailpoint.object.Attributes;
        Attributes attributes = new Attributes();
        attributes.put("ATR_APPLICATION1",STR_ACTIVE_DIRECTORY);
        attributes.put("ATR_APPLICATION2",STR_ISAM_LDAP);
        attributes.put("ATR_APPLICATION4",STR_JMS_REQ_VALUT_NAME);
        attributes.put("ATR_APPLICATION4",STR_ONESTOP_SERVICENOW);
        sendEmailNotification(identityName,failedMap,STR_PROVISIONING_FAILURE_EMAIL_TEMPLATE);
        createAuditEvent(STR_ADUIT_LOA_FAILURE_NOTIFICATION,null,null,STR_ADUIT_LOA_FAILURE_NOTIFICATION,null,identityName,null,null,attributes,null,null,null,null);
      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow created="1604320069447" explicitTransitions="true" id="0a111e5c758812a9817588ed8747001c" libraries="Identity" modified="1617905406487" name="CF-ProvisioningApprovalSubprocess-Workflow" type="Subprocess">
    <Variable initializer="ref:approvalMode" input="true" name="approvalMode">
      <Description>
      A string that specifies how we should handle the approvals.

      By default this is serial since most of these request with
      the exception of manager transfers will have only one approver.

      parallel
      Approvals are processed concurrently and there must be consensus,
      we wait for all approvers to approve.  The first approver that
      rejects terminates the entire approval.

      parallelPoll
      Approvals are processed concurrently but consensus is not required.
      All approvals will be processed, we don't stop if there are any
      rejections.

      serial
      Approvals are processed one at a time and there must be consensus.
      The first approver that rejects terminates the entire approval.

      serialPoll
      Approvals are processed in order but consensus is not required.
      All approvals will be processed, we don't stop if there are any
      rejections.  In effect we are "taking a poll" of the approvers.

      any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approval items should be generated 
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below 
      in any order, separated by commas. The order in which they are 
      specified is the order in which they are processed:

      owner
      The object owner gets the approval item. 
      For Role approvals this is the Role object owner. 
      For Entitlement approvals this is the Entitlement object owner.

      manager
      The manager gets the approval item.

      securityOfficer
      The identity in the variable securityOfficerName gets the approval item.

      identity
      The identities/workgroups in the variable approvingIdentities get the approval item.

    </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval 
      process.    
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.      
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
      The ID of the IdentityRequest for this request.
    </Description>
    </Variable>
    <Variable input="true" name="policyViolations">
      <Description>
      List of policy violations that were found during our initial policy scan.
      This list is passed into each work item so the approvers can see
      pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by object owners.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="managerEmailTemplate">
      <Description>
      Name of the email template to use when manager of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
      Name of the email template to use when notifying the owner of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="securityOfficerEmailTemplate">
      <Description>
      Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="identityEmailTemplate">
      <Description>
      Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="workItemDescription">
      <Description>String "template" that will be used as the workitem description.</Description>
    </Variable>
    <Variable input="true" name="workItemEscalationTemplate">
      <Description>The email template that should be used when sending out reminders.</Description>
    </Variable>
    <Variable input="true" name="workItemHoursBetweenReminders">
      <Description>The number of hours to wait between sending reminders to approvers.</Description>
    </Variable>
    <Variable input="true" name="workItemHoursTillEscalation">
      <Description>The number of hourse to wait until an approval should be escalated.</Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
      The String version of a WorkItem.Priority. This variable is
      used to set the priority on all of the workitems generated
      as part of this workflow and also set on the IdentityRequest
      object.
    </Description>
    </Variable>
    <Variable input="true" name="workItemReminderTemplate">
      <Description>The email template that should be used when sending out reminders.</Description>
    </Variable>
    <Variable input="true" name="workItemEscalationRule">
      <Description>The rule used to assign a new ownder during escalation.</Description>
    </Variable>
    <Variable input="true" name="workItemMaxReminders">
      <Description>The maximum number of reminder emails that will be sent before we begin the escalation process.</Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="clearApprovalDecisions">
      <Description>True to clear all decisions when generating approvals</Description>
    </Variable>
    <Variable initializer="true" input="true" name="dontUpdatePlan">
      <Description>True to skip updating the ProvisioningProject masterPlan when processing approval decisions.</Description>
    </Variable>
    <Variable input="true" name="approvalSet" output="true">
      <Description>
      ApprovalSet representing the things that were requested and come from
      the master provisioning plan. 
    </Description>
    </Variable>
    <Variable name="ownerName">
      <Description>ownerName.</Description>
    </Variable>
    <Variable input="true" name="project" output="true">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan, the 
      master plan will be adjusted when approval decisions are applied and a new 
      revised provisiobion project will be returned.
    </Description>
    </Variable>
    <Variable input="true" name="plan" output="true">
      <Description>The provisioning plan.</Description>
    </Variable>
    <Description>
    Simple approval subrocess introduced into release 6.2 to make
    adding custom approvals easier.  This approval subprocess
    has a configuration form to make it easier to configure
    from the Business Process Editor.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f817585910a8c272b" name="CF-Library-AccessRequestWorkflowRuleLibrary-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="20" posY="22">
      <Transition to="Approval"/>
    </Step>
    <Step name="ValidateRole" posX="20" posY="22">
      <Script>
        <Source>
        import sailpoint.object.IdentityRequest;
        import sailpoint.object.WorkflowSummary.ApprovalSummary;
        import sailpoint.object.EmailTemplate;
        import sailpoint.object.EmailOptions;



        System.out.println("identityRequestId subprocess"+identityRequestId);


        IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);

        System.out.println("identityRequestobject"+idReq);
        //System.out.println("idReq.getExternalTicketId() "+idReq.get);

        EmailTemplate template = context.getObjectByName(EmailTemplate.class, "CareFirst-TicketUpdate-POC");
        String email = "Admin@carefirst.com";
        EmailOptions options = new EmailOptions();
        options.setTo(email);                
        //options.setVariable("ticketid", idReq.getApprovalSummaries().get(0).getApprovalSet().getApproved().get(0).getApprover());
        options.setVariable("identityRequestId", identityRequestId);
        //options.setVariable("ExternalTicketId", idReq.getExternalTicketId());
        context.sendEmailNotification(template, options);







      </Source>
      </Script>
      <Transition to="Approval"/>
    </Step>
    <Step icon="Approval" name="Approval" posX="158" posY="22">
      <Approval mode="serial" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId">
        <Arg name="launcher" value="ref:launcher"/>
        <Arg name="workItemDescription" value="ref:workItemDescription"/>
        <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
        <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
        <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
        <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
        <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
        <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="approvalMode" value="ref:approvalMode"/>
        <Arg name="approvalScheme" value="ref:approvalScheme"/>
        <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
        <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
        <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Approval mode="serial" owner="script:firstLevelAppoval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;

            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import sailpoint.object.IdentityRequest;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.ApprovalItem;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            System.out.println("item.getCompleter "+item.getCompleter());
            System.out.println("owner subprocess"+item.getOwner());
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());

            if(idReq.getExternalTicketId()!=null){            
            String comments="First level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }






          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:secondApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Second level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }

          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();
System.out.println("***************2nd approval iq: "+iq);
				
            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
            displayNameOld = identityCube.getDisplayName();
           System.out.println("***************2nd approval displayNameOld : "+displayNameOld);
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            System.out.println("***************2nd approval before else modifiedOwnerName : "+modifiedOwnerName);
            } 
            
            else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }

System.out.println("***************2nd approval after else modifiedOwnerName : "+modifiedOwnerName);

            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:thirdApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;


            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Third level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
String displayNameOld = "";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
           Strng displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:fourthApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Fourth level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }



            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:fifthApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Fifth level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
            String displayNameOld="";

            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
              displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }



            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:sixthApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Sixth level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
            String displayNameOld="";

            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
            displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }



            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:seventhApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Seventh level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
            String displayNameOld="";

            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
            displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:eieghthApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Eigth level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
            String displayNameOld="";

            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
          displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }



            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:ninethApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
            import sailpoint.object.Identity;
            import sailpoint.object.EmailTemplate;
            import sailpoint.object.EmailOptions;
            import java.util.Map;
            import java.util.HashMap;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import sailpoint.object.IdentityRequest;

            if ( item == null ) 
            return;

            WorkItem.State state = item.getState();  
            if (state.equals(WorkItem.State.Rejected) 
            || state.equals(WorkItem.State.Expired) 
            || state.equals(WorkItem.State.Canceled)) 
            {  
            List approvalItems = approvalSet.getItems();  
            for (ApprovalItem approvalItem : approvalItems) 
            {  
            approvalItem.reject();  
            List listOfComments = approvalItem.getComments();  
            approvalItem.add(new Comment("Auto reject item due to lack of approval", "system"));  
            item.addComment("Auto reject item due to lack of approval", "system");  
            item.setCompletionComments("Auto reject item due to lack of approval");  
            }  
            } 

            //sendEmailWithApprovalDecisions(approval, launcher, identityName, workItemNotificationTemplate, "");

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
            auditDecisions(item);  
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);

            System.out.println("identityRequestId subprocess"+identityRequestId);
            if(identityRequestId!=null){
            IdentityRequest idReq = context.getObjectByName(IdentityRequest.class, identityRequestId);
            System.out.println("identityRequestobject"+idReq);
            System.out.println("idReq.getExternalTicketId() "+idReq.getExternalTicketId());


            if(idReq.getExternalTicketId()!=null){
            String comments="Ninth level approval completed by:"+item.getCompleter();
            updateTicket(idReq.getExternalTicketId(),comments);
            }
            }
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            import java.util.Iterator;
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
            String displayNameOld="";

            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
            displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }



            System.out.println("owner subprocess"+item.getOwner());
            System.out.println("owner subprocess.........."+launcher);
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
            // promote completion state to Rejected if all items are rejected
            ApprovalSet aset = item.getApprovalSet();
            if (aset != null) {
            List items = aset.getItems();
            if (items != null) {
            int rejectCount = 0;
            for (ApprovalItem item : items) {
            // note that isRejected can't be used since that
            // assumes no answer means rejected
            if (item.getState() == WorkItem.State.Rejected) {
            rejectCount++;
            }
            }
            if (rejectCount == items.size()) {
            item.setState(WorkItem.State.Rejected);
            }
            }
            }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

            ApprovalSet currentSet = approval.getApprovalSet();

            if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
            if (Boolean.valueOf(filterRejects)) {
            filterRejectsFromApprovalSet(approvalSet, currentSet);
            }

            //We've filtered all items from the approval set
            if (Util.isEmpty(currentSet.getItems())) {
            //Complete the approval if it contains no ApprovalItems
            approval.setComplete(true);
            } else {

            if (Boolean.valueOf(setPreviousApprovalDecisions)) {
            // If setPreviousApprovalDecisions is enabled, set the decision
            // on the items to that of the global item.
            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
            }
            }
            }  

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
            // Owner children approvals need to propagate the rejection state if all children are rejected
            Approval parentApp = approval.getParent();
            // Never relay the state to the root approval
            // If we don't have an approvalSet, must be a container approval
            if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
            boolean completeAndRejected = false;
            for (Approval child : Util.safeIterable(approval.getChildren())) {
            if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
            completeAndRejected = true;
            } else {
            completeAndRejected = false;
            break;
            }
            }
            //If all children complete and rejected, set the status on the parent approval
            if (completeAndRejected) {
            approval.setState(WorkItem.State.Rejected);
            }
            }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
            import sailpoint.workflow.IdentityRequestLibrary;

            //Sync IdentityRequestItems with the WorkItem
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
      </Approval>
      <Transition to="Process Approval Decisions" when="script:(step.getApproval() != null &amp;&amp; step.getApproval().containsApprovalItems())"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:processApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="420" resultVariable="project">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="disableAudit" value="true"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="recompilePlan" value="true"/>
      <Arg name="dontUpdatePlan" value="ref:dontUpdatePlan"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="420" posY="225"/>
  </Workflow>
  <Workflow created="1604320069538" explicitTransitions="true" id="0a111e5c758812a9817588ed87a2001d" modified="1616679160199" name="CF-ApproveAndProvisionSubprocess-Workflow" type="Subprocess">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
            The displayName of the identity being updated.
            Query for this using a projection query and fall back to the name.
        </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
            The name of the LCM flow that launched this workflow.

            This is one of these three values:

            AccountsRequest
            EntitlementsRequest
            RolesRequest
        </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
            Set to true to enable optimistic provisioning.  This will cause
            changes to the entitlements compiled from role assignments to be
            applied immediately to the identity cube rather than waiting
            for the next refresh/reaggregation after the provisioning system
            completes the request.
        </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
            Normally provisioning is done in a step that uses the "background"
            option to force the workflow to be suspend and be resumed in a
            background task thread.  This prevents the browser session from
            hanging since provision can sometimes take a long time.  For demos
            and testing it can be better to do this in the foreground so that
            provisioning will have been performed when control is returned to the
            user.  This prevents having to run the Perform Maintenance task to
            see the results of the request.
        </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
            Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
        </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
            The email template to use for user notification.
        </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
            The email template to use for requester notification.
        </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
            The email template to use for manager notification.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
            The email template to use for security officer notification.
        </Description>
    </Variable>
    <Variable initializer="parallel" input="true" name="approvalMode">
      <Description>
            A string that specifies how we should handle the approvals.

            By default this is serial since most of these request with
            the exception of manager transfers will have only one approver.

            parallel
            Approvals are processed concurrently and there must be consensus,
            we wait for all approvers to approve.  The first approver that
            rejects terminates the entire approval.

            parallelPoll
            Approvals are processed concurrently but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.

            serial
            Approvals are processed one at a time and there must be consensus.
            The first approver that rejects terminates the entire approval.

            serialPoll
            Approvals are processed in order but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.  In effect we are "taking a poll" of the approvers.

            any
            Approvals are processed concurrently, the first approver to
            respond makes the decision for the group.
        </Description>
    </Variable>
    <Variable initializer="owner" input="true" name="approvalScheme">
      <Description>
            A csv string that specifies how approval items should be generated
            for the incoming request.

            The value can be "none", in which case approvals are disabled.

            The value can also be a combination of any of the values below
            in any order, separated by commas. The order in which they are
            specified is the order in which they are processed:

            owner
            The object owner gets the approval item.
            For Role approvals this is the Role object owner.
            For Entitlement approvals this is the Entitlement object owner.

            manager
            The manager gets the approval item.

            securityOfficer
            The identity in the variable securityOfficerName gets the approval item.

            identity
            The identities/workgroups in the variable approvingIdentities get the approval item.
        </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
            The email template to use for approval notifications.
        </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
            The String version of a WorkItem.Priority. This variable is
            used to set the priority on all of the workitems generated
            as part of this workflow and also set on the IdentityRequest
            object.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
            The name of the identity that will be sent approvals
            during security officer approvals.
        </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
            A String that specifies the name of the Identity that will
            be assigned any approvals where the owner of the approver
            can't be resolved. Example if the scheme is "owner" and the
            application doesn't specify and owner.
        </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
            When set to true it will disable the workflow retry loop and let the
            Provision step launch requests to handle the retries.  Enabling
            this flag will enable some older functionality.
        </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to LCM.
        </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
            Used for debugging this workflow and when set to true trace
            will be sent to stdout.
        </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
            This attributes is set during the "Build Approval Set" step,
            which builds this list by going through the ProvisioningPlan
            to build the line items that need to be approved,

            This variable includes all ApprovalItems that are part of
            the request process and is updated during the AfterScript
            of the approval process by assimilating the decisions
            and comments from the Approvals copy of the ApprovalItem.
        </Description>
    </Variable>
    <Variable input="true" name="approvalAssignmentRule"/>
    <Variable name="project">
      <Description>
            ProvisioningProject which is just a compiled version of the ProvisioningPlan.
        </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
            List of policy violations that were found during our initial policy scan.
            This list is passed into each work item so the approvers can see
            pending violations.
        </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
            The sequence id of the Identity request object which is stored in
            the name field of the identity request and auto-incremented.
        </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
            Global comments accumulated during the workflow which should be shared
            with other approvals. When a new approval is created, the comments in this
            list will be added to the work item.
        </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
            Name of the application that can handle ticket requests.
            When non-null the Manage Ticket Steps will be visited to open
            tickets during the workflow lifecycle.
        </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by a manager.
        </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by object owners.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by the security officer.
        </Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable input="true" name="approvalSplitPoint">
      <Description>Approval Scheme to split on.</Description>
    </Variable>
    <Variable input="true" name="clearApprovalDecisions">
      <Description>
            True to clear any decisions on approvals built with buildCommonApprovals
        </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
            List of identities and/or workgroups names/ids that should be involved in the approval
            process.
        </Description>
    </Variable>
    <Variable input="true" name="formTemplate"/>
    <Variable input="true" name="manualActionsEmailTemplate"/>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
            Name of the email template to use when notifying the owner of pending approvals.
        </Description>
    </Variable>
    <Variable initializer="false" input="true" name="splitProvisioning">
      <Description>
            True to tell IdentityRequest Provisioning subprocess that this is a subset of the initial provisioning plan
        </Description>
    </Variable>
    <Description>Subprocess to approve and provision immediately. This is used after splitting an ApprovalSet into individual items to run in parallel.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f817585910a8c272b" name="CF-Library-AccessRequestWorkflowRuleLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="20" posY="20">
      <Transition to="Compile Project"/>
    </Step>
    <Step action="call:compileProvisioningProject" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Compile Project" posX="120" posY="20" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="noApplicationTemplates">
        <Script>
          <Source>
                    boolean ignoreForms = false;
                    if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
                    ignoreForms = true;
                    }
                    return ignoreForms;
                </Source>
        </Script>
      </Arg>
      <Transition to="Build Approval Set"/>
    </Step>
    <Step action="call:buildSplitApprovalSet" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Build Approval Set" posX="220" posY="20" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Approve"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" configForm="Provisioning Approval Step Form" icon="Approval" name="Approve" posX="320" posY="20">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature"/>
      <Arg name="identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="workItemComments"/>
      <Arg name="clearApprovalDecisions" value="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c758812a9817588ed8747001c" name="CF-ProvisioningApprovalSubprocess-Workflow"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Approval"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="470" posY="20">
      <Arg name="action" value="postApproval"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Provision" name="Provision" posX="600" posY="20">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
      <Description>
            Call the standard subprocess that will process the
            approval decisions and do provisioning.  This
            includes calling any configured provisioning
            connectors and building manual actions.
        </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Provision"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="700" posY="20">
      <Arg name="action" value="postProvisioning"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
    </Step>
  </Workflow>
  <Workflow created="1604336753272" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c75891b75817589ec1a750000" libraries="Identity,BatchRequest" name="CF-ImmediateTermination-Workflow" taskType="LCM" type="LCMRegistration">
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="requester">
      <Description>
      The person who has requested the update.
    </Description>
    </Variable>
    <Variable input="true" name="identityModel" type="input">
      <Description>
      The custom model that is used to house and pass application data.
    </Description>
    </Variable>
    <Variable name="identityName" type="input">
      <Description>
      Shows the identityname.
    </Description>
    </Variable>
    <Variable name="launcher">
      <Description>
      Shows the requester.
    </Description>
    </Variable>
    <Variable name="confirmationForm">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="requester">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>
      Shows the plan.
    </Description>
    </Variable>
    <Description>
    Initialize the data in the model.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c46893c0168" name="Approval Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start">
      <Transition to="Initialize"/>
    </Step>
    <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
      <Transition to="Initialize IdentityModel"/>
    </Step>
    <Step name="Initialize IdentityModel" resultVariable="identityModel">
      <Script>
        <Source>

        import sailpoint.transformer.IdentityTransformer;
        identityModel.put(IdentityTransformer.ATTR_TRANSFORMER_CLASS,"sailpoint.transformer.IdentityTransformer");
        return identityModel;

      </Source>
      </Script>
      <Transition to="App Display Form"/>
    </Step>
    <Step icon="Approval" name="App Display Form">
      <Approval mode="serial" owner="ref:launcher" renderer="workItemForm.xhtml" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CareFirst-Form-UserImmediateTermination"/>
        <Arg name="workItemForm" value="CareFirst-Form-UserImmediateTermination"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
        <Arg name="requester" value="ref:launcher"/>
        <Arg name="workItemRequester" value="ref:launcher"/>
      </Approval>
      <Description>
      Display the application form
      System.out.println("Test"+launcher);
    </Description>
      <Transition to="Confirmation Form"/>
    </Step>
    <Step icon="Approval" name="Confirmation Form" posX="269" posY="10">
      <Approval mode="serial" owner="ref:launcher" return="identityModel" send="requester,identityModel">
        <Arg name="workItemType" value="Form"/>
        <Arg name="workItemDescription" value="CareFirst-Form-ImmediateUserTermination-Confirmatin-Form"/>
        <Arg name="workItemForm" value="CareFirst-Form-ImmediateUserTermination-Confirmation"/>
        <Arg name="workItemFormBasePath" value="identityModel"/>
      </Approval>
      <Description>
      Display the confirmation form to the registrant.
    </Description>
      <Transition to="Set identity name"/>
    </Step>
    <Step name="Set identity name" posX="507" posY="6" resultVariable="identityName">
      <Description>
      Set the identityName workflow variable based on the form input.
    </Description>
      <Script>
        <Source>
        return identityModel.get("identityName");
      </Source>
      </Script>
      <Transition to="Build Plan"/>
    </Step>
    <Step name="Build Plan" resultVariable="plan">
      <Script>
        <Source>
        import sailpoint.object.Identity;
        import java.text.DateFormat; 
        import java.text.SimpleDateFormat;
        import java.util.Date; 

        import org.apache.log4j.Logger;

        Logger log = Logger.getLogger("com.carefirst.ImmediateTrigger");
        log.info("identityName in BuildPlan step "+identityName);

        Identity identity =context.getObjectByName(Identity.class,identityName);
        if(identity != null){
          identity.setInactive(true);
          identity.setAttribute("action","TER");
          identity.setAttribute("employeestatus","Terminate");
          Date date = new Date(); 
          DateFormat dateFormat = new SimpleDateFormat("dd-MMM-yy");  
          String strDate = dateFormat.format(date); 
          identity.setAttribute("enddate",strDate);
          context.saveObject(identity);
          context.commitTransaction();
        }

      </Source>
      </Script>
      <Transition to="TriggerLeaverWorkflow"/>
    </Step>
    <Step name="TriggerLeaverWorkflow">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Description>
      Calling the leaver workflow to disable the accounts.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c758812a9817588d9c5d00004" name="CF-Leaver-Workflow"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end"/>
  </Workflow>
  <Workflow created="1604336753533" explicitTransitions="true" id="0a111e5c75891b75817589ec1b7d0001" libraries="Identity" modified="1616058324506" name="CF-Delete-Workflow" type="IdentityLifecycle">
    <Variable input="true" name="trigger">
      <Description>The IdentityTrigger</Description>
    </Variable>
    <Variable input="true" name="event" transient="true">
      <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
    </Variable>
    <Variable input="true" name="message">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable name="manager">
      <Description>
      Shows the confirmationpage.
    </Description>
    </Variable>
    <Variable name="plan">
      <Description>The provisioning plan, which is built by a service method. </Description>
    </Variable>
    <Variable name="errorMsg">
      <Description>To capture the error message from project </Description>
    </Variable>
    <Variable initializer="CF-LeaverProvisioningSuccess-EmailTemplate" input="true" name="approvalEmailTemplate">
      <Description>
      The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
      The sequence id of the Identity request object which is stored in 
      the name field of the identity request.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
      The String version of a WorkItem.Priority. This variable is 
      used to set the priority on all of the workitems generated 
      as part of this workflow and also set on the IdentityRequest
      object.
    </Description>
    </Variable>
    <Description>Delete all accounts when an employee leaves the company.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d99426ac" name="CF-Constants-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="op" value="Delete"/>
      <Arg name="event" value="ref:event"/>
      <Arg name="trigger" value="ref:trigger"/>
      <Description>Go through all of the user's links and build a plan.</Description>
      <Script>
        <Source>
       
  import sailpoint.object.Application;
  import sailpoint.object.Identity;
  import sailpoint.object.Link;
  import sailpoint.object.ProvisioningPlan;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest;
  import sailpoint.object.Link;
  import sailpoint.object.Link;
  import sailpoint.api.Provisioner;
  import sailpoint.api.*;
  import sailpoint.tools.Util;
  import java.text.DateFormat;  
  import java.text.SimpleDateFormat;  
  import java.util.Date;  
  import sailpoint.object.QueryOptions;
  import java.util.Calendar;  
  import java.util.Date;
  import java.util.Date;
  import java.util.List;
  import sailpoint.api.ObjectUtil;
  import sailpoint.api.SailPointContext;
  import sailpoint.object.*;
  import sailpoint.object.Filter;
  import sailpoint.object.Identity;
  import sailpoint.object.QueryOptions;
  import sailpoint.object.NotificationConfig;
  import sailpoint.object.WorkItem;
  import sailpoint.object.EmailOptions;
  import sailpoint.object.EmailTemplate;
        
        Attributes attributes = new Attributes();
        attributes.put(STR_ATR_ASSOCIATE,"null");

  try{
	Identity identity =getIdentityObj(identityName);
  //Identity identity =context.getObjectByName(Identity.class,"");
  if(identity !=null ){
	ProvisioningPlan plan = buildAccountDeletePlan(identity);
    Provisioner  prov = new Provisioner(context);
    prov.compile(plan);
    prov.execute();
        
        
        //Role delete
        ProvisioningPlan p = new ProvisioningPlan();
       // Identity identity = getIdentityObj(identityName);
        log.info("****** Start  of Remove Roles Step identity : "+identity);
		  p.setIdentity(identity);
		  AccountRequest adAccountReq = new AccountRequest();
		   adAccountReq.setApplication("IIQ");
		      adAccountReq.setNativeIdentity(identity.getName());
		  adAccountReq.setOperation(AccountRequest.Operation.Modify);
		  //return existingRA;
		  
		     List assignedRoles = identity.getAssignedRoles();
		    List  detectedRoles = identity.getDetectedRoles();
		  //return bundles;

		 // AttributeRequest attributeRequest = new AttributeRequest();

		  //attributeRequest.setName(ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES);
		 

		  //attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);
		  for(Bundle bundle:assignedRoles){
		    AttributeRequest attributeRequest = new AttributeRequest();

		        attributeRequest.setName(ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES);

		        attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);

		        attributeRequest.setValue(bundle.getName());
		      adAccountReq.add(attributeRequest);
		  }

		  for(Bundle bundle:detectedRoles){
			    AttributeRequest attributeRequest = new AttributeRequest();

			        attributeRequest.setName(ProvisioningPlan.ATT_IIQ_DETECTED_ROLES);

			        attributeRequest.setOperation(ProvisioningPlan.Operation.Remove);

			        attributeRequest.setValue(bundle.getName());
			      adAccountReq.add(attributeRequest);
			  }
		   p.add(adAccountReq);
		  Provisioner  prov1 = new Provisioner(context);
		  prov1.compile(p);
		  prov1.execute();
		  context.commitTransaction();
		  context.saveObject(identity);
        //End of role delete
        
        
    //return prov.getProject();
    //return plan;
        
        //Below lines are Added for Deleting SailPoint Identity Object
   /* Terminator t = new Terminator(context);
 		t.deleteObject(identity);*/
    //Completed Identity Deletion Code
        
        EmailTemplate template = context.getObjectByName(EmailTemplate.class, "CareFirst-UserDeletion-Notification");
  String email = "Admin@carefirst.com";
      EmailOptions options = new EmailOptions();
      Identity manager=identity.getManager();
      if(manager == null){
        options.setTo(email);
      }else{
        if(null != manager.getEmail()){
          options.setTo(manager.getEmail());
        }else{
          options.setTo(email);
        }
      }
      
      Map args = new HashMap();
      args.put("identityName", identity.getName());
       // System.out.println("args.........................."+args);
      args.put("errorMsg",args.get(identityName));

      options.setVariables(args);
      context.sendEmailNotification(template, options);
        createAuditEvent(STR_AUDIT_DELETE_SUCCESS_NOTIFICATION,null,null,STR_AUDIT_DELETE_SUCCESS_NOTIFICATION,null,identity,null,null,attributes,null,null,null,null);
        
        
  }
        }
        catch(Exception e){
        EmailTemplate template = context.getObjectByName(EmailTemplate.class, "CareFirst-UserDeletion-Error");
  		String email = "Admin@carefirst.com";
      EmailOptions options = new EmailOptions();
          options.setTo(email);
       
      Map args = new HashMap();
      args.put("identityName", identity.getName());
       // System.out.println("args.........................."+args);
      args.put("errorMsg",args.get(identityName));

      options.setVariables(args);
      context.sendEmailNotification(template, options);
        createAuditEvent(STR_AUDIT_DELETE_FAILURE_NOTIFICATION,null,null,STR_AUDIT_DELETE_FAILURE_NOTIFICATION,null,identity,null,null,attributes,null,null,null,null);
        
        }
        

      </Source>
      </Script>
      <Transition to="Stop"/>
    </Step>
    <Step icon="Stop" name="Stop" posX="268" posY="10"/>
  </Workflow>
  <Workflow configForm="Provisioning Workflow Config Form" created="1607097145543" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c7623137081762e7458c712b6" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" modified="1607099849592" name="CF-Rest-LCMProvisioning-Workflow" taskType="LCM" type="LCMProvisioning">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these three values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
    </Variable>
    <Variable editable="true" name="doRefresh">
      <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
    </Variable>
    <Variable initializer="user,requester" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
     The email template to use for user notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
     The email template to use for requester notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
     The email template to use for manager notification.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
     The email template to use for security officer notification.
    </Description>
    </Variable>
    <Variable initializer="parallel" input="true" name="approvalMode">
      <Description>
        A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="none" input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item.
        For Role approvals this is the Role object owner.
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      continue -  continue if policy violations are found

      interactive -  allow requester to remove request items which are causing violations

      fail -  this option will cause the workflow to terminate immediately if any policy violations are found.
              Note that the requester will not be notified that the workflow has terminated.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="true" name="allowRequestsWithViolations">
      <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request. This is only relevant
      if policyScheme=interactive.
    </Description>
    </Variable>
    <Variable initializer="true" name="requireViolationReviewComments">
      <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations. This
      is only relevant if policyScheme=interactive.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request and auto-incremented.
    </Description>
    </Variable>
    <Variable name="violationReviewDecision">
      <Description>
       Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

      -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

     </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
      Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
    </Variable>
    <Variable name="ticketId">
      <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval
      process.
    </Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.
    </Description>
    </Variable>
    <Variable input="true" name="identityEmailTemplate">
      <Description>
      Name of the email template to use when notifying the identities/workgroups of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable name="approvalSplitPoint">
      <Description>
          Variable to determine when to split into parallel processing.
          This should map to a configured approvalScheme. We will process all schemes up until
          the approvalSplitPoint in the Pre Split approvals, and the remaining schemes after
          we split the items. If this is not specified, we will not split the Provisioning
          project, and process the entire project as a whole.
      </Description>
    </Variable>
    <Variable name="splitPlans">
      <Description>
          List of ProvisioningPlan that is generated from the splitPlans step if approvalSplitPoint is set.
      </Description>
    </Variable>
    <Variable name="splitProjects">
      <Description>
          Variable to store the returns if approvalSplitPoint is set. This will contain a List&lt;ProvisioningProject>
      </Description>
    </Variable>
    <Variable name="splitApprovalSet">
      <Description>
          Variable to store the list of approvalSets returned from the split subprocess if approvalSplitPoint is set.
      </Description>
    </Variable>
    <Variable name="splitWorkItemComments">
      <Description>
          Variable to store the list of WorkItem comments returned from the split subprocess if approvalSplitPoint is set.
      </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="25" posY="10">
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="134" posY="10">
      <Arg name="flow" value="ref:flow"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
      <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
      <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
      <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="violationReviewDecision" to="violationReviewDecision"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afde002f" name="Identity Request Initialize"/>
      </WorkflowRef>
      <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Exit On Policy Violation" when="script:(&quot;cancel&quot;.equals(violationReviewDecision) || ((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;))))"/>
      <Transition to="Create Ticket"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="381" posY="6">
      <Arg name="action" value="open"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <Return name="ticketId" to="externalTicketId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Pre Split Approve" when="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Transition to="Approve and Provision"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" icon="Task" name="Pre Split Approve" posX="518" posY="63">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme">
        <Script>
          <Source>
              import java.util.List;
              import java.util.ArrayList;
              import java.util.Iterator;
              import sailpoint.tools.Util;

              List schemes = Util.csvToList(approvalScheme);
              List preSchemes = new ArrayList&lt;String>();
              for (String s : Util.safeIterable(schemes)) {
                if (s.equals(approvalSplitPoint)) {
                    break;
                } else {
                    preSchemes.add(s);
                }
              }
              return Util.listToCsv(preSchemes);
          </Source>
        </Script>
      </Arg>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="workItemComments"/>
      <Description>
      Call to our standard subprocess to handle the default approvals for
      manager, owner and security officer.
    </Description>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c46935f0198" name="Provisioning Approval Subprocess"/>
      </WorkflowRef>
      <Transition to="Split Plan"/>
    </Step>
    <Step action="call:splitProvisioningPlan" icon="Task" name="Split Plan" posX="618" posY="63" resultVariable="splitPlans">
      <Arg name="project" value="ref:project"/>
      <Description>
          Step to split the provisioning project into individual projects for each item requested.
          This will only run if the approvalSplitPoint is configured.
      </Description>
      <Transition to="Approve and Provision Split"/>
    </Step>
    <Step icon="Task" name="Approve and Provision Split" posX="783" posY="63">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme">
        <Script>
          <Source>
              import java.util.List;
              import java.util.Iterator;
              import sailpoint.tools.Util;
              List schemes = Util.csvToList(approvalScheme);
              Iterator it = schemes.iterator();
              while (it.hasNext()) {
                String s = it.next();
                if (!s.equals(approvalSplitPoint)) {
                    it.remove();
                } else {
                    break;
                }
              }
              return Util.listToCsv(schemes);
            </Source>
        </Script>
      </Arg>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="splitProvisioning" value="true"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
          Call the Approve and Provision Subprocess for each Provisioning Project generated in the Split Plan step.
      </Description>
      <Replicator arg="plan" items="splitPlans"/>
      <Return name="project" to="splitProjects"/>
      <Return name="workItemComments" to="splitWorkItemComments"/>
      <Return name="approvalSet" to="splitApprovalSet"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0cb0035" name="Approve and Provision Subprocess"/>
      </WorkflowRef>
      <Transition to="Assimilate Splits"/>
    </Step>
    <Step action="call:joinLCMProvWorkflowSplits" icon="Task" name="Assimilate Splits" posX="914" posY="63">
      <Arg name="splitProjects" value="ref:splitProjects"/>
      <Arg name="splitWorkItemComments" value="ref:splitWorkItemComments"/>
      <Arg name="splitApprovalSet" value="ref:splitApprovalSet"/>
      <Description>
          Assimilate all projects returned from the split into the global project.
      </Description>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step icon="Task" name="Approve and Provision" posX="699" posY="7">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="splitProvisioning" value="false"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
          Finish any remaining approvals and provision.
      </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0cb0035" name="Approve and Provision Subprocess"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="1028" posY="7">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Description>
      Add arguments as necessary to enable refresh features.  Typically you
      only want this to correlate roles.  Don't ask for provisioning  since that
      can result in provisioning policies that need to be presented and it's
      too late for that.  This is only to get role detection and exception
      entitlements in the cube.
    </Description>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Task" name="Notify" posX="1131" posY="7">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="source" value="ref:source"/>
      <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b02d0031" name="Identity Request Notify"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Policy Violation" posX="201" posY="253">
      <Arg name="message" value="Failed due to policy violation(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Manual Work Items" posX="364" posY="107">
      <Arg name="message" value="Failed due to manual work item(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Provisioning Form" posX="280" posY="178">
      <Arg name="message" value="Failed due to provisioning form"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Finalize" posX="1058" posY="308">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
    </Step>
    <Step icon="Stop" name="end" posX="1131" posY="253"/>
  </Workflow>
  <Workflow configForm="Provisioning Workflow Config Form" created="1614664911791" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c77a51bf38177f1874baf5bf2" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" modified="1616585778045" name="CF-MulitpleRequest-LCMProvisioning" taskType="LCM" type="LCMProvisioning">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable initializer="Request Access" input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these three values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
    </Variable>
    <Variable editable="true" name="doRefresh">
      <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
    </Variable>
    <Variable initializer="user,requester" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
     The email template to use for user notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
     The email template to use for requester notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
     The email template to use for manager notification.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
     The email template to use for security officer notification.
    </Description>
    </Variable>
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
        A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.  In effect we are "taking a poll" of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="owner" input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item.
        For Role approvals this is the Role object owner.
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      continue -  continue if policy violations are found

      interactive -  allow requester to remove request items which are causing violations

      fail -  this option will cause the workflow to terminate immediately if any policy violations are found.
              Note that the requester will not be notified that the workflow has terminated.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="true" name="allowRequestsWithViolations">
      <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request. This is only relevant
      if policyScheme=interactive.
    </Description>
    </Variable>
    <Variable initializer="true" name="requireViolationReviewComments">
      <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations. This
      is only relevant if policyScheme=interactive.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request and auto-incremented.
    </Description>
    </Variable>
    <Variable name="violationReviewDecision">
      <Description>
       Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

       -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

     </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
      Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
    </Variable>
    <Variable name="ticketId">
      <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval
      process.
    </Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.
    </Description>
    </Variable>
    <Variable input="true" name="identityEmailTemplate">
      <Description>
      Name of the email template to use when notifying the identities/workgroups of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable initializer="owner" name="approvalSplitPoint">
      <Description>
          Variable to determine when to split into parallel processing.
          This should map to a configured approvalScheme. We will process all schemes up until
          the approvalSplitPoint in the Pre Split approvals, and the remaining schemes after
          we split the items. If this is not specified, we will not split the Provisioning
          project, and process the entire project as a whole.
      </Description>
    </Variable>
    <Variable name="splitPlans">
      <Description>
          List of ProvisioningPlan that is generated from the splitPlans step if approvalSplitPoint is set.
      </Description>
    </Variable>
    <Variable name="splitProjects">
      <Description>
          Variable to store the returns if approvalSplitPoint is set. This will contain a List&lt;ProvisioningProject>
      </Description>
    </Variable>
    <Variable name="splitApprovalSet">
      <Description>
          Variable to store the list of approvalSets returned from the split subprocess if approvalSplitPoint is set.
      </Description>
    </Variable>
    <Variable name="splitWorkItemComments">
      <Description>
          Variable to store the list of WorkItem comments returned from the split subprocess if approvalSplitPoint is set.
      </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="25" posY="10">
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="134" posY="10">
      <Arg name="flow" value="ref:flow"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
      <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
      <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
      <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="violationReviewDecision" to="violationReviewDecision"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c785d172f817863f5c1491b2e" name="CF-IdentityRequestInitialize-Workflow"/>
      </WorkflowRef>
      <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Exit On Policy Violation" when="script:(&quot;cancel&quot;.equals(violationReviewDecision) || ((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;))))"/>
      <Transition to="Create Ticket"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="381" posY="6">
      <Arg name="action" value="open"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <Return name="ticketId" to="externalTicketId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Pre Split Approve" when="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Transition to="Approve and Provision"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" icon="Task" name="Pre Split Approve" posX="518" posY="63">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme">
        <Script>
          <Source>
              import java.util.List;
              import java.util.ArrayList;
              import java.util.Iterator;
              import sailpoint.tools.Util;

              List schemes = Util.csvToList(approvalScheme);
              List preSchemes = new ArrayList&lt;String>();
              for (String s : Util.safeIterable(schemes)) {
                if (s.equals(approvalSplitPoint)) {
                    break;
                } else {
                    preSchemes.add(s);
                }
              }
              return Util.listToCsv(preSchemes);
          </Source>
        </Script>
      </Arg>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="workItemComments"/>
      <Description>
      Call to our standard subprocess to handle the default approvals for
      manager, owner and security officer.
    </Description>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c46935f0198" name="Provisioning Approval Subprocess"/>
      </WorkflowRef>
      <Transition to="Split Plan"/>
    </Step>
    <Step action="call:splitProvisioningPlan" icon="Task" name="Split Plan" posX="618" posY="63" resultVariable="splitPlans">
      <Arg name="project" value="ref:project"/>
      <Description>
          Step to split the provisioning project into individual projects for each item requested.
          This will only run if the approvalSplitPoint is configured.
      </Description>
      <Transition to="Approve and Provision Split"/>
    </Step>
    <Step icon="Task" name="Approve and Provision Split" posX="783" posY="63">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme">
        <Script>
          <Source>
              import java.util.List;
              import java.util.Iterator;
              import sailpoint.tools.Util;
              List schemes = Util.csvToList(approvalScheme);
              Iterator it = schemes.iterator();
              while (it.hasNext()) {
                String s = it.next();
                if (!s.equals(approvalSplitPoint)) {
                    it.remove();
                } else {
                    break;
                }
              }
              return Util.listToCsv(schemes);
            </Source>
        </Script>
      </Arg>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="splitProvisioning" value="true"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
          Call the Approve and Provision Subprocess for each Provisioning Project generated in the Split Plan step.
      </Description>
      <Replicator arg="plan" items="splitPlans"/>
      <Return name="project" to="splitProjects"/>
      <Return name="workItemComments" to="splitWorkItemComments"/>
      <Return name="approvalSet" to="splitApprovalSet"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c77a51bf3817815e5dab93b2d" name="CF-MultipleAccessApproveandProvisionSubprocess-Workflow"/>
      </WorkflowRef>
      <Transition to="Assimilate Splits"/>
    </Step>
    <Step action="call:joinLCMProvWorkflowSplits" icon="Task" name="Assimilate Splits" posX="914" posY="63">
      <Arg name="splitProjects" value="ref:splitProjects"/>
      <Arg name="splitWorkItemComments" value="ref:splitWorkItemComments"/>
      <Arg name="splitApprovalSet" value="ref:splitApprovalSet"/>
      <Description>
          Assimilate all projects returned from the split into the global project.
      </Description>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step icon="Task" name="Approve and Provision" posX="699" posY="7">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="splitProvisioning" value="false"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
          Finish any remaining approvals and provision.
      </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0cb0035" name="Approve and Provision Subprocess"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="1028" posY="7">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Description>
      Add arguments as necessary to enable refresh features.  Typically you
      only want this to correlate roles.  Don't ask for provisioning  since that
      can result in provisioning policies that need to be presented and it's
      too late for that.  This is only to get role detection and exception
      entitlements in the cube.
    </Description>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Task" name="Notify" posX="1131" posY="7">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="source" value="ref:source"/>
      <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b02d0031" name="Identity Request Notify"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Policy Violation" posX="201" posY="253">
      <Arg name="message" value="Failed due to policy violation(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Manual Work Items" posX="364" posY="107">
      <Arg name="message" value="Failed due to manual work item(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Provisioning Form" posX="280" posY="178">
      <Arg name="message" value="Failed due to provisioning form"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Finalize" posX="1058" posY="308">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
    </Step>
    <Step icon="Stop" name="end" posX="1131" posY="253"/>
  </Workflow>
  <Workflow created="1615275074641" explicitTransitions="true" id="0a111e5c77a51bf3817815e5a4513b2b" libraries="Identity" modified="1616810609257" name="CF-MulitpleAccessProvisioningApprovalSubprocess-Workflow" type="Subprocess">
    <Variable initializer="serial" input="true" name="approvalMode">
      <Description>
      A string that specifies how we should handle the approvals.

      By default this is serial since most of these request with
      the exception of manager transfers will have only one approver.

      parallel
      Approvals are processed concurrently and there must be consensus,
      we wait for all approvers to approve.  The first approver that
      rejects terminates the entire approval.

      parallelPoll
      Approvals are processed concurrently but consensus is not required.
      All approvals will be processed, we don't stop if there are any
      rejections.

      serial
      Approvals are processed one at a time and there must be consensus.
      The first approver that rejects terminates the entire approval.

      serialPoll
      Approvals are processed in order but consensus is not required.
      All approvals will be processed, we don't stop if there are any
      rejections.  In effect we are "taking a poll" of the approvers.

      any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approval items should be generated 
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below 
      in any order, separated by commas. The order in which they are 
      specified is the order in which they are processed:

      owner
      The object owner gets the approval item. 
      For Role approvals this is the Role object owner. 
      For Entitlement approvals this is the Entitlement object owner.

      manager
      The manager gets the approval item.

      securityOfficer
      The identity in the variable securityOfficerName gets the approval item.

      identity
      The identities/workgroups in the variable approvingIdentities get the approval item.

    </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval 
      process.    
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.      
    </Description>
    </Variable>
    <Variable input="true" name="identityRequestId">
      <Description>
      The ID of the IdentityRequest for this request.
    </Description>
    </Variable>
    <Variable input="true" name="policyViolations">
      <Description>
      List of policy violations that were found during our initial policy scan.
      This list is passed into each work item so the approvers can see
      pending violations.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by object owners.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="managerEmailTemplate">
      <Description>
      Name of the email template to use when manager of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
      Name of the email template to use when notifying the owner of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="securityOfficerEmailTemplate">
      <Description>
      Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="identityEmailTemplate">
      <Description>
      Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable input="true" name="workItemDescription">
      <Description>String "template" that will be used as the workitem description.</Description>
    </Variable>
    <Variable input="true" name="workItemEscalationTemplate">
      <Description>The email template that should be used when sending out reminders.</Description>
    </Variable>
    <Variable input="true" name="workItemHoursBetweenReminders">
      <Description>The number of hours to wait between sending reminders to approvers.</Description>
    </Variable>
    <Variable input="true" name="workItemHoursTillEscalation">
      <Description>The number of hourse to wait until an approval should be escalated.</Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
      The String version of a WorkItem.Priority. This variable is
      used to set the priority on all of the workitems generated
      as part of this workflow and also set on the IdentityRequest
      object.
    </Description>
    </Variable>
    <Variable name="ownerName">
      <Description>ownerName.</Description>
    </Variable>
    <Variable input="true" name="workItemReminderTemplate">
      <Description>The email template that should be used when sending out reminders.</Description>
    </Variable>
    <Variable input="true" name="workItemEscalationRule">
      <Description>The rule used to assign a new ownder during escalation.</Description>
    </Variable>
    <Variable input="true" name="workItemMaxReminders">
      <Description>The maximum number of reminder emails that will be sent before we begin the escalation process.</Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="clearApprovalDecisions">
      <Description>True to clear all decisions when generating approvals</Description>
    </Variable>
    <Variable initializer="true" input="true" name="dontUpdatePlan">
      <Description>True to skip updating the ProvisioningProject masterPlan when processing approval decisions.</Description>
    </Variable>
    <Variable input="true" name="approvalSet" output="true">
      <Description>
      ApprovalSet representing the things that were requested and come from
      the master provisioning plan. 
    </Description>
    </Variable>
    <Variable input="true" name="project" output="true">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan, the 
      master plan will be adjusted when approval decisions are applied and a new 
      revised provisiobion project will be returned.
    </Description>
    </Variable>
    <Variable input="true" name="plan" output="true">
      <Description>The provisioning plan.</Description>
    </Variable>
    <Description>
    Simple approval subrocess introduced into release 6.2 to make
    adding custom approvals easier.  This approval subprocess
    has a configuration form to make it easier to configure
    from the Business Process Editor.
  </Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5c77a51bf3817815e56a493b27" name="CF-Library-MulitiAccessRequestWorkflowRuleLibrary-Rule"/>
      <Reference class="sailpoint.object.Rule" id="0a111e5875691e4f81758590d9e326ad" name="CF-CommonLibrary-Rule"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="20" posY="22">
      <Transition to="Approval"/>
    </Step>
    <Step icon="Approval" name="Approval" posX="158" posY="22">
      <Approval mode="ref:approvalMode" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId">
        <Arg name="launcher" value="ref:launcher"/>
        <Arg name="workItemDescription" value="ref:workItemDescription"/>
        <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
        <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
        <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
        <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
        <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
        <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
        <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
        <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
        <Arg name="workItemPriority" value="ref:workItemPriority"/>
        <Arg name="approvalMode" value="ref:approvalMode"/>
        <Arg name="approvalScheme" value="ref:approvalScheme"/>
        <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
        <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
        <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
        <Arg name="workItemRequester" value="$(launcher)"/>
        <Approval mode="serial" owner="script:multiAccessFirstLevelAppoval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessSecondApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessThirdApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessFourthApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessFifththApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
		  import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
            
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessSixththApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessSevenththApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>

            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessEieghthApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>
						import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
            
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);
						String displayNameOld="";
            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
             displayNameOld = identityCube.getDisplayName();
           
            l.add(displayNameOld);
            l.add("/");

            }
          

            modifiedOwnerName = displayNameOld;
            } else{
             displayNameOld = iq.getDisplayName();
            
            modifiedOwnerName=displayNameOld;
            }


            
            workflow.put("ownerName",modifiedOwnerName);
            }
            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
        <Approval mode="serial" owner="script:multiAccessNinethApproval(approvalSet,wfcontext);" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId,workItemNotificationTemplate">
          <AfterScript>
            <Source>
            import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          </Source>
          </AfterScript>
          <Arg name="launcher" value="ref:launcher"/>
          <Arg name="workItemDescription" value="ref:workItemDescription"/>
          <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
          <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
          <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
          <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
          <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
          <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
          <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
          <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
          <Arg name="workItemPriority" value="ref:workItemPriority"/>
          <Arg name="approvalMode" value="ref:approvalMode"/>
          <Arg name="approvalScheme" value="ref:approvalScheme"/>
          <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
          <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
          <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
          <Arg name="workItemRequester" value="$(launcher)"/>
          <InterceptorScript>
            <Source>
			import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;
            import sailpoint.object.Identity;
            import  sailpoint.api.ObjectUtil;
              
            String nameOfTheApprover = "";

            String modifiedOwnerName="";
            if(item !=null){
            Identity iq=item.getOwner();
            nameOfTheApprover=iq.getName();
            ArrayList l=new ArrayList();


            ObjectUtil obj = new ObjectUtil();

            Identity wg = context.getObjectByName(Identity.class, nameOfTheApprover);
            Identity identityCube=null;


            Iterator members = obj.getWorkgroupMembers(context, wg, null);

            if(members.hasNext()){
            while (members.hasNext()) {

            identityCube= (Identity)(members.next()[0]);
            l.add(identityCube.getDisplayName());
            l.add("/");

            }
            String replaceString=l.toString().replaceAll(", /,","/");

            modifiedOwnerName = replaceString.substring(1,replaceString.length() - 4);
            } else{
            modifiedOwnerName=iq.getDisplayName();
            }

            workflow.put("ownerName",modifiedOwnerName);
            }

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
          </Source>
          </InterceptorScript>
          <WorkItemConfig escalationStyle="none">
            <NotificationEmailTemplateRef>
              <Reference class="sailpoint.object.EmailTemplate" id="0a111e5875e014d081760d6cce5b3122" name="CF-ApproverNotification-EmailTemplate"/>
            </NotificationEmailTemplateRef>
          </WorkItemConfig>
        </Approval>
      </Approval>
      <Transition to="Process Approval Decisions" when="script:(step.getApproval() != null &amp;&amp; step.getApproval().containsApprovalItems())"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:processApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="420" resultVariable="project">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="disableAudit" value="true"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="recompilePlan" value="true"/>
      <Arg name="dontUpdatePlan" value="ref:dontUpdatePlan"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="420" posY="225"/>
  </Workflow>
  <Workflow created="1615275088569" explicitTransitions="true" id="0a111e5c77a51bf3817815e5dab93b2d" name="CF-MultipleAccessApproveandProvisionSubprocess-Workflow" type="Subprocess">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
            The displayName of the identity being updated.
            Query for this using a projection query and fall back to the name.
        </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
            The name of the LCM flow that launched this workflow.

            This is one of these three values:

            AccountsRequest
            EntitlementsRequest
            RolesRequest
        </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
            Set to true to enable optimistic provisioning.  This will cause
            changes to the entitlements compiled from role assignments to be
            applied immediately to the identity cube rather than waiting
            for the next refresh/reaggregation after the provisioning system
            completes the request.
        </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
            Normally provisioning is done in a step that uses the "background"
            option to force the workflow to be suspend and be resumed in a
            background task thread.  This prevents the browser session from
            hanging since provision can sometimes take a long time.  For demos
            and testing it can be better to do this in the foreground so that
            provisioning will have been performed when control is returned to the
            user.  This prevents having to run the Perform Maintenance task to
            see the results of the request.
        </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
            Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
        </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
            The email template to use for user notification.
        </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
            The email template to use for requester notification.
        </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
            The email template to use for manager notification.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
            The email template to use for security officer notification.
        </Description>
    </Variable>
    <Variable initializer="parallel" input="true" name="approvalMode">
      <Description>
            A string that specifies how we should handle the approvals.

            By default this is serial since most of these request with
            the exception of manager transfers will have only one approver.

            parallel
            Approvals are processed concurrently and there must be consensus,
            we wait for all approvers to approve.  The first approver that
            rejects terminates the entire approval.

            parallelPoll
            Approvals are processed concurrently but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.

            serial
            Approvals are processed one at a time and there must be consensus.
            The first approver that rejects terminates the entire approval.

            serialPoll
            Approvals are processed in order but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.  In effect we are "taking a poll" of the approvers.

            any
            Approvals are processed concurrently, the first approver to
            respond makes the decision for the group.
        </Description>
    </Variable>
    <Variable initializer="owner" input="true" name="approvalScheme">
      <Description>
            A csv string that specifies how approval items should be generated
            for the incoming request.

            The value can be "none", in which case approvals are disabled.

            The value can also be a combination of any of the values below
            in any order, separated by commas. The order in which they are
            specified is the order in which they are processed:

            owner
            The object owner gets the approval item.
            For Role approvals this is the Role object owner.
            For Entitlement approvals this is the Entitlement object owner.

            manager
            The manager gets the approval item.

            securityOfficer
            The identity in the variable securityOfficerName gets the approval item.

            identity
            The identities/workgroups in the variable approvingIdentities get the approval item.
        </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
            The email template to use for approval notifications.
        </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
            The String version of a WorkItem.Priority. This variable is
            used to set the priority on all of the workitems generated
            as part of this workflow and also set on the IdentityRequest
            object.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
            The name of the identity that will be sent approvals
            during security officer approvals.
        </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
            A String that specifies the name of the Identity that will
            be assigned any approvals where the owner of the approver
            can't be resolved. Example if the scheme is "owner" and the
            application doesn't specify and owner.
        </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
            When set to true it will disable the workflow retry loop and let the
            Provision step launch requests to handle the retries.  Enabling
            this flag will enable some older functionality.
        </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to LCM.
        </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
            Used for debugging this workflow and when set to true trace
            will be sent to stdout.
        </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
            This attributes is set during the "Build Approval Set" step,
            which builds this list by going through the ProvisioningPlan
            to build the line items that need to be approved,

            This variable includes all ApprovalItems that are part of
            the request process and is updated during the AfterScript
            of the approval process by assimilating the decisions
            and comments from the Approvals copy of the ApprovalItem.
        </Description>
    </Variable>
    <Variable input="true" name="approvalAssignmentRule"/>
    <Variable name="project">
      <Description>
            ProvisioningProject which is just a compiled version of the ProvisioningPlan.
        </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
            List of policy violations that were found during our initial policy scan.
            This list is passed into each work item so the approvers can see
            pending violations.
        </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
            The sequence id of the Identity request object which is stored in
            the name field of the identity request and auto-incremented.
        </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
            Global comments accumulated during the workflow which should be shared
            with other approvals. When a new approval is created, the comments in this
            list will be added to the work item.
        </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
            Name of the application that can handle ticket requests.
            When non-null the Manage Ticket Steps will be visited to open
            tickets during the workflow lifecycle.
        </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by a manager.
        </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by object owners.
        </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by the security officer.
        </Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable input="true" name="approvalSplitPoint">
      <Description>Approval Scheme to split on.</Description>
    </Variable>
    <Variable input="true" name="clearApprovalDecisions">
      <Description>
            True to clear any decisions on approvals built with buildCommonApprovals
        </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
            List of identities and/or workgroups names/ids that should be involved in the approval
            process.
        </Description>
    </Variable>
    <Variable input="true" name="formTemplate"/>
    <Variable input="true" name="manualActionsEmailTemplate"/>
    <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
      <Description>
            Name of the email template to use when notifying the owner of pending approvals.
        </Description>
    </Variable>
    <Variable initializer="false" input="true" name="splitProvisioning">
      <Description>
            True to tell IdentityRequest Provisioning subprocess that this is a subset of the initial provisioning plan
        </Description>
    </Variable>
    <Description>Subprocess to approve and provision immediately. This is used after splitting an ApprovalSet into individual items to run in parallel.</Description>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="20" posY="20">
      <Transition to="Compile Project"/>
    </Step>
    <Step action="call:compileProvisioningProject" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Compile Project" posX="120" posY="20" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="noApplicationTemplates">
        <Script>
          <Source>
                    boolean ignoreForms = false;
                    if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
                    ignoreForms = true;
                    }
                    return ignoreForms;
                </Source>
        </Script>
      </Arg>
      <Transition to="Build Approval Set"/>
    </Step>
    <Step action="call:buildSplitApprovalSet" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Build Approval Set" posX="220" posY="20" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Approve"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" configForm="Provisioning Approval Step Form" icon="Approval" name="Approve" posX="320" posY="20">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature"/>
      <Arg name="identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="workItemComments"/>
      <Arg name="clearApprovalDecisions" value="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c77a51bf3817815e5a4513b2b" name="CF-MulitpleAccessProvisioningApprovalSubprocess-Workflow"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Approval"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="470" posY="20">
      <Arg name="action" value="postApproval"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Provision"/>
    </Step>
    <Step icon="Provision" name="Provision" posX="600" posY="20">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
      <Description>
            Call the standard subprocess that will process the
            approval decisions and do provisioning.  This
            includes calling any configured provisioning
            connectors and building manual actions.
        </Description>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0510032" name="Identity Request Provision"/>
      </WorkflowRef>
      <Transition to="Update Ticket Post Provision"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="700" posY="20">
      <Arg name="action" value="postProvisioning"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
    </Step>
  </Workflow>
  <Workflow configForm="Provisioning Workflow Config Form" created="1616506839247" handler="sailpoint.api.StandardWorkflowHandler" id="0a111e5c785d172f81785f50e0cf0989" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" name="OOTB_LCMProvisioning" taskType="LCM" type="LCMProvisioning">
    <Variable input="true" name="identityName">
      <Description>The name of the identity being updated.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work items.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
    </Variable>
    <Variable input="true" name="plan">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these three values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
    </Description>
    </Variable>
    <Variable editable="true" initializer="false" name="optimisticProvisioning">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable editable="true" initializer="true" name="foregroundProvisioning">
      <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
    </Variable>
    <Variable input="true" name="batchRequestItemId">
      <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
    </Variable>
    <Variable editable="true" name="doRefresh">
      <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
    </Variable>
    <Variable initializer="user,requester" input="true" name="notificationScheme">
      <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
    </Variable>
    <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
      <Description>
     The email template to use for user notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
      <Description>
     The email template to use for requester notification.
    </Description>
    </Variable>
    <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
      <Description>
     The email template to use for manager notification.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerEmailTemplate">
      <Description>
     The email template to use for security officer notification.
    </Description>
    </Variable>
    <Variable initializer="parallel" input="true" name="approvalMode">
      <Description>
        A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.  In effect we are "taking a poll" of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.
    </Description>
    </Variable>
    <Variable initializer="owner" input="true" name="approvalScheme">
      <Description>
      A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item.
        For Role approvals this is the Role object owner.
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.
    </Description>
    </Variable>
    <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
      <Description>
     The email template to use for approval notifications.
    </Description>
    </Variable>
    <Variable initializer="Normal" input="true" name="workItemPriority">
      <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerName">
      <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
    </Variable>
    <Variable initializer="spadmin" input="true" name="fallbackApprover">
      <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      continue -  continue if policy violations are found

      interactive -  allow requester to remove request items which are causing violations

      fail -  this option will cause the workflow to terminate immediately if any policy violations are found.
              Note that the requester will not be notified that the workflow has terminated.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
    </Variable>
    <Variable name="approvalSet">
      <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable initializer="true" name="allowRequestsWithViolations">
      <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request. This is only relevant
      if policyScheme=interactive.
    </Description>
    </Variable>
    <Variable initializer="true" name="requireViolationReviewComments">
      <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations. This
      is only relevant if policyScheme=interactive.
    </Description>
    </Variable>
    <Variable name="project">
      <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
    </Variable>
    <Variable name="policyViolations">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable name="identityRequestId" output="true">
      <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request and auto-incremented.
    </Description>
    </Variable>
    <Variable name="violationReviewDecision">
      <Description>
       Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

       -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

     </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
      Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.
    </Description>
    </Variable>
    <Variable input="true" name="ticketManagementApplication">
      <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
    </Variable>
    <Variable name="ticketId">
      <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
    </Variable>
    <Variable input="true" name="managerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
    </Variable>
    <Variable input="true" name="ownerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
    </Variable>
    <Variable input="true" name="securityOfficerElectronicSignature">
      <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
    </Variable>
    <Variable input="true" name="approvingIdentities">
      <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval
      process.
    </Description>
    </Variable>
    <Variable input="true" name="identityElectronicSignature">
      <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.
    </Description>
    </Variable>
    <Variable input="true" name="identityEmailTemplate">
      <Description>
      Name of the email template to use when notifying the identities/workgroups of pending approvals.
    </Description>
    </Variable>
    <Variable initializer="true" input="true" name="filterRejects">
      <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
      <Description>True to pre-populate approval decisions from previous approvals.</Description>
    </Variable>
    <Variable name="approvalSplitPoint">
      <Description>
          Variable to determine when to split into parallel processing.
          This should map to a configured approvalScheme. We will process all schemes up until
          the approvalSplitPoint in the Pre Split approvals, and the remaining schemes after
          we split the items. If this is not specified, we will not split the Provisioning
          project, and process the entire project as a whole.
      </Description>
    </Variable>
    <Variable name="splitPlans">
      <Description>
          List of ProvisioningPlan that is generated from the splitPlans step if approvalSplitPoint is set.
      </Description>
    </Variable>
    <Variable name="splitProjects">
      <Description>
          Variable to store the returns if approvalSplitPoint is set. This will contain a List&lt;ProvisioningProject>
      </Description>
    </Variable>
    <Variable name="splitApprovalSet">
      <Description>
          Variable to store the list of approvalSets returned from the split subprocess if approvalSplitPoint is set.
      </Description>
    </Variable>
    <Variable name="splitWorkItemComments">
      <Description>
          Variable to store the list of WorkItem comments returned from the split subprocess if approvalSplitPoint is set.
      </Description>
    </Variable>
    <RuleLibraries>
      <Reference class="sailpoint.object.Rule" id="0a111e58754c15ea81754c468af8017b" name="LCM Workflow Library"/>
    </RuleLibraries>
    <Step icon="Start" name="Start" posX="25" posY="10">
      <Transition to="Initialize"/>
    </Step>
    <Step icon="Task" name="Initialize" posX="134" posY="10">
      <Arg name="flow" value="ref:flow"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
      <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
      <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
      <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
      <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="identityRequestId" to="identityRequestId"/>
      <Return name="violationReviewDecision" to="violationReviewDecision"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afde002f" name="Identity Request Initialize"/>
      </WorkflowRef>
      <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Exit On Policy Violation" when="script:(&quot;cancel&quot;.equals(violationReviewDecision) || ((size(policyViolations) > 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;))))"/>
      <Transition to="Create Ticket"/>
    </Step>
    <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="381" posY="6">
      <Arg name="action" value="open"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="ticketDataGenerationRule" value=""/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="ticketId" value="ref:ticketId"/>
      <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
      <Return name="ticketId" to="externalTicketId"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c468a3d016f" name="Manage Ticket"/>
      </WorkflowRef>
      <Transition to="Pre Split Approve" when="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
      <Transition to="Approve and Provision"/>
    </Step>
    <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" icon="Task" name="Pre Split Approve" posX="518" posY="63">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme">
        <Script>
          <Source>
              import java.util.List;
              import java.util.ArrayList;
              import java.util.Iterator;
              import sailpoint.tools.Util;

              List schemes = Util.csvToList(approvalScheme);
              List preSchemes = new ArrayList&lt;String>();
              for (String s : Util.safeIterable(schemes)) {
                if (s.equals(approvalSplitPoint)) {
                    break;
                } else {
                    preSchemes.add(s);
                }
              }
              return Util.listToCsv(preSchemes);
          </Source>
        </Script>
      </Arg>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule"/>
      <Arg name="workItemComments"/>
      <Description>
      Call to our standard subprocess to handle the default approvals for
      manager, owner and security officer.
    </Description>
      <Return name="approvalSet"/>
      <Return name="workItemComments"/>
      <Return name="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c46935f0198" name="Provisioning Approval Subprocess"/>
      </WorkflowRef>
      <Transition to="Split Plan"/>
    </Step>
    <Step action="call:splitProvisioningPlan" icon="Task" name="Split Plan" posX="618" posY="63" resultVariable="splitPlans">
      <Arg name="project" value="ref:project"/>
      <Description>
          Step to split the provisioning project into individual projects for each item requested.
          This will only run if the approvalSplitPoint is configured.
      </Description>
      <Transition to="Approve and Provision Split"/>
    </Step>
    <Step icon="Task" name="Approve and Provision Split" posX="783" posY="63">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme">
        <Script>
          <Source>
              import java.util.List;
              import java.util.Iterator;
              import sailpoint.tools.Util;
              List schemes = Util.csvToList(approvalScheme);
              Iterator it = schemes.iterator();
              while (it.hasNext()) {
                String s = it.next();
                if (!s.equals(approvalSplitPoint)) {
                    it.remove();
                } else {
                    break;
                }
              }
              return Util.listToCsv(schemes);
            </Source>
        </Script>
      </Arg>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="splitProvisioning" value="true"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
          Call the Approve and Provision Subprocess for each Provisioning Project generated in the Split Plan step.
      </Description>
      <Replicator arg="plan" items="splitPlans"/>
      <Return name="project" to="splitProjects"/>
      <Return name="workItemComments" to="splitWorkItemComments"/>
      <Return name="approvalSet" to="splitApprovalSet"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0cb0035" name="Approve and Provision Subprocess"/>
      </WorkflowRef>
      <Transition to="Assimilate Splits"/>
    </Step>
    <Step action="call:joinLCMProvWorkflowSplits" icon="Task" name="Assimilate Splits" posX="914" posY="63">
      <Arg name="splitProjects" value="ref:splitProjects"/>
      <Arg name="splitWorkItemComments" value="ref:splitWorkItemComments"/>
      <Arg name="splitApprovalSet" value="ref:splitApprovalSet"/>
      <Description>
          Assimilate all projects returned from the split into the global project.
      </Description>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step icon="Task" name="Approve and Provision" posX="699" posY="7">
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="approvalAssignmentRule"/>
      <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
      <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
      <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
      <Arg name="formTemplate" value="Identity Update"/>
      <Arg name="filterRejects" value="ref:filterRejects"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
      <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="splitProvisioning" value="false"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
          Finish any remaining approvals and provision.
      </Description>
      <Return name="project" to="project"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b0cb0035" name="Approve and Provision Subprocess"/>
      </WorkflowRef>
      <Transition to="Refresh Identity"/>
    </Step>
    <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="1028" posY="7">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="correlateEntitlements" value="true"/>
      <Description>
      Add arguments as necessary to enable refresh features.  Typically you
      only want this to correlate roles.  Don't ask for provisioning  since that
      can result in provisioning policies that need to be presented and it's
      too late for that.  This is only to get role detection and exception
      entitlements in the cube.
    </Description>
      <Transition to="Notify"/>
    </Step>
    <Step icon="Task" name="Notify" posX="1131" posY="7">
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="notificationScheme" value="ref:notificationScheme"/>
      <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
      <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
      <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="policyViolations" value="ref:policyViolations"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
      <Arg name="trace" value="ref:trace"/>
      <Arg name="source" value="ref:source"/>
      <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b02d0031" name="Identity Request Notify"/>
      </WorkflowRef>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Policy Violation" posX="201" posY="253">
      <Arg name="message" value="Failed due to policy violation(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Manual Work Items" posX="364" posY="107">
      <Arg name="message" value="Failed due to manual work item(s)"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step action="call:addMessage" name="Exit On Provisioning Form" posX="280" posY="178">
      <Arg name="message" value="Failed due to provisioning form"/>
      <Arg name="type" value="Error"/>
      <Transition to="end"/>
    </Step>
    <Step catches="complete" icon="Catches" name="Finalize" posX="1058" posY="308">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
      <Arg name="trace" value="ref:trace"/>
      <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40b06a0033" name="Identity Request Finalize"/>
      </WorkflowRef>
    </Step>
    <Step icon="Stop" name="end" posX="1131" posY="253"/>
  </Workflow>
  <Workflow created="1616584753481" id="0a111e5c785d172f817863f5c1491b2e" libraries="Identity,IdentityRequest" name="CF-IdentityRequestInitialize-Workflow" type="Subprocess">
    <Variable input="true" name="identityName" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable input="true" name="launcher" required="true">
      <Description>
      The name of the identity object being modified.
    </Description>
    </Variable>
    <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
      <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable initializer="script:(launcherDisplayName != void) ? launcherDisplayName : resolveDisplayName(launcher)" input="true" name="launcherDisplayName">
      <Description>
      The displayName of the launcher
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnManualWorkItems">
      <Description>Option to skip requests with manual work iems.</Description>
    </Variable>
    <Variable initializer="false" input="true" name="endOnProvisioningForms">
      <Description>Option to skip requests with provisioning forms.</Description>
    </Variable>
    <Variable input="true" name="flow">
      <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
    </Variable>
    <Variable input="true" name="plan" required="true">
      <Description>The provisioning plan ready to execute.</Description>
    </Variable>
    <Variable input="true" name="optimisticProvisioning" required="true">
      <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
    </Variable>
    <Variable input="true" name="asyncCacheRefresh">
      <Description>
      Set to true to enable asynchronous refresh of the policy and role
      caches.  This speeds up response time for the LCM user, but you
      may want to disable this during demonstrations after editing
      the role or policy models.  This may also be enabled globally
      in the system configuration.  This variable overrides the
      system configuration if it has a value.
    </Description>
    </Variable>
    <Variable input="true" name="policiesToCheck">
      <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
    </Variable>
    <Variable input="true" name="allowRequestsWithViolations">
      <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request.
    </Description>
    </Variable>
    <Variable input="true" name="requireViolationReviewComments">
      <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations.
     </Description>
    </Variable>
    <Variable initializer="Identity Update" input="true" name="formTemplate">
      <Description>
      Template used when processing provisioning forms.
    </Description>
    </Variable>
    <Variable initializer="false" name="trace">
      <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
    </Variable>
    <Variable initializer="continue" input="true" name="policyScheme">
      <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      interactive -  allow requester to remove request items which are causing violations

      continue -  continue if policy violations are found

      fail -  fail and exit the workflow if any policy violations are found

    </Description>
    </Variable>
    <Variable initializer="LCM" input="true" name="source">
      <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
    </Variable>
    <Variable input="true" name="workItemPriority">
      <Description>
      String version of WorkItem.level that will be used
      to set the priority any generated workitems. It will
      also configure the priority of the request as
      on the generated Access Request.
    </Description>
    </Variable>
    <Variable initializer="false" input="true" name="enableRetryRequest">
      <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
    </Variable>
    <Variable name="project" output="true">
      <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
    </Variable>
    <Variable name="policyViolations" output="true">
      <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
    </Variable>
    <Variable name="approvalSet" output="true">
      <Description>
       This attribute is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved.

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
    </Variable>
    <Variable name="identityRequest">
      <Description>
       The request object we get back from the create call. This is
       primarily useful for debugging.
    </Description>
    </Variable>
    <Variable name="identityRequestId">
      <Description>
        The id of the IdentityRequest created.
    </Description>
    </Variable>
    <Variable name="violationReviewDecision" output="true">
      <Description>
     Decision made by the user in the Policy Violation Review step.
     This may be one of three choices:

     -ignore:   User is ignoring the violations and letting the request continue. If
                 requireViolationReviewComments=true the user will be required to enter
                 comments indicating why they are allowing the violations.

     -remediate: Indicates that the user removed the request items that were causing the
                 violations

     -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

    </Description>
    </Variable>
    <Variable initializer="script:( Util.otob(getConfiguration(&quot;lcmEnableApprovalRecommendations&quot;)))" input="true" name="enableApprovalRecommendations">
      <Description>
        Flag to determine if recommendations should be gathered for the approvals.
      </Description>
    </Variable>
    <Variable name="workItemComments">
      <Description>
      Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.
    </Description>
    </Variable>
    <Description>
      This workflow subprocess is used to initialize the various
      object necessary when executing workflows that deal
      with provisioning.

      This subprocess was added in 5.5 in an effort to
      break groups of related steps into a single call
      from the top level workflow.

      It now encapsulates the following services:

        - Compliation of the plan into a project
        - Build an approval set
           defaults to using buildApprovalSet but allows it to be passed in
        - Audit Start
        - Create the IdentityRequest object for the request tracking
        - Check policies
        - Build required forms for the launcher

  </Description>
    <Step icon="Start" name="Start" posX="25" posY="15">
      <Transition to="Compile Project"/>
    </Step>
    <Step action="call:compileProvisioningProject" icon="Task" name="Compile Project" posX="121" posY="15" resultVariable="project">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="source" value="ref:source"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
      <Arg name="noApplicationTemplates">
        <Script>
          <Source>
            boolean ignoreForms = false;
            if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
               ignoreForms = true;
            }
            return ignoreForms;
        </Source>
        </Script>
      </Arg>
      <Arg name="noLocking">
        <Script>
          <Source>
            boolean noLocking = false;
            if ("Lifecycle".equals(flow)) {
               noLocking = true;
            }
            return noLocking;
        </Source>
        </Script>
      </Arg>
      <Description>Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.</Description>
      <Transition to="end" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
      <Transition to="end" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
      <Transition to="Build Approval Set" when="script:isNull(approvalSet)"/>
      <Transition to="Rebuild Approval Set"/>
    </Step>
    <Step action="call:buildApprovalSet" condition="script:isNull(approvalSet)" name="Build Approval Set" posX="260" posY="92" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Check Policies"/>
    </Step>
    <Step condition="script:(!policyScheme.equals(&quot;none&quot;))" name="Check Policies" posX="391" posY="92">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="plan" value="ref:plan"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="policyScheme" value="ref:policyScheme"/>
      <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
      <Arg name="asyncCacheRefresh" value="ref:asyncCacheRefresh"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
      <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
      <Return name="policyViolations" to="policyViolations"/>
      <Return name="project" to="project"/>
      <Return name="plan" to="plan"/>
      <Return name="violationReviewDecision" to="violationReviewDecision"/>
      <Return merge="true" name="workItemComments" to="workItemComments"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e5c756f1eb681756f40afc9002e" name="Identity Request Violation Review"/>
      </WorkflowRef>
      <Transition to="end" when="script:(&quot;cancel&quot;.equals(violationReviewDecision))"/>
      <Transition to="end" when="script:((policyScheme.equals(&quot;fail&quot;) &amp;&amp; (size(policyViolations) > 0 )  ))"/>
      <Transition to="Rebuild Approval Set"/>
    </Step>
    <Step action="call:buildApprovalSet" name="Rebuild Approval Set" posX="187" posY="252" resultVariable="approvalSet">
      <Arg name="plan" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Build Approval Recommendations"/>
    </Step>
    <Step action="call:populateRecommendationsInApprovalSet" condition="ref:enableApprovalRecommendations" name="Build Approval Recommendations" posX="322" posY="252" resultVariable="approvalSet">
      <Arg name="identitySource" value="ref:plan"/>
      <Return name="approvalSet" to="approvalSet"/>
      <Transition to="Audit Start"/>
    </Step>
    <Step action="call:auditLCMStart" icon="Audit" name="Audit Start" posX="439" posY="252">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Transition to="Create Identity Request"/>
    </Step>
    <Step action="call:createIdentityRequest" icon="Task" name="Create Identity Request" posX="577" posY="252" resultVariable="identityRequest">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="flow" value="ref:flow"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="source" value="ref:source"/>
      <Transition to="Do Provisioning Forms Pre-Approval"/>
    </Step>
    <Step icon="Task" name="Do Provisioning Forms Pre-Approval" posX="741" posY="252">
      <Arg name="identityName" value="ref:identityName"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="formTemplate" value="ref:formTemplate"/>
      <Arg name="requiredOwner" value="ref:sessionOwner"/>
      <Arg name="workItemComments" value="ref:workItemComments"/>
      <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms that can be filled out before approvals.
    </Description>
      <Return name="approvalSet" to="approvalSet"/>
      <Return name="project" to="project"/>
      <WorkflowRef>
        <Reference class="sailpoint.object.Workflow" id="0a111e58754c15ea81754c4689ef016a" name="Do Provisioning Forms"/>
      </WorkflowRef>
      <Transition to="Assimilate Account Id Changes"/>
    </Step>
    <Step action="call:assimilateAccountIdChanges" icon="Task" name="Assimilate Account Id Changes" posX="740" posY="119" resultVariable="approvalSet">
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="project" value="ref:project"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Description>
      Assimilate the result of any accountId changes that may have been compiled into the plan back onto the ApprovalSet and IdentityRequest.
    </Description>
      <Transition to="Notify Requester"/>
    </Step>
    <Step action="call:sendEmail" icon="Email" name="Notify Requester" posX="216" posY="10">
      <Arg name="template" value="CF-Requester-EmailTemplate"/>
      <Arg name="to" value="script:getEmail(launcher)"/>
      <Arg name="identityRequestId" value="ref:identityRequestId"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="launcherDisplayName" value="ref:launcherDisplayName"/>
      <Transition to="end"/>
    </Step>
    <Step icon="Stop" name="end" posX="740" posY="12"/>
  </Workflow>
</sailpoint>
